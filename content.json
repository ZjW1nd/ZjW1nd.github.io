{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"对跳表机制及其静态逆向的一些想法","slug":"对跳表机制及其静态逆向的一些想法","date":"2023-11-06T08:52:08.000Z","updated":"2023-11-06T15:05:03.079Z","comments":true,"path":"2023/11/06/对跳表机制及其静态逆向的一些想法/","link":"","permalink":"http://example.com/2023/11/06/%E5%AF%B9%E8%B7%B3%E8%A1%A8%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%85%B6%E9%9D%99%E6%80%81%E9%80%86%E5%90%91%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95/","excerpt":"","text":"之前没有听说过跳转表这个词，查了查什么是跳转表，看起来是个用到一些数据结构思想的有点意思的编译机制🤔。 什么是跳表？跳转表（jump table）是GCC编译器在汇编时针对C语言的switch语句采用的一种汇编机制。查资料的时候发现CSAPP上有讲，这里就结合书上的内容和自己的理解给出一点解释，那我们先来看看switch是如何在汇编层面实现的吧。 switch开关语句可以根据一个整数索引值进行多重分支，提高了C代码的可读性。通过使用跳转表，它的实现可以更加高效。跳转表是一个数组，表项 i 是一个代码片段的地址，这个片段实现当开关索引值为 i 的时候程序应采取的动作。程序代码使用开关索引值来执行一个跳转表内部的数组引用，确定跳转指令的目标。和 if-else 语句相比，跳转表的优点是执行开关语句的时间与开关情况的数量无关。———摘自《深入理解计算机系统》 3.6.8 先简单说，这就是一个 O(1) 的索引然后跳转。不这样的话，汇编层面会变成一连串的类似“if-else”的连续的 cmp + jcc 结构。那么编译器是怎么分别这两种情况的呢？ 汇编器在遇到switch语句的时候会先评估case分支的“稀疏程度”，选择使用来进行编译，还是使用跳转表进行编译。这种判断，本质上是一种时间和空间的权衡。对于cmp+jcc结构的编译方法就不过多赘述，类似于下面这种: 当汇编器认为开关数量比较多（部分版本是4个以上）并且跨度较小分布密集的时候，就会采用跳转表进行编译，类似下面这种。 汇编器首先将所有的整数索引值区间移动到一个“最小值从0开始”的区间上，然后用这个转化后的索引值作为数组下标去跳转表中搜寻地址。 IDA在面对跳表的时候出了什么问题？手动修复IDA跳表","categories":[],"tags":[{"name":"pwn IDA 逆向","slug":"pwn-IDA-逆向","permalink":"http://example.com/tags/pwn-IDA-%E9%80%86%E5%90%91/"}]},{"title":"pwntools的shellcode逻辑详解","slug":"pwntools的shellcode逻辑详解","date":"2023-10-26T13:21:09.000Z","updated":"2023-11-02T07:04:07.339Z","comments":true,"path":"2023/10/26/pwntools的shellcode逻辑详解/","link":"","permalink":"http://example.com/2023/10/26/pwntools%E7%9A%84shellcode%E9%80%BB%E8%BE%91%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"先看看pwntools的shellcraft.amd64.sh()为我们提供了怎样的一段代码 12345678910111213141516171819202122/* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) *//* push b&#x27;/bin///sh\\x00&#x27; */push 0x68mov rax, 0x732f2f2f6e69622fpush rax //64位数据不能直接pushmov rdi, rsp //第一个参数设置成了/bin///sh\\x00的地址/* push argument array [&#x27;sh\\x00&#x27;] *//* push b&#x27;sh\\x00&#x27; */push 0x1010101 ^ 0x6873xor dword ptr [rsp], 0x1010101xor esi, esi /* 0 */push rsi /* null terminate */push 8 pop rsiadd rsi, rsppush rsi /* &#x27;sh\\x00&#x27; */mov rsi, rspxor edx, edx /* 0 *//* call execve() */push SYS_execve /* 0x3b */pop raxsyscall 可以看到这段代码是为了执行execve(path=&#39;/bin///sh&#39;, argv=[&#39;sh&#39;], envp=0)，但是似乎看起来有些长了，我们看看它干了些什么 0x68732f2f2f6e69622f 是&#x2F;bin&#x2F;sh的逆序hs&#x2F;&#x2F;&#x2F;nib&#x2F;，也就是首先将我们等下要调用的参数压栈。可以理解的是这段shellcode在尽可能的避免出现\\x00字符，但是似乎使用&#x2F;bin&#x2F;&#x2F;sh就够了？简单的mov rdi,rsp后，第一个参数就控制完成了 然后是令人疑惑的一步异或操作，首先execve(&quot;/bin/sh&quot;,0,0)就可以运行，这里的shellcode想把入口参数设为sh也可，但是采用了先疑惑一下入栈再异或回来，没有看懂然后通过push 8;pop rsi实现了mov rsi,8的效果，然后rsi和rsp相加，令rsi（第二个参数）指向了栈上上一个元素–”sh”（此时栈顶是0）然后的push rsi;mov rsi, rsp令rsi存放了“sh”的地址，至此，第一个和第二个参数的控制都完成了 第三个参数很简单，只需要清空edx就行。最后通过栈将execve的系统调用号传入rax，执行调用就可以拿到shell。 事情到这里似乎结束了？这段代码有48字节长： 123456789101112131415161718190000000000401000 &lt;_start&gt;: 401000: 6a 68 push 0x68 401002: 48 b8 2f 62 69 6e 2f movabs rax,0x732f2f2f6e69622f 401009: 2f 2f 73 40100c: 50 push rax 40100d: 48 89 e7 mov rdi,rsp 401010: 68 72 69 01 01 push 0x1016972 401015: 81 34 24 01 01 01 01 xor DWORD PTR [rsp],0x1010101 40101c: 31 f6 xor esi,esi 40101e: 56 push rsi 40101f: 6a 08 push 0x8 401021: 5e pop rsi 401022: 48 01 e6 add rsi,rsp 401025: 56 push rsi 401026: 48 89 e6 mov rsi,rsp 401029: 31 d2 xor edx,edx 40102b: 6a 3b push 0x3b 40102d: 58 pop rax 40102e: 0f 05 syscall 它借助了栈来实现执行了execve(&quot;/bin///sh&quot;,&quot;sh&quot;,0)。但是里面采用了很多怪怪的操作，我们试试能不能通过优化这些操作来减少shellcode的大小。在将异或操作改成直接push 0x6873后，手动编译成功的文件照样成功运行了。但是在objdump的时候就能发现，shellcode里出现了\\x00: 1401010: 68 73 68 00 00 push 0x6873 不太妙，看来pwntools成为经典是有原因的。那干脆如果允许读入\\x00，我们能否再精简shellcode呢？我们做一些尝试： 12345678910global _start_start: mov rax, 0x68732f2f6e69622f push rax mov rdi, rsp ;rdi set successfully xor rsi,rsi ;try xor rdx,rdx mov rax,0x3b syscall 这样写是不行的，syscall并不会进入shell。了解之后知道，execve的第二个参数必须以一个指向空的指针结尾，也就是说第二个参数也要传入一个合法的地址。查到了一个这样的shellcode： 123456789401000: 48 31 d2 xor rdx,rdx401003: 52 push rdx401004: 48 89 e6 mov rsi,rsp401007: 48 b8 2f 62 69 6e 2f movabs rax,0x68732f2f6e69622f40100e: 2f 73 68 401011: 50 push rax401012: 48 89 e7 mov rdi,rsp401015: b8 3b 00 00 00 mov eax,0x3b40101a: 0f 05 syscall 看完确实令人感叹。这个shellcode的巧妙在于，将第二个参数和第三个参数的设置过程进行了融合复用，环境变量数组为0看来是合法的，那就将0先入栈然后将地址传给rsi，同时这样写也实现了’&#x2F;bin&#x2F;sh’最后在栈中以\\x00结束，非常的巧妙。我们看到这样写的shellcode只有26字节大小，只是在mov eax,0x3b设置系统调用的地方有三个\\x00。如果这里我们使用pwntools的栈的方法优化一下？ 12345678910401000: 48 31 d2 xor rdx,rdx401003: 52 push rdx401004: 48 89 e6 mov rsi,rsp401007: 48 b8 2f 62 69 6e 2f movabs rax,0x68732f2f6e69622f40100e: 2f 73 68 401011: 50 push rax401012: 48 89 e7 mov rdi,rsp401015: 6a 3b push 0x3b401017: 58 pop rax401018: 0f 05 syscall 没有\\x00!而且只要24字节就能实现。不觉得这很酷吗？我觉得这太酷了。shellcode也没那么复杂。x86传参，网上看到的教程似乎都是__fastcall调用方式,最终两个参数好像是用ecx和ebx在传递而不是栈。逻辑也是类似的。","categories":[],"tags":[]},{"title":"安卓逆向学习记录","slug":"安卓逆向学习记录","date":"2023-10-26T13:20:33.000Z","updated":"2023-11-06T10:45:45.592Z","comments":true,"path":"2023/10/26/安卓逆向学习记录/","link":"","permalink":"http://example.com/2023/10/26/%E5%AE%89%E5%8D%93%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","excerpt":"","text":"妈的，学个鸡","categories":[],"tags":[{"name":"不会","slug":"不会","permalink":"http://example.com/tags/%E4%B8%8D%E4%BC%9A/"}]},{"title":"my_first_blog","slug":"my-first-blog","date":"2023-10-26T11:58:33.000Z","updated":"2023-10-26T13:31:06.663Z","comments":true,"path":"2023/10/26/my-first-blog/","link":"","permalink":"http://example.com/2023/10/26/my-first-blog/","excerpt":"","text":"My First Blog段落居然是markdown，不过或许这已经是部署网页博客最方便的集成办法了。后续肯定要优化的？md是类似python的顺序解释语言这样没法换行这样可以换行“两个空格加一个回车或者回车加空行” 这样是分割线“***”这是斜体“两个星号包起来”这是加粗“两个星号”这是加粗斜体“三个星号包起来”这是删除线 “一对波浪线包起来”这是下划线，用html的一对u标签实现这是脚注^1 列表非常符合直觉的设计： 只用星号或加号或减号+空格就可以创建无序列表 像这样 而有序列表使用数字加点加空格 像这样嵌套只需要前面加四个空格 像这样 这样 这样 像这样 这样，无需换行两空格标记 区块需要使用大于号标记 数量表示层数 这样是第一层第一层继续 这样是第二层 这样是第三层 上述所有符号都是可嵌套的 像这样 或者这样 或者 这样 代码简单的引用用反引号标记（键盘左上角）printf这样代码块使用三个引号加语言类型（可选）进行标记 12#include&lt;stdio.h&gt; //像这样&#x27;&#x27;&#x27;C开头 链接引用这是一个链接 主页重定向或者http://zjw1nd.github.io变量的机制？主页 图片","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2023-10-26T11:47:40.285Z","updated":"2023-10-26T11:47:40.285Z","comments":true,"path":"2023/10/26/hello-world/","link":"","permalink":"http://example.com/2023/10/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"pwn IDA 逆向","slug":"pwn-IDA-逆向","permalink":"http://example.com/tags/pwn-IDA-%E9%80%86%E5%90%91/"},{"name":"不会","slug":"不会","permalink":"http://example.com/tags/%E4%B8%8D%E4%BC%9A/"}]}